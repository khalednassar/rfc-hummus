<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc7692
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.34.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.34.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-hybi-permessage-compression/">
  <meta name="description" content="Compression Extensions for WebSocket (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.34.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.34.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgblue"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc7692.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc7692.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7692.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc7692/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc7692/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/hybi/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-hybi-permessage-compression@ietf.org?subject=draft-ietf-hybi-permessage-compression" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-hybi-permessage-compression-28.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-hybi-permessage-compression-28.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-hybi-permessage-compression-28.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-hybi-permessage-compression-28">draft-ietf-hybi-permessage-compression-28</a>        Proposed Standard
                                                            <a class="text-warning" href="https://www.rfc-editor.org/errata_search.php?rfc=7692&amp;rec_status=0">Errata exist</a></pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                        T. Yoshino
Request for Comments: 7692                                  Google, Inc.
Category: Standards Track                                  December 2015
ISSN: 2070-1721


                  <span class="h1">Compression Extensions for WebSocket</span>

Abstract

   This document defines a framework for creating WebSocket extensions
   that add compression functionality to the WebSocket Protocol.  An
   extension based on this framework compresses the payload data portion
   of WebSocket data messages on a per-message basis using parameters
   negotiated during the opening handshake.  This framework provides a
   general method for applying a compression algorithm to the contents
   of WebSocket messages.  Each compression algorithm has to be defined
   in a document defining the extension by specifying the parameter
   negotiation and the payload transformation algorithm in detail.  This
   document also specifies one specific compression extension using the
   DEFLATE algorithm.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="/doc/html/rfc5741#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7692">http://www.rfc-editor.org/info/rfc7692</a>.
















<span class="grey">Yoshino                      Standards Track                    [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Conformance Requirements and Terminology ........................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Complementary Terminology .......................................<a href="#page-4">4</a>
   <a href="#section-4">4</a>. WebSocket Per-Message Compression Extension .....................<a href="#page-5">5</a>
   <a href="#section-5">5</a>. Extension Negotiation ...........................................<a href="#page-5">5</a>
      <a href="#section-5.1">5.1</a>. General Negotiation Flow ...................................<a href="#page-9">9</a>
      <a href="#section-5.2">5.2</a>. Negotiation Examples .......................................<a href="#page-9">9</a>
   <a href="#section-6">6</a>. Framing ........................................................<a href="#page-10">10</a>
      <a href="#section-6.1">6.1</a>. Compression ...............................................<a href="#page-10">10</a>
      <a href="#section-6.2">6.2</a>. Decompression .............................................<a href="#page-12">12</a>
   <a href="#section-7">7</a>. The &quot;permessage-deflate&quot; Extension .............................<a href="#page-12">12</a>
      <a href="#section-7.1">7.1</a>. Extension Parameters ......................................<a href="#page-14">14</a>
           <a href="#section-7.1.1">7.1.1</a>. Context Takeover Control ...........................<a href="#page-14">14</a>
           <a href="#section-7.1.2">7.1.2</a>. Limiting the LZ77 Sliding Window Size ..............<a href="#page-16">16</a>
           <a href="#section-7.1.3">7.1.3</a>. Examples ...........................................<a href="#page-18">18</a>
      <a href="#section-7.2">7.2</a>. Message Payload Transformation ............................<a href="#page-19">19</a>
           <a href="#section-7.2.1">7.2.1</a>. Compression ........................................<a href="#page-19">19</a>
           <a href="#section-7.2.2">7.2.2</a>. Decompression ......................................<a href="#page-21">21</a>
           <a href="#section-7.2.3">7.2.3</a>. Examples ...........................................<a href="#page-22">22</a>
      <a href="#section-7.3">7.3</a>. Implementation Notes ......................................<a href="#page-25">25</a>
   <a href="#section-8">8</a>. Security Considerations ........................................<a href="#page-25">25</a>
   <a href="#section-9">9</a>. IANA Considerations ............................................<a href="#page-26">26</a>
      9.1. Registration of the &quot;permessage-deflate&quot; WebSocket
           Extension Name ............................................<a href="#page-26">26</a>
      9.2. Registration of the &quot;Per-Message Compressed&quot;
           WebSocket Framing Header Bit ..............................<a href="#page-26">26</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-27">27</a>
      <a href="#section-10.1">10.1</a>. Normative References .....................................<a href="#page-27">27</a>
      <a href="#section-10.2">10.2</a>. Informative References ...................................<a href="#page-27">27</a>
   Acknowledgements ..................................................<a href="#page-28">28</a>
   Author&#x27;s Address ..................................................<a href="#page-28">28</a>



<span class="grey">Yoshino                      Standards Track                    [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   This document specifies a framework for adding compression
   functionality to the WebSocket Protocol [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>].  The framework
   specifies how to define WebSocket Per-Message Compression Extensions
   (PMCEs) for a compression algorithm based on the extension concept of
   the WebSocket Protocol specified in <a href="/doc/html/rfc6455#section-9">Section&nbsp;9 of [RFC6455]</a>.  A
   WebSocket client and a peer WebSocket server negotiate the use of a
   PMCE and determine the parameters required to configure the
   compression algorithm during the WebSocket opening handshake.  The
   client and server can then exchange data messages whose frames
   contain compressed data in the payload data portion.

   This framework only specifies a general method for applying a
   compression algorithm to the contents of WebSocket messages.  Each
   individual PMCE has to be specified in a document describing in
   detail how to negotiate the configuration parameters for the specific
   compression algorithm used by that PMCE and how to transform
   (compress and decompress) data in the payload data portion.

   A WebSocket client may offer multiple PMCEs during the WebSocket
   opening handshake.  A peer WebSocket server receiving the offer may
   choose to accept the preferred PMCE or decline all of them.  PMCEs
   use the RSV1 bit of the WebSocket frame header to indicate whether a
   message is compressed or not so that an endpoint can choose not to
   compress messages with incompressible contents.

   This document also specifies one specific PMCE based on the DEFLATE
   [<a href="/doc/html/rfc1951" title="&quot;DEFLATE Compressed Data Format Specification version 1.3&quot;">RFC1951</a>] algorithm.  The DEFLATE algorithm is widely available on
   various platforms, and its overhead is small.  The extension name of
   this PMCE is &quot;permessage-deflate&quot;.  To align the end of compressed
   data to an octet boundary, this extension uses the algorithm
   described in <a href="/doc/html/rfc1979#section-2.1">Section&nbsp;2.1 of [RFC1979]</a>.  Endpoints can take over the
   LZ77 sliding window [<a href="#ref-LZ77" title="&quot;A Universal Algorithm for Sequential Data Compression&quot;">LZ77</a>] used to build frames for previous messages
   to achieve a better compression ratio.  For resource-limited devices,
   this extension provides parameters to limit memory usage for
   compression context.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Conformance Requirements and Terminology</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

   Requirements phrased in the imperative as part of algorithms (such as
   &quot;strip any leading space characters&quot; or &quot;return false and abort these
   steps&quot;) are to be interpreted with the meaning of the key word
   (&quot;MUST&quot;, &quot;SHOULD&quot;, &quot;MAY&quot;, etc.) used in introducing the algorithm.



<span class="grey">Yoshino                      Standards Track                    [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   Conformance requirements phrased as algorithms or specific steps can
   be implemented in any manner, so long as the end result is
   equivalent.  In particular, the algorithms defined in this
   specification are intended to be easy to understand and are not
   intended to be performant.

   This document references the procedure to _Fail the WebSocket
   Connection_.  This procedure is defined in <a href="/doc/html/rfc6455#section-7.1.7">Section&nbsp;7.1.7 of
   [RFC6455]</a>.

   This document references the event that _The WebSocket Connection is
   Established_ and the event that _A WebSocket Message Has Been
   Received_.  These events are defined in Sections <a href="#section-4.1">4.1</a> and <a href="#section-6.2">6.2</a>,
   respectively, of [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>].

   This document uses the Augmented Backus-Naur Form (ABNF) notation of
   [<a href="/doc/html/rfc5234" title="&quot;Augmented BNF for Syntax Specifications: ABNF&quot;">RFC5234</a>].  The DIGIT (decimal 0-9) rule is included by reference, as
   defined in the <a href="/doc/html/rfc5234#appendix-B.1">Appendix&nbsp;B.1 of [RFC5234]</a>.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Complementary Terminology</span>

   This document defines some terms about WebSocket and WebSocket
   extension mechanisms that are underspecified or not defined at all in
   [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>].

   data message - a message consisting of data frames as defined in
   <a href="/doc/html/rfc6455#section-5.6">Section&nbsp;5.6 of [RFC6455]</a>.

   message payload (or payload of a message) - the concatenation of the
   payload data portion of all data frames (see <a href="/doc/html/rfc6455#section-6.2">Section&nbsp;6.2 of
   [RFC6455]</a>) representing a single message.

   next extension in use after extension X - the next extension listed
   after X in the &quot;Sec-WebSocket-Extensions&quot; header in the server&#x27;s
   opening handshake as defined in <a href="/doc/html/rfc6455#section-9.1">Section&nbsp;9.1 of [RFC6455]</a>.  Such an
   extension is applied to outgoing data from the application right
   after X on the sender side but is applied right before X to incoming
   data from the underlying transport.

   extension in use preceding extension X - the extension listed right
   before X in the &quot;Sec-WebSocket-Extensions&quot; header in the server&#x27;s
   opening handshake.  Such an extension is applied to outgoing data
   from the application right before X on the sender side but is applied
   right after X to incoming data from the underlying transport.

   extension negotiation offer - each element in the &quot;Sec-WebSocket-
   Extensions&quot; header in the client&#x27;s opening handshake.




<span class="grey">Yoshino                      Standards Track                    [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   extension negotiation response - each element in the &quot;Sec-WebSocket-
   Extensions&quot; header in the server&#x27;s opening handshake.

   corresponding extension negotiation response for an extension
   negotiation offer - an extension negotiation response that a server
   sends back to the peer client containing the same extension name as
   the offer and meeting the requirements represented by the offer.

   Accepting an extension negotiation offer - including a corresponding
   extension negotiation response for the offer in the &quot;Sec-WebSocket-
   Extensions&quot; header in the server&#x27;s opening handshake.

   Declining an extension negotiation offer - not including a
   corresponding extension negotiation response for the offer in the
   &quot;Sec-WebSocket-Extensions&quot; header in the server&#x27;s opening handshake.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  WebSocket Per-Message Compression Extension</span>

   WebSocket PMCEs are extensions to the WebSocket Protocol enabling
   compression functionality.  PMCEs are built based on the extension
   concept of the WebSocket Protocol specified in <a href="/doc/html/rfc6455#section-9">Section&nbsp;9 of
   [RFC6455]</a>.  PMCEs are individually defined for each compression
   algorithm to be implemented and are registered in the &quot;WebSocket
   Extension Name Registry&quot; created in <a href="/doc/html/rfc6455#section-11.4">Section&nbsp;11.4 of [RFC6455]</a>.  Each
   PMCE referring to this framework MUST define the following:

   o  The extension name of the PMCE and any applicable extension
      parameters that MUST be included in the &quot;Sec-WebSocket-Extensions&quot;
      header during the extension negotiation offer/response.

   o  How to interpret the extension parameters exchanged during the
      opening handshake.

   o  How to transform the payload of a message.

   One PMCE is defined in <a href="#section-7">Section 7</a> of this document and is registered
   in <a href="#section-9">Section 9</a>.  Other PMCEs may be defined in the future in other
   documents.

   <a href="#section-5">Section 5</a> describes the basic extension negotiation process.
   <a href="#section-6">Section 6</a> describes how to apply the compression algorithm with
   negotiated parameters to the contents of WebSocket messages.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Extension Negotiation</span>

   To offer use of a PMCE, a client MUST include the extension name of
   the PMCE in the &quot;Sec-WebSocket-Extensions&quot; header field of its
   opening handshake of the WebSocket connection.  Extension parameters



<span class="grey">Yoshino                      Standards Track                    [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   are used to specify the PMCE offer in detail.  For example, a client
   lists its preferred configuration parameter values for the
   compression algorithm of the PMCE.  A client may also offer multiple
   PMCE choices to the server by including multiple elements in the
   &quot;Sec-WebSocket-Extensions&quot; header, one for each PMCE offered.  This
   set of elements MAY include multiple PMCEs with the same extension
   name to offer the possibility to use the same algorithm with
   different configuration parameters.  The order of elements is
   important as it specifies the client&#x27;s preference.  An element
   preceding another element has higher preference.  It is recommended
   that a server accepts PMCEs with higher preference if the server
   supports them.

   A PMCE negotiation offer provides requests and/or hints to the
   server.

   A request in a PMCE negotiation offer indicates constraints on the
   server&#x27;s behavior that must be satisfied if the server accepts the
   offer.  For example, suppose that a server sends data compressed with
   the DEFLATE algorithm to a client.  The server must keep the original
   bytes of data that it recently compressed and sent to the client.
   The client must keep the result of decompressing the bytes of data
   that it recently received from the server.  The amount of bytes of
   data kept is called the LZ77 window size.  The LZ77 window size of
   the client must not be less than the LZ77 window size of the server.
   In a PMCE negotiation offer, the client MUST inform the server of its
   LZ77 window size so that the server uses an LZ77 window size that is
   not greater than the LZ77 window size of the client.  This
   restriction on the LZ77 window size is an example of a request in a
   PMCE negotiation offer.

   A hint in a PMCE negotiation offer provides information about the
   client&#x27;s behavior that the server may either safely ignore or refer
   to when the server decides its behavior.  For example, suppose that a
   client sends data compressed with the DEFLATE algorithm to a server.
   The client must keep the original bytes of data that it recently
   compressed and sent to the server.  The server must keep the result
   of decompressing the bytes of data that it recently received from the
   client.  The LZ77 window size of the server must not be less than the
   LZ77 window size of the client.  In a PMCE negotiation offer, the
   client MAY inform the server of the maximum LZ77 window size the
   client can afford so that the server can choose to use an LZ77 window
   size that is not greater than the maximum size of the client.  This
   information is an example of a hint in a PMCE negotiation offer.
   It&#x27;s waste of memory to use an LZ77 window size greater than the LZ77
   window size the client actually uses.  Using the hint, the server can
   avoid the waste of memory.  Since the hint itself doesn&#x27;t specify the




<span class="grey">Yoshino                      Standards Track                    [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   constraints on the endpoints, the server must use the &quot;agreed
   parameters&quot; (defined below) to explicitly ask the client not to use
   an LZ77 window size greater than the LZ77 window size of the server.

   To accept the use of an offered PMCE, a server MUST include the
   extension name of the PMCE in the &quot;Sec-WebSocket-Extensions&quot; header
   field of its opening handshake of the WebSocket connection.
   Extension parameters represent the detailed configuration parameters
   for the PMCE to use.  These extension parameters and their values are
   called &quot;agreed parameters&quot;.  The element MUST represent a PMCE that
   is fully supported by the server.  The contents of the element don&#x27;t
   need to be exactly the same as those of the received extension
   negotiation offers.  For example, suppose that a server received a
   PMCE extension negotiation offer with an extension parameter &quot;X&quot;
   indicating that the client can enable an optional feature named X.
   The server may accept the PMCE offer with an element without the
   extension parameter &quot;X&quot;, meaning that the server chose not to enable
   the feature X.  In this case, the offer contains the extension
   parameter &quot;X&quot;, but the &quot;agreed parameters&quot; don&#x27;t contain the
   extension parameter &quot;X&quot;.

   &quot;Agreed parameters&quot; must represent how the requests and hints in the
   client&#x27;s extension negotiation offer have been handled in addition to
   the server&#x27;s requests and hints on the client&#x27;s behavior, so that the
   client can configure its behavior without identifying exactly which
   PMCE extension negotiation offer has been accepted.

   For example, if a client sends an extension negotiation offer that
   includes a parameter &quot;enable_compression&quot; and another without this
   parameter, the server accepts the former and informs the client by
   sending back an element that includes parameter(s) acknowledging
   &quot;enable_compression&quot;.  The name of the acknowledging parameter
   doesn&#x27;t need to be exactly the same as the offer.  For example, two
   parameters, &quot;enable_strong_compression&quot; and
   &quot;enable_weak_compression&quot;, may be defined as acknowledging parameters
   for &quot;enable_compression&quot;.

   Compression features can be applied differently for each direction.
   For such features, the acknowledging parameter and the parameter in
   the reverse direction must be chosen to distinguish them.  For
   example, in order to make parameters distinguishable, a &quot;server_&quot;
   prefix can be added to parameters affecting data sent from a server,
   and a &quot;client_&quot; prefix can be added to parameters affecting data sent
   from a client.







<span class="grey">Yoshino                      Standards Track                    [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   A server MUST NOT accept a PMCE extension negotiation offer together
   with another extension if the PMCE will conflict with the extension
   on their use of the RSV1 bit.  A client that received a response
   accepting a PMCE extension negotiation offer together with such an
   extension MUST _Fail the WebSocket Connection_.

   A server MUST NOT accept a PMCE extension negotiation offer together
   with another extension if the PMCE will be applied to the output of
   the extension and any of the following conditions applies to the
   extension:

   o  The extension requires the boundary of frames to be preserved
      between the output from the extension at the sender and the input
      to the extension at the receiver.

   o  The extension uses the &quot;Extension data&quot; field or any of the
      reserved bits on the WebSocket header as a per-frame attribute.

   A client that receives a response accepting a PMCE extension
   negotiation offer together with such an extension MUST _Fail the
   WebSocket Connection_.

   A server declining all offered PMCEs MUST NOT include any element
   with PMCE names.  If a server responds with no PMCE element in the
   &quot;Sec-WebSocket-Extensions&quot; header, both endpoints proceed without
   per-message compression once _the WebSocket Connection is
   established_.

   If a server gives an invalid response, such as accepting a PMCE that
   the client did not offer, the client MUST _Fail the WebSocket
   Connection_.

   If a server responds with a valid PMCE element in the &quot;Sec-WebSocket-
   Extensions&quot; header and _the WebSocket Connection is established_,
   both endpoints MUST use the algorithm described in <a href="#section-6">Section 6</a> and the
   message payload transformation (compressing and decompressing)
   procedure of the PMCE configured with the &quot;agreed parameters&quot;
   returned by the server to exchange messages.













<span class="grey">Yoshino                      Standards Track                    [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a>.  General Negotiation Flow</span>

   This section describes a general negotiation flow.  How to handle
   parameters in detail must be specified in the document specifying the
   PMCE.

   A client makes an offer including parameters identifying the
   following:

   o  Hints about how the client is planning to compress data

   o  Requests about how the server compresses data

   o  Limitations concerning the client&#x27;s compression functionality

   The peer server makes a determination of its behavior based on these
   parameters.  If the server can and wants to proceed with this PMCE
   enabled, the server responds to the client with parameters
   identifying the following:

   o  Requests about how the client compresses data

   o  How the server will compress data

   Based on these parameters received from the server, the client
   determines its behavior and if it can and wants to proceed with this
   PMCE enabled.  Otherwise, the client starts the closing handshake
   with close code 1010.

<span class="h3"><a class="selflink" id="section-5.2" href="#section-5.2">5.2</a>.  Negotiation Examples</span>

   The following are example values for the &quot;Sec-WebSocket-Extensions&quot;
   header offering PMCEs; permessage-foo and permessage-bar in the
   examples are hypothetical extension names of PMCEs for the
   compression algorithm foo and bar.

   o  Offer the permessage-foo.

          permessage-foo

   o  Offer the permessage-foo with a parameter x with a value of 10.

          permessage-foo; x=10

      The value may be quoted.

          permessage-foo; x=&quot;10&quot;




<span class="grey">Yoshino                      Standards Track                    [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   o  Offer the permessage-foo as first choice and the permessage-bar as
      a fallback plan.

          permessage-foo, permessage-bar

   o  Offer the permessage-foo with a parameter use_y, which enables a
      feature y as first choice, and the permessage-foo without the
      use_y parameter as a fallback plan.

          permessage-foo; use_y, permessage-foo

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Framing</span>

   PMCEs operate only on data messages.

   This document allocates the RSV1 bit of the WebSocket header for
   PMCEs and calls the bit the &quot;Per-Message Compressed&quot; bit.  On a
   WebSocket connection where a PMCE is in use, this bit indicates
   whether a message is compressed or not.

   A message with the &quot;Per-Message Compressed&quot; bit set on the first
   fragment of the message is called a &quot;compressed message&quot;.  Frames of
   a compressed message have compressed data in the payload data
   portion.  An endpoint receiving a compressed message decompresses the
   concatenation of the compressed data of the frames of the message by
   following the decompression procedure specified by the PMCE in use.
   The endpoint uses the bytes corresponding to the application data
   portion in this decompressed data for the _A WebSocket Message Has
   Been Received_ event instead of the received data as is.

   A message with the &quot;Per-Message Compressed&quot; bit unset on the first
   fragment of the message is called an &quot;uncompressed message&quot;.  Frames
   of an uncompressed message have uncompressed original data as is in
   the payload data portion.  An endpoint receiving an uncompressed
   message uses the concatenation of the application data portion of the
   frames of the message as is for the _A WebSocket Message Has Been
   Received_ event.

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Compression</span>

   An endpoint MUST use the following algorithm to send a message in the
   form of a compressed message.

   1.  Compress the message payload of the original message by following
       the compression procedure of the PMCE.  The original message may
       be input from the application layer or output of another
       WebSocket extension, depending on which extensions were
       negotiated.



<span class="grey">Yoshino                      Standards Track                   [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   2.  Process the compressed data as follows:

       *  If this PMCE is the last extension to process outgoing
          messages, build frame(s) using the compressed data instead of
          the original data for the message payload, set the &quot;Per-
          Message Compressed&quot; bit of the first frame, and then send the
          frame(s) as described in <a href="/doc/html/rfc6455#section-6.1">Section&nbsp;6.1 of [RFC6455]</a>.

       *  Otherwise, pass the transformed message payload and modified
          header values, including the &quot;Per-Message Compressed&quot; bit
          value set to 1, to the next extension after the PMCE.  If the
          extension expects frames for input, build a frame for the
          message and pass it.

   An endpoint MUST use the following algorithm to send a message in the
   form of an uncompressed message.

   1.  Process the original data as follows:

       *  If this PMCE is the last extension to process outgoing
          messages, build frame(s) using the original data for the
          payload data portion as is, unset the &quot;Per-Message Compressed&quot;
          bit of the first frame, and then send the frame(s) as
          described in <a href="/doc/html/rfc6455#section-6.1">Section&nbsp;6.1 of [RFC6455]</a>.

       *  Otherwise, pass the message payload and header values to the
          next extension after the PMCE as is.  If the extension expects
          frames for input, build a frame for the message and pass it.

   An endpoint MUST NOT set the &quot;Per-Message Compressed&quot; bit of control
   frames and non-first fragments of a data message.  An endpoint
   receiving such a frame MUST _Fail the WebSocket Connection_.

   PMCEs do not change the opcode field.  The opcode of the first frame
   of a compressed message indicates the opcode of the original message.

   The payload data portion in frames generated by a PMCE is not subject
   to the constraints for the original data type.  For example, the
   concatenation of the output data corresponding to the application
   data portion of frames of a compressed text message is not required
   to be valid UTF-8.  At the receiver, the payload data portion after
   decompression is subject to the constraints for the original data
   type again.








<span class="grey">Yoshino                      Standards Track                   [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  Decompression</span>

   An endpoint MUST use the following algorithm to receive a message in
   the form of a compressed message.

   1.  Concatenate the payload data portion of the received frames of
       the compressed message.  The received frames may be direct input
       from the underlying transport or output of another WebSocket
       extension, depending on which extensions were negotiated.

   2.  Decompress the concatenation by following the decompression
       procedure of the PMCE.

   3.  Process the decompressed message as follows:

       *  If this is the last extension to process incoming messages,
          deliver the _A WebSocket Message Has Been Received_ event to
          the application layer with the decompressed message payload
          and header values, including the &quot;Per-Message Compressed&quot; bit
          unset to 0.

       *  Otherwise, pass the decompressed message payload and header
          values, including the &quot;Per-Message Compressed&quot; bit unset to 0,
          to the extension preceding the PMCE.  If the extension expects
          frames for input, build a frame for the message and pass it.

   An endpoint MUST use the following algorithm to receive a message in
   the form of an uncompressed message.

   1.  Process the received message as follows:

       *  If this PMCE is the last extension to process incoming
          messages, deliver the _A WebSocket Message Has Been Received_
          event to the application layer with the received message
          payload and header values as is.

       *  Otherwise, pass the message payload and header values to the
          extension preceding the PMCE as is.  If the extension expects
          frames for input, build a frame for the message and pass it.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  The &quot;permessage-deflate&quot; Extension</span>

   This section defines a specific PMCE called &quot;permessage-deflate&quot;.  It
   compresses the payload of a message using the DEFLATE algorithm
   [<a href="/doc/html/rfc1951" title="&quot;DEFLATE Compressed Data Format Specification version 1.3&quot;">RFC1951</a>] and uses the byte boundary alignment method introduced in
   [<a href="/doc/html/rfc1979" title="&quot;PPP Deflate Protocol&quot;">RFC1979</a>].





<span class="grey">Yoshino                      Standards Track                   [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   This section uses the term &quot;byte&quot; with the same meaning as used in
   [<a href="/doc/html/rfc1951" title="&quot;DEFLATE Compressed Data Format Specification version 1.3&quot;">RFC1951</a>], i.e., 8 bits stored or transmitted as a unit (same as an
   octet).

   The registered extension name for this extension is &quot;permessage-
   deflate&quot;.

   Four extension parameters are defined for &quot;permessage-deflate&quot; to
   help endpoints manage per-connection resource usage.

   o  &quot;server_no_context_takeover&quot;

   o  &quot;client_no_context_takeover&quot;

   o  &quot;server_max_window_bits&quot;

   o  &quot;client_max_window_bits&quot;

   These parameters enable two methods (no_context_takeover and
   max_window_bits) of constraining memory usage that may be applied
   independently to either direction of WebSocket traffic.  The
   extension parameters with the &quot;client_&quot; prefix are used by the client
   to configure its compressor and by the server to configure its
   decompressor.  The extension parameters with the &quot;server_&quot; prefix are
   used by the server to configure its compressor and by the client to
   configure its decompressor.  All four parameters are defined for both
   a client&#x27;s extension negotiation offer and a server&#x27;s extension
   negotiation response.

   A server MUST decline an extension negotiation offer for this
   extension if any of the following conditions are met:

   o  The negotiation offer contains an extension parameter not defined
      for use in an offer.

   o  The negotiation offer contains an extension parameter with an
      invalid value.

   o  The negotiation offer contains multiple extension parameters with
      the same name.

   o  The server doesn&#x27;t support the offered configuration.

   A client MUST _Fail the WebSocket Connection_ if the peer server
   accepted an extension negotiation offer for this extension with an
   extension negotiation response meeting any of the following
   conditions:




<span class="grey">Yoshino                      Standards Track                   [Page 13]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-14" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   o  The negotiation response contains an extension parameter not
      defined for use in a response.

   o  The negotiation response contains an extension parameter with an
      invalid value.

   o  The negotiation response contains multiple extension parameters
      with the same name.

   o  The client does not support the configuration that the response
      represents.

   The term &quot;LZ77 sliding window&quot; [<a href="#ref-LZ77" title="&quot;A Universal Algorithm for Sequential Data Compression&quot;">LZ77</a>] used in this section means the
   buffer used by the DEFLATE algorithm to store recently processed
   input.  The DEFLATE compression algorithm searches the buffer for a
   match with the following input.

   The term &quot;use context takeover&quot; used in this section means that the
   same LZ77 sliding window used by the endpoint to build frames of the
   previous sent message is reused to build frames of the next message
   to be sent.

<span class="h3"><a class="selflink" id="section-7.1" href="#section-7.1">7.1</a>.  Extension Parameters</span>

<span class="h4"><a class="selflink" id="section-7.1.1" href="#section-7.1.1">7.1.1</a>.  Context Takeover Control</span>

<span class="h5"><a class="selflink" id="section-7.1.1.1" href="#section-7.1.1.1">7.1.1.1</a>.  The &quot;server_no_context_takeover&quot; Extension Parameter</span>

   A client MAY include the &quot;server_no_context_takeover&quot; extension
   parameter in an extension negotiation offer.  This extension
   parameter has no value.  By including this extension parameter in an
   extension negotiation offer, a client prevents the peer server from
   using context takeover.  If the peer server doesn&#x27;t use context
   takeover, the client doesn&#x27;t need to reserve memory to retain the
   LZ77 sliding window between messages.

   Absence of this extension parameter in an extension negotiation offer
   indicates that the client can decompress a message that the server
   built using context takeover.

   A server accepts an extension negotiation offer that includes the
   &quot;server_no_context_takeover&quot; extension parameter by including the
   &quot;server_no_context_takeover&quot; extension parameter in the corresponding
   extension negotiation response to send back to the client.  The
   &quot;server_no_context_takeover&quot; extension parameter in an extension
   negotiation response has no value.





<span class="grey">Yoshino                      Standards Track                   [Page 14]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-15" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   It is RECOMMENDED that a server supports the
   &quot;server_no_context_takeover&quot; extension parameter in an extension
   negotiation offer.

   A server MAY include the &quot;server_no_context_takeover&quot; extension
   parameter in an extension negotiation response even if the extension
   negotiation offer being accepted by the extension negotiation
   response didn&#x27;t include the &quot;server_no_context_takeover&quot; extension
   parameter.

<span class="h5"><a class="selflink" id="section-7.1.1.2" href="#section-7.1.1.2">7.1.1.2</a>.  The &quot;client_no_context_takeover&quot; Extension Parameter</span>

   A client MAY include the &quot;client_no_context_takeover&quot; extension
   parameter in an extension negotiation offer.  This extension
   parameter has no value.  By including this extension parameter in an
   extension negotiation offer, a client informs the peer server of a
   hint that even if the server doesn&#x27;t include the
   &quot;client_no_context_takeover&quot; extension parameter in the corresponding
   extension negotiation response to the offer, the client is not going
   to use context takeover.

   A server MAY include the &quot;client_no_context_takeover&quot; extension
   parameter in an extension negotiation response.  If the received
   extension negotiation offer includes the &quot;client_no_context_takeover&quot;
   extension parameter, the server may either ignore the parameter or
   use the parameter to avoid taking over the LZ77 sliding window
   unnecessarily by including the &quot;client_no_context_takeover&quot; extension
   parameter in the corresponding extension negotiation response to the
   offer.  The &quot;client_no_context_takeover&quot; extension parameter in an
   extension negotiation response has no value.  By including the
   &quot;client_no_context_takeover&quot; extension parameter in an extension
   negotiation response, a server prevents the peer client from using
   context takeover.  This reduces the amount of memory that the server
   has to reserve for the connection.

   Absence of this extension parameter in an extension negotiation
   response indicates that the server can decompress messages built by
   the client using context takeover.

   A client MUST support the &quot;client_no_context_takeover&quot; extension
   parameter in an extension negotiation response.










<span class="grey">Yoshino                      Standards Track                   [Page 15]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-16" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h4"><a class="selflink" id="section-7.1.2" href="#section-7.1.2">7.1.2</a>.  Limiting the LZ77 Sliding Window Size</span>

<span class="h5"><a class="selflink" id="section-7.1.2.1" href="#section-7.1.2.1">7.1.2.1</a>.  The &quot;server_max_window_bits&quot; Extension Parameter</span>

   A client MAY include the &quot;server_max_window_bits&quot; extension parameter
   in an extension negotiation offer.  This parameter has a decimal
   integer value without leading zeroes between 8 to 15, inclusive,
   indicating the base-2 logarithm of the LZ77 sliding window size, and
   MUST conform to the ABNF below.

       server-max-window-bits = 1*DIGIT

   By including this parameter in an extension negotiation offer, a
   client limits the LZ77 sliding window size that the server will use
   to compress messages.  If the peer server uses a small LZ77 sliding
   window to compress messages, the client can reduce the memory needed
   for the LZ77 sliding window.

   A server declines an extension negotiation offer with this parameter
   if the server doesn&#x27;t support it.

   Absence of this parameter in an extension negotiation offer indicates
   that the client can receive messages compressed using an LZ77 sliding
   window of up to 32,768 bytes.

   A server accepts an extension negotiation offer with this parameter
   by including the &quot;server_max_window_bits&quot; extension parameter in the
   extension negotiation response to send back to the client with the
   same or smaller value as the offer.  The &quot;server_max_window_bits&quot;
   extension parameter in an extension negotiation response has a
   decimal integer value without leading zeroes between 8 to 15,
   inclusive, indicating the base-2 logarithm of the LZ77 sliding window
   size, and MUST conform to the ABNF below.

       server-max-window-bits = 1*DIGIT

   A server MAY include the &quot;server_max_window_bits&quot; extension parameter
   in an extension negotiation response even if the extension
   negotiation offer being accepted by the response didn&#x27;t include the
   &quot;server_max_window_bits&quot; extension parameter.

<span class="h5"><a class="selflink" id="section-7.1.2.2" href="#section-7.1.2.2">7.1.2.2</a>.  The &quot;client_max_window_bits&quot; Extension Parameter</span>

   A client MAY include the &quot;client_max_window_bits&quot; extension parameter
   in an extension negotiation offer.  This parameter has no value or a
   decimal integer value without leading zeroes between 8 to 15





<span class="grey">Yoshino                      Standards Track                   [Page 16]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-17" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   inclusive indicating the base-2 logarithm of the LZ77 sliding window
   size.  If a value is specified for this parameter, the value MUST
   conform to the ABNF below.

       client-max-window-bits = 1*DIGIT

   By including this parameter in an offer, a client informs the peer
   server that the client supports the &quot;client_max_window_bits&quot;
   extension parameter in an extension negotiation response and,
   optionally, a hint by attaching a value to the parameter.  If the
   &quot;client_max_window_bits&quot; extension parameter in an extension
   negotiation offer has a value, the parameter also informs the peer
   server of a hint that even if the server doesn&#x27;t include the
   &quot;client_max_window_bits&quot; extension parameter in the corresponding
   extension negotiation response with a value greater than the one in
   the extension negotiation offer or if the server doesn&#x27;t include the
   extension parameter at all, the client is not going to use an LZ77
   sliding window size greater than the size specified by the value in
   the extension negotiation offer to compress messages.

   If a received extension negotiation offer has the
   &quot;client_max_window_bits&quot; extension parameter, the server MAY include
   the &quot;client_max_window_bits&quot; extension parameter in the corresponding
   extension negotiation response to the offer.  If the
   &quot;client_max_window_bits&quot; extension parameter in a received extension
   negotiation offer has a value, the server may either ignore this
   value or use this value to avoid allocating an unnecessarily big LZ77
   sliding window by including the &quot;client_max_window_bits&quot; extension
   parameter in the corresponding extension negotiation response to the
   offer with a value equal to or smaller than the received value.  The
   &quot;client_max_window_bits&quot; extension parameter in an extension
   negotiation response has a decimal integer value without leading
   zeroes between 8 to 15 inclusive indicating the base-2 logarithm of
   the LZ77 sliding window size and MUST conform to the ABNF below.

       client-max-window-bits = 1*DIGIT

   By including this extension parameter in an extension negotiation
   response, a server limits the LZ77 sliding window size that the
   client uses to compress messages.  This reduces the amount of memory
   for the decompression context that the server has to reserve for the
   connection.

   If a received extension negotiation offer doesn&#x27;t have the
   &quot;client_max_window_bits&quot; extension parameter, the corresponding
   extension negotiation response to the offer MUST NOT include the
   &quot;client_max_window_bits&quot; extension parameter.




<span class="grey">Yoshino                      Standards Track                   [Page 17]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-18" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   Absence of this extension parameter in an extension negotiation
   response indicates that the server can receive messages compressed
   using an LZ77 sliding window of up to 32,768 bytes.

<span class="h4"><a class="selflink" id="section-7.1.3" href="#section-7.1.3">7.1.3</a>.  Examples</span>

   The simplest &quot;Sec-WebSocket-Extensions&quot; header in a client&#x27;s opening
   handshake to offer use of the &quot;permessage-deflate&quot; extension looks
   like this:

       Sec-WebSocket-Extensions: permessage-deflate

   Since the &quot;client_max_window_bits&quot; extension parameter is not
   included in this extension negotiation offer, the server must not
   accept the offer with an extension negotiation response that includes
   the &quot;client_max_window_bits&quot; extension parameter.  The simplest &quot;Sec-
   WebSocket-Extensions&quot; header in a server&#x27;s opening handshake to
   accept use of the &quot;permessage-deflate&quot; extension is the same:

       Sec-WebSocket-Extensions: permessage-deflate

   The following extension negotiation offer sent by a client is asking
   the server to use an LZ77 sliding window with a size of 1,024 bytes
   or less and declaring that the client supports the
   &quot;client_max_window_bits&quot; extension parameter in an extension
   negotiation response.

       Sec-WebSocket-Extensions:
           permessage-deflate;
           client_max_window_bits; server_max_window_bits=10

   This extension negotiation offer might be rejected by the server
   because the server doesn&#x27;t support the &quot;server_max_window_bits&quot;
   extension parameter in an extension negotiation offer.  This is fine
   if the client cannot receive messages compressed using a larger
   sliding window size, but if the client just prefers using a small
   window but wants to fall back to the &quot;permessage-deflate&quot; without the
   &quot;server_max_window_bits&quot; extension parameter, the client can make an
   offer with the fallback option like this:

       Sec-WebSocket-Extensions:
           permessage-deflate;
           client_max_window_bits; server_max_window_bits=10,
           permessage-deflate;
           client_max_window_bits






<span class="grey">Yoshino                      Standards Track                   [Page 18]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-19" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   The server can accept &quot;permessage-deflate&quot; by picking any supported
   one from the listed offers.  To accept the first option, for example,
   the server may send back a response as follows:

       Sec-WebSocket-Extensions:
           permessage-deflate; server_max_window_bits=10

   To accept the second option, for example, the server may send back a
   response as follows:

       Sec-WebSocket-Extensions: permessage-deflate

<span class="h3"><a class="selflink" id="section-7.2" href="#section-7.2">7.2</a>.  Message Payload Transformation</span>

<span class="h4"><a class="selflink" id="section-7.2.1" href="#section-7.2.1">7.2.1</a>.  Compression</span>

   An endpoint uses the following algorithm to compress a message.

   1.  Compress all the octets of the payload of the message using
       DEFLATE.

   2.  If the resulting data does not end with an empty DEFLATE block
       with no compression (the &quot;BTYPE&quot; bits are set to 00), append an
       empty DEFLATE block with no compression to the tail end.

   3.  Remove 4 octets (that are 0x00 0x00 0xff 0xff) from the tail end.
       After this step, the last octet of the compressed data contains
       (possibly part of) the DEFLATE header bits with the &quot;BTYPE&quot; bits
       set to 00.

   When using DEFLATE in the first step above:

   o  An endpoint MAY use multiple DEFLATE blocks to compress one
      message.

   o  An endpoint MAY use DEFLATE blocks of any type.

   o  An endpoint MAY use both DEFLATE blocks with the &quot;BFINAL&quot; bit set
      to 0 and DEFLATE blocks with the &quot;BFINAL&quot; bit set to 1.

   o  When any DEFLATE block with the &quot;BFINAL&quot; bit set to 1 doesn&#x27;t end
      at a byte boundary, an endpoint MUST add minimal padding bits of 0
      to make it end at a byte boundary.  The next DEFLATE block follows
      the padded data if any.

   An endpoint fragments a compressed message by splitting the result of
   running this algorithm.  Even when only part of the payload is
   available, a fragment can be built by compressing the available data



<span class="grey">Yoshino                      Standards Track                   [Page 19]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-20" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   and choosing the block type appropriately so that the end of the
   resulting compressed data is aligned at a byte boundary.  Note that
   for non-final fragments, the removal of 0x00 0x00 0xff 0xff MUST NOT
   be done.

   An endpoint MUST NOT use an LZ77 sliding window longer than 32,768
   bytes to compress messages to send.

   If the &quot;agreed parameters&quot; contain the &quot;client_no_context_takeover&quot;
   extension parameter, the client MUST start compressing each new
   message with an empty LZ77 sliding window.  Otherwise, the client MAY
   take over the LZ77 sliding window used to build the last compressed
   message.  Note that even if the client has included the
   &quot;client_no_context_takeover&quot; extension parameter in its offer, the
   client MAY take over the LZ77 sliding window used to build the last
   compressed message if the &quot;agreed parameters&quot; don&#x27;t contain the
   &quot;client_no_context_takeover&quot; extension parameter.  The client-to-
   server &quot;client_no_context_takeover&quot; extension parameter is just a
   hint for the server to build an extension negotiation response.

   If the &quot;agreed parameters&quot; contain the &quot;server_no_context_takeover&quot;
   extension parameter, the server MUST start compressing each new
   message with an empty LZ77 sliding window.  Otherwise, the server MAY
   take over the LZ77 sliding window used to build the last compressed
   message.

   If the &quot;agreed parameters&quot; contain the &quot;client_max_window_bits&quot;
   extension parameter with a value of w, the client MUST NOT use an
   LZ77 sliding window longer than the w-th power of 2 bytes to compress
   messages to send.  Note that even if the client has included in its
   offer the &quot;client_max_window_bits&quot; extension parameter with a value
   smaller than one in the &quot;agreed parameters&quot;, the client MAY use an
   LZ77 sliding window with any size to compress messages to send as
   long as the size conforms to the &quot;agreed parameters&quot;.  The client-to-
   server &quot;client_max_window_bits&quot; extension parameter is just a hint
   for the server to build an extension negotiation response.

   If the &quot;agreed parameters&quot; contain the &quot;server_max_window_bits&quot;
   extension parameter with a value of w, the server MUST NOT use an
   LZ77 sliding window longer than the w-th power of 2 bytes to compress
   messages to send.










<span class="grey">Yoshino                      Standards Track                   [Page 20]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-21" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h4"><a class="selflink" id="section-7.2.2" href="#section-7.2.2">7.2.2</a>.  Decompression</span>

   An endpoint uses the following algorithm to decompress a message.

   1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the
       payload of the message.

   2.  Decompress the resulting data using DEFLATE.

   If the &quot;agreed parameters&quot; contain the &quot;server_no_context_takeover&quot;
   extension parameter, the client MAY decompress each new message with
   an empty LZ77 sliding window.  Otherwise, the client MUST decompress
   each new message using the LZ77 sliding window used to process the
   last compressed message.

   If the &quot;agreed parameters&quot; contain the &quot;client_no_context_takeover&quot;
   extension parameter, the server MAY decompress each new message with
   an empty LZ77 sliding window.  Otherwise, the server MUST decompress
   each new message using the LZ77 sliding window used to process the
   last compressed message.  Note that even if the client has included
   the &quot;client_no_context_takeover&quot; extension parameter in its offer,
   the server MUST decompress each new message using the LZ77 sliding
   window used to process the last compressed message if the &quot;agreed
   parameters&quot; don&#x27;t contain the &quot;client_no_context_takeover&quot; extension
   parameter.  The client-to-server &quot;client_no_context_takeover&quot;
   extension parameter is just a hint for the server to build an
   extension negotiation response.

   If the &quot;agreed parameters&quot; contain the &quot;server_max_window_bits&quot;
   extension parameter with a value of w, the client MAY reduce the size
   of its LZ77 sliding window to decompress received messages down to
   the w-th power of 2 bytes.  Otherwise, the client MUST use a
   32,768-byte LZ77 sliding window to decompress received messages.

   If the &quot;agreed parameters&quot; contain the &quot;client_max_window_bits&quot;
   extension parameter with a value of w, the server MAY reduce the size
   of its LZ77 sliding window to decompress received messages down to
   the w-th power of 2 bytes.  Otherwise, the server MUST use a
   32,768-byte LZ77 sliding window to decompress received messages.
   Note that even if the client has included in its offer the
   &quot;client_max_window_bits&quot; extension parameter with a value smaller
   than one in the &quot;agreed parameters&quot;, the client MUST use an LZ77
   sliding window of a size that conforms the &quot;agreed parameters&quot; to
   compress messages to send.  The client-to-server
   &quot;client_max_window_bits&quot; extension parameter is just a hint for the
   server to build an extension negotiation response.





<span class="grey">Yoshino                      Standards Track                   [Page 21]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-22" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h4"><a class="selflink" id="section-7.2.3" href="#section-7.2.3">7.2.3</a>.  Examples</span>

   This section introduces examples of how the &quot;permessage-deflate&quot;
   extension transforms messages.

<span class="h5"><a class="selflink" id="section-7.2.3.1" href="#section-7.2.3.1">7.2.3.1</a>.  A Message Compressed Using One Compressed DEFLATE Block</span>

   Suppose that an endpoint sends a text message &quot;Hello&quot;.  If the
   endpoint uses one compressed DEFLATE block (compressed with fixed
   Huffman code and the &quot;BFINAL&quot; bit not set) to compress the message,
   the endpoint obtains the compressed data to use for the message
   payload as follows.

   The endpoint compresses &quot;Hello&quot; into one compressed DEFLATE block and
   flushes the resulting data into a byte array using an empty DEFLATE
   block with no compression:

       0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00 0x00 0x00 0xff 0xff

   By stripping 0x00 0x00 0xff 0xff from the tail end, the endpoint gets
   the data to use for the message payload:

       0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00

   Suppose that the endpoint sends this compressed message without
   fragmentation.  The endpoint builds one frame by putting all of the
   compressed data in the payload data portion of the frame:

       0xc1 0x07 0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00

   The first 2 octets (0xc1 0x07) are the WebSocket frame header (FIN=1,
   RSV1=1, RSV2=0, RSV3=0, opcode=text, MASK=0, Payload length=7).  The
   following figure shows what value is set in each field of the
   WebSocket frame header.

        0                   1
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
       +-+-+-+-+-------+-+-------------+
       |F|R|R|R| opcode|M| Payload len |
       |I|S|S|S|       |A|             |
       |N|V|V|V|       |S|             |
       | |1|2|3|       |K|             |
       +-+-+-+-+-------+-+-------------+
       |1|1|0|0|   1   |0|      7      |
       +-+-+-+-+-------+-+-------------+






<span class="grey">Yoshino                      Standards Track                   [Page 22]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-23" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


   Suppose that the endpoint sends the compressed message with
   fragmentation.  The endpoint splits the compressed data into
   fragments and builds frames for each fragment.  For example, if the
   fragments are 3 and 4 octets, the first frame is:

       0x41 0x03 0xf2 0x48 0xcd

   and the second frame is:

       0x80 0x04 0xc9 0xc9 0x07 0x00

   Note that the RSV1 bit is set only on the first frame.

<span class="h5"><a class="selflink" id="section-7.2.3.2" href="#section-7.2.3.2">7.2.3.2</a>.  Sharing LZ77 Sliding Window</span>

   Suppose that a client has sent a message &quot;Hello&quot; as a compressed
   message and will send the same message &quot;Hello&quot; again as a compressed
   message.

       0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00

   The above is the payload of the first message that the client has
   sent.  If the &quot;agreed parameters&quot; contain the
   &quot;client_no_context_takeover&quot; extension parameter, the client
   compresses the payload of the next message into the same bytes (if
   the client uses the same &quot;BTYPE&quot; value and &quot;BFINAL&quot; value).  So, the
   payload of the second message will be:

       0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00

   If the &quot;agreed parameters&quot; did not contain the
   &quot;client_no_context_takeover&quot; extension parameter, the client can
   compress the payload of the next message into fewer bytes by
   referencing the history in the LZ77 sliding window.  So, the payload
   of the second message will be:

       0xf2 0x00 0x11 0x00 0x00

   So, 2 bytes are saved in total.

   Note that even if some uncompressed messages (with the RSV1 bit
   unset) are inserted between the two &quot;Hello&quot; messages, they don&#x27;t
   affect the LZ77 sliding window.








<span class="grey">Yoshino                      Standards Track                   [Page 23]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-24" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h5"><a class="selflink" id="section-7.2.3.3" href="#section-7.2.3.3">7.2.3.3</a>.  Using a DEFLATE Block with No Compression</span>

   A DEFLATE block with no compression may be used.

       0xc1 0x0b 0x00 0x05 0x00 0xfa 0xff 0x48 0x65 0x6c 0x6c 0x6f 0x00

   This is a frame constituting a text message &quot;Hello&quot; built using a
   DEFLATE block with no compression.  The first 2 octets (0xc1 0x0b)
   are the WebSocket frame header (FIN=1, RSV1=1, RSV2=0, RSV3=0,
   opcode=text, MASK=0, Payload length=7).  Note that the RSV1 bit is
   set for this message (only on the first fragment if the message is
   fragmented) because the RSV1 bit is set when DEFLATE is applied to
   the message, including the case when only DEFLATE blocks with no
   compression are used.  The 3rd to 13th octets consist of the payload
   data containing &quot;Hello&quot; compressed using a DEFLATE block with no
   compression.

<span class="h5"><a class="selflink" id="section-7.2.3.4" href="#section-7.2.3.4">7.2.3.4</a>.  Using a DEFLATE Block with &quot;BFINAL&quot; Set to 1</span>

   On platforms on which the flush method using an empty DEFLATE block
   with no compression is not available, implementors can choose to
   flush data using DEFLATE blocks with &quot;BFINAL&quot; set to 1.

       0xf3 0x48 0xcd 0xc9 0xc9 0x07 0x00 0x00

   This is the payload of a message containing &quot;Hello&quot; compressed using
   a DEFLATE block with &quot;BFINAL&quot; set to 1.  The first 7 octets
   constitute a DEFLATE block with &quot;BFINAL&quot; set to 1 and &quot;BTYPE&quot; set to
   01 containing &quot;Hello&quot;.  The last 1 octet (0x00) contains the header
   bits with &quot;BFINAL&quot; set to 0 and &quot;BTYPE&quot; set to 00, and 5 padding bits
   of 0.  This octet is necessary to allow the payload to be
   decompressed in the same manner as messages flushed using DEFLATE
   blocks with &quot;BFINAL&quot; unset.

<span class="h5"><a class="selflink" id="section-7.2.3.5" href="#section-7.2.3.5">7.2.3.5</a>.  Two DEFLATE Blocks in One Message</span>

   Two or more DEFLATE blocks may be used in one message.

       0xf2 0x48 0x05 0x00 0x00 0x00 0xff 0xff 0xca 0xc9 0xc9 0x07 0x00

   The first 3 octets (0xf2 0x48 0x05) and the least significant two
   bits of the 4th octet (0x00) constitute one DEFLATE block with
   &quot;BFINAL&quot; set to 0 and &quot;BTYPE&quot; set to 01 containing &quot;He&quot;.  The rest of
   the 4th octet contains the header bits with &quot;BFINAL&quot; set to 0 and
   &quot;BTYPE&quot; set to 00, and the 3 padding bits of 0.  Together with the
   following 4 octets (0x00 0x00 0xff 0xff), the header bits constitute
   an empty DEFLATE block with no compression.  A DEFLATE block
   containing &quot;llo&quot; follows the empty DEFLATE block.



<span class="grey">Yoshino                      Standards Track                   [Page 24]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-25" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h5"><a class="selflink" id="section-7.2.3.6" href="#section-7.2.3.6">7.2.3.6</a>.  Generating an Empty Fragment</span>

   Suppose that an endpoint is sending data of unknown size.  The
   endpoint may encounter the end-of-data signal from the data source
   when its buffer for uncompressed data is empty.  In such a case, the
   endpoint just needs to send the last fragment with the FIN bit set to
   1 and the payload set to the DEFLATE block(s), which contains 0 bytes
   of data.  If the compression library being used doesn&#x27;t generate any
   data when its buffer is empty, an empty uncompressed DEFLATE block
   can be built and used for this purpose as follows:

       0x00

   The single octet 0x00 contains the header bits with &quot;BFINAL&quot; set to 0
   and &quot;BTYPE&quot; set to 00, and 5 padding bits of 0.

<span class="h3"><a class="selflink" id="section-7.3" href="#section-7.3">7.3</a>.  Implementation Notes</span>

   On most common software development platforms, the DEFLATE
   compression library provides a method for aligning compressed data to
   byte boundaries using an empty DEFLATE block with no compression.
   For example, zlib [<a href="#ref-zlib" title="&quot;zlib&quot;">zlib</a>] does this when &quot;Z_SYNC_FLUSH&quot; is passed to
   the deflate function.

   Some platforms may only provide methods to output and process
   compressed data with a zlib header and an Adler-32 checksum.  On such
   platforms, developers need to write stub code to remove and
   complement the zlib and Adler-32 checksum by themselves.

   To obtain a useful compression ratio, an LZ77 sliding window size of
   1,024 or more is RECOMMENDED.

   If a side disallows context takeover, its endpoint can easily figure
   out whether or not a certain message will be shorter if compressed.
   Otherwise, it&#x27;s not easy to know whether future messages will benefit
   from having a certain message compressed.  Implementors may employ
   some heuristics to determine this.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  Security Considerations</span>

   There is a known exploit when history-based compression is combined
   with a secure transport [<a href="#ref-CRIME" title="&quot;The CRIME attack&quot;">CRIME</a>].  Implementors should pay attention
   to this point when integrating this extension with other extensions
   or protocols.







<span class="grey">Yoshino                      Standards Track                   [Page 25]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-26" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>.  IANA Considerations</span>

<span class="h3"><a class="selflink" id="section-9.1" href="#section-9.1">9.1</a>.  Registration of the &quot;permessage-deflate&quot; WebSocket Extension Name</span>

   IANA has registered the following WebSocket extension name in the
   &quot;WebSocket Extension Name Registry&quot; defined in [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>].

   Extension Identifier
      permessage-deflate

   Extension Common Name
      WebSocket Per-Message Deflate

   Extension Definition
      This document.

   Known Incompatible Extensions
      None

   The &quot;permessage-deflate&quot; extension name is used in the &quot;Sec-
   WebSocket-Extensions&quot; header in the WebSocket opening handshake to
   negotiate use of the &quot;permessage-deflate&quot; extension.

<span class="h3"><a class="selflink" id="section-9.2" href="#section-9.2">9.2</a>.  Registration of the &quot;Per-Message Compressed&quot; WebSocket Framing</span>
<span class="h3">      Header Bit</span>

   IANA has registered the following WebSocket framing header bit in the
   &quot;WebSocket Framing Header Bits Registry&quot; defined in [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>].

   Value
      RSV1

   Description
      The &quot;Per-Message Compressed&quot; bit, which indicates whether or not
      the message is compressed.  RSV1 is set for compressed messages
      and unset for uncompressed messages.

   Reference
      <a href="#section-6">Section 6</a> of this document.

   The &quot;Per-Message Compressed&quot; framing header bit is used on the first
   fragment of data messages to indicate whether the payload of the
   message is compressed by the PMCE or not.








<span class="grey">Yoshino                      Standards Track                   [Page 26]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-27" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>.  References</span>

<span class="h3"><a class="selflink" id="section-10.1" href="#section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-CRIME">CRIME</a>]    Rizzo, J. and T. Duong, &quot;The CRIME attack&quot;, EKOparty
              Security Conference, September 2012.

   [<a id="ref-LZ77">LZ77</a>]     Ziv, J. and A. Lempel, &quot;A Universal Algorithm for
              Sequential Data Compression&quot;, IEEE Transactions on
              Information Theory, Vol. 23, No. 3, pp. 337-343,
              DOI 10.1109/TIT.1977.1055714, May 1977,
              &lt;<a href="https://www.cs.duke.edu/courses/spring03/cps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf">https://www.cs.duke.edu/courses/spring03/cps296.5/papers/</a>
              <a href="https://www.cs.duke.edu/courses/spring03/cps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf">ziv_lempel_1977_universal_algorithm.pdf</a>&gt;.

   [<a id="ref-RFC1951">RFC1951</a>]  Deutsch, P., &quot;DEFLATE Compressed Data Format Specification
              version 1.3&quot;, <a href="/doc/html/rfc1951">RFC 1951</a>, DOI 10.17487/RFC1951, May 1996,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1951">http://www.rfc-editor.org/info/rfc1951</a>&gt;.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC5234">RFC5234</a>]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, <a href="/doc/html/rfc5234">RFC 5234</a>,
              DOI 10.17487/RFC5234, January 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.

   [<a id="ref-RFC6455">RFC6455</a>]  Fette, I. and A. Melnikov, &quot;The WebSocket Protocol&quot;,
              <a href="/doc/html/rfc6455">RFC 6455</a>, DOI 10.17487/RFC6455, December 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6455">http://www.rfc-editor.org/info/rfc6455</a>&gt;.

<span class="h3"><a class="selflink" id="section-10.2" href="#section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-RFC1979">RFC1979</a>]  Woods, J., &quot;PPP Deflate Protocol&quot;, <a href="/doc/html/rfc1979">RFC 1979</a>,
              DOI 10.17487/RFC1979, August 1996,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1979">http://www.rfc-editor.org/info/rfc1979</a>&gt;.

   [<a id="ref-zlib">zlib</a>]     Gailly, J. and M. Adler, &quot;zlib&quot;, &lt;<a href="http://www.zlib.net/">http://www.zlib.net/</a>&gt;.












<span class="grey">Yoshino                      Standards Track                   [Page 27]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-28" ></span>
<span class="grey"><a href="/doc/html/rfc7692">RFC 7692</a>          Compression Extensions for WebSocket     December 2015</span>


Acknowledgements

   Special thanks to Patrick McManus who wrote up the initial
   specification of a DEFLATE-based compression extension for the
   WebSocket Protocol, which I referred to when writing this
   specification.

   Thanks to the following people who participated in discussions on the
   HyBi WG and contributed ideas and/or provided detailed reviews (the
   list is likely incomplete): Adam Rice, Alexander Philippou, Alexey
   Melnikov, Arman Djusupov, Bjoern Hoehrmann, Brian McKelvey, Dario
   Crivelli, Greg Wilkins, Inaki Baz Castillo, Jamie Lokier, Joakim
   Erdfelt, John A. Tamplin, Julian Reschke, Kenichi Ishibashi, Mark
   Nottingham, Peter Thorson, Roberto Peon, Salvatore Loreto, Simone
   Bordet, Tobias Oberstein, and Yutaka Hirano.  Note that the people
   listed above didn&#x27;t necessarily endorse the end result of this work.

Author&#x27;s Address

   Takeshi Yoshino
   Google, Inc.

   Email: tyoshino@google.com




























Yoshino                      Standards Track                   [Page 28]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

