<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc6961
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-tls-multiple-cert-status-extension/">
  <meta name="description" content="The Transport Layer Security (TLS) Multiple Certificate Status Request Extension (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgbrown"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc6961.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc6961.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc6961.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc6961/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc6961/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/tls/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-tls-multiple-cert-status-extension@ietf.org?subject=draft-ietf-tls-multiple-cert-status-extension" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-tls-multiple-cert-status-extension-08.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-tls-multiple-cert-status-extension-08.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-tls-multiple-cert-status-extension-08.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-tls-multiple-cert-status-extension-08">draft-ietf-tls-multiple-cert-status-extension-08</a> Proposed Standard
Obsoleted by: <a href="/doc/html/rfc8446">8446</a>                                          <a class="text-warning" href="https://www.rfc-editor.org/errata_search.php?rfc=6961&amp;rec_status=0">Errata exist</a></pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                      Y. Pettersen
Request for Comments: 6961                                     June 2013
Category: Standards Track
ISSN: 2070-1721


                   <span class="h1">The Transport Layer Security (TLS)</span>
             <span class="h1">Multiple Certificate Status Request Extension</span>

Abstract

   This document defines the Transport Layer Security (TLS) Certificate
   Status Version 2 Extension to allow clients to specify and support
   several certificate status methods.  (The use of the Certificate
   Status extension is commonly referred to as &quot;OCSP stapling&quot;.)  Also
   defined is a new method based on the Online Certificate Status
   Protocol (OCSP) that servers can use to provide status information
   about not only the server&#x27;s own certificate but also the status of
   intermediate certificates in the chain.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="/doc/html/rfc5741#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6961">http://www.rfc-editor.org/info/rfc6961</a>.


















<span class="grey">Pettersen                    Standards Track                    [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   The Transport Layer Security (TLS) Extension [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>] framework
   defines, among other extensions, the Certificate Status extension
   (also referred to as &quot;OCSP stapling&quot;) that clients can use to request
   the server&#x27;s copy of the current status of its certificate.  The
   benefits of this extension include a reduced number of roundtrips and
   network delays for the client to verify the status of the server&#x27;s
   certificate and a reduced load on the certificate issuer&#x27;s status
   response servers, thus solving a problem that can become significant
   when the issued certificate is presented by a frequently visited
   server.

   There are two problems with the existing Certificate Status
   extension.  First, it does not provide functionality to request the
   status information about intermediate Certification Authority (CA)
   certificates, which means the client has to request status
   information through other methods, such as Certificate Revocation
   Lists (CRLs), introducing further delays.  Second, the current format
   of the extension and requirements in the TLS protocol prevent a
   client from offering the server multiple status methods.



<span class="grey">Pettersen                    Standards Track                    [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


   Many CAs are now issuing intermediate CA certificates that not only
   specify the publication point for their CRLs in a CRL Distribution
   Point [<a href="/doc/html/rfc5280" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>] but also specify a URL for their OCSP [<a href="/doc/html/rfc6960" title="&quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&quot;">RFC6960</a>]
   server in Authority Information Access [<a href="/doc/html/rfc5280" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>].  Given that
   client-cached CRLs are frequently out of date, clients would benefit
   from using OCSP to access up-to-date status information about
   intermediate CA certificates.  The benefit to the issuing CA is less
   clear, as providing the bandwidth for the OCSP responder can be
   costly, especially for CAs with many high-traffic subscriber sites,
   and this cost is a concern for many CAs.  There are cases where OCSP
   requests for a single high-traffic site caused significant network
   problems for the issuing CA.

   Clients will benefit from the TLS server providing certificate status
   information regardless of type, not just for the server certificate
   but also for the intermediate CA certificates.  Combining the status
   checks into one extension will reduce the roundtrips needed to
   complete the handshake by the client to just those needed for
   negotiating the TLS connection.  Also, for the Certification
   Authorities, the load on their servers will depend on the number of
   certificates they have issued, not on the number of visitors to those
   sites.  Additionally, using this extension significantly reduces
   privacy concerns around the clients informing the certificate issuer
   about which sites they are visiting.

   For such a new system to be introduced seamlessly, clients need to be
   able to indicate support for the existing OCSP Certificate Status
   method and a new multiple-OCSP mode.

   Unfortunately, the definition of the Certificate Status extension
   only allows a single Certificate Status extension to be defined in a
   single extension record in the handshake, and the TLS protocol
   [<a href="/doc/html/rfc5246" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;">RFC5246</a>] only allows a single record in the extension list for any
   given extension.  This means that it is not possible for clients to
   indicate support for new methods while still supporting older
   methods, which would cause problems for interoperability between
   newer clients and older servers.  This will not just be an issue for
   the multiple status request mode proposed above but also for any
   other future status methods that might be introduced.  This will be
   true not just for the current PKIX infrastructure [<a href="/doc/html/rfc5280" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>] but also
   for alternative PKI structures.

   The solution to this problem is to define a new extension,
   &quot;status_request_v2&quot;, with an extended format that allows the client
   to indicate support for multiple status request methods.  This is
   implemented using a list of CertificateStatusRequestItemV2 records in
   the extension record.  As the server will select the single status




<span class="grey">Pettersen                    Standards Track                    [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


   method based on the selected cipher suite and the certificate
   presented, no significant changes are needed in the server&#x27;s
   extension format.

<span class="h3"><a class="selflink" id="section-1.1" href="#section-1.1">1.1</a>.  Requirements Language</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in <a href="/doc/html/rfc2119">RFC 2119</a> [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

<span class="h3"><a class="selflink" id="section-1.2" href="#section-1.2">1.2</a>.  Presentation Language</span>

   This document defines protocol structures using the same conventions
   and presentation language as defined in <a href="/doc/html/rfc5246#section-4">Section&nbsp;4 of [RFC5246]</a>.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Multiple Certificate Status Extension</span>

<span class="h3"><a class="selflink" id="section-2.1" href="#section-2.1">2.1</a>.  New Extension</span>

   The extension defined by this document is indicated by
   &quot;status_request_v2&quot; in the ExtensionType enum (originally defined by
   [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>]), which uses the following value:

     enum {
       status_request_v2(17), (65535)
     } ExtensionType;

<span class="h3"><a class="selflink" id="section-2.2" href="#section-2.2">2.2</a>.  Multiple Certificate Status Request Record</span>

   Clients that support a certificate status protocol like OCSP may send
   the &quot;status_request_v2&quot; extension to the server in order to use the
   TLS handshake to transfer such data instead of downloading it through
   separate connections.  When using this extension, the
   &quot;extension_data&quot; field (defined in <a href="/doc/html/rfc5246#section-7.4.1.4">Section&nbsp;7.4.1.4 of [RFC5246]</a>) of
   the extension SHALL contain a CertificateStatusRequestListV2 where:

     struct {
       CertificateStatusType status_type;
       uint16 request_length; /* Length of request field in bytes */
       select (status_type) {
         case ocsp: OCSPStatusRequest;
         case ocsp_multi: OCSPStatusRequest;
       } request;
     } CertificateStatusRequestItemV2;

     enum { ocsp(1), ocsp_multi(2), (255) } CertificateStatusType;





<span class="grey">Pettersen                    Standards Track                    [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


     struct {
       ResponderID responder_id_list&lt;0..2^16-1&gt;;
       Extensions request_extensions;
     } OCSPStatusRequest;

     opaque ResponderID&lt;1..2^16-1&gt;;
     opaque Extensions&lt;0..2^16-1&gt;;

     struct {
       CertificateStatusRequestItemV2
                        certificate_status_req_list&lt;1..2^16-1&gt;;
     } CertificateStatusRequestListV2;

   In the OCSPStatusRequest (originally defined by [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>]), the
   &quot;ResponderID&quot; provides a list of OCSP responders that the client
   trusts.  A zero-length &quot;responder_id_list&quot; sequence has the special
   meaning that the responders are implicitly known to the server, e.g.,
   by prior arrangement, or are identified by the certificates used by
   the server.  &quot;Extensions&quot; is a DER encoding [<a href="#ref-X.690" title="&quot;ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)&quot;">X.690</a>] of the OCSP
   request extensions, and if the server supports the forwarding of OCSP
   request extensions, this value MUST be forwarded without
   modification.

   Both &quot;ResponderID&quot; and &quot;Extensions&quot; are DER-encoded ASN.1 types as
   defined in [<a href="/doc/html/rfc6960" title="&quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&quot;">RFC6960</a>].  &quot;Extensions&quot; is imported from [<a href="/doc/html/rfc5280" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>].  A
   zero-length &quot;request_extensions&quot; value means that there are no
   extensions (as opposed to a DER-encoded zero-length ASN.1 SEQUENCE,
   which is not valid for the &quot;Extensions&quot; type).

   Servers that support a client&#x27;s selection of responders using the
   ResponderID field could implement this selection by matching the
   responder ID values from the client&#x27;s list with the ResponderIDs of
   known OCSP responders, either by using a binary compare of the values
   or a hash calculation and compare method.

   In the case of the &quot;id-pkix-ocsp-nonce&quot; OCSP extension, [<a href="/doc/html/rfc2560" title="&quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&quot;">RFC2560</a>] is
   unclear about its encoding; for clarification, the nonce MUST be a
   DER-encoded OCTET STRING, which is encapsulated as another OCTET
   STRING (note that implementations based on an existing OCSP client
   will need to be checked for conformance to this requirement).  This
   has been clarified in [<a href="/doc/html/rfc6960" title="&quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&quot;">RFC6960</a>].

   The items in the list of CertificateStatusRequestItemV2 entries are
   ordered according to the client&#x27;s preference (favorite choice first).

   A server that receives a client hello containing the
   &quot;status_request_v2&quot; extension MAY return a suitable certificate
   status response message to the client along with the server&#x27;s



<span class="grey">Pettersen                    Standards Track                    [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


   certificate message.  If OCSP is requested, it SHOULD use the
   information contained in the extension when selecting an OCSP
   responder and SHOULD include request_extensions in the OCSP request.

   The server returns a certificate status response along with its
   certificate by sending a &quot;CertificateStatus&quot; message (originally
   defined by [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>]) immediately after the &quot;Certificate&quot; message
   (<a href="/doc/html/rfc5246#section-7.4.2">Section&nbsp;7.4.2 of [RFC5246]</a>) (and before any &quot;ServerKeyExchange&quot; or
   &quot;CertificateRequest&quot; messages).  If a server returns a
   &quot;CertificateStatus&quot; message in response to a &quot;status_request_v2&quot;
   request, then the server MUST have included an extension of type
   &quot;status_request_v2&quot; with empty &quot;extension_data&quot; in the extended
   server hello.

   The &quot;CertificateStatus&quot; message is conveyed using the handshake
   message type &quot;certificate_status&quot; (defined in [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>]) as follows
   (updated from the definition in [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>]):

     struct {
       CertificateStatusType status_type;
       select (status_type) {
         case ocsp: OCSPResponse;
         case ocsp_multi: OCSPResponseList;
       } response;
     } CertificateStatus;

     opaque OCSPResponse&lt;0..2^24-1&gt;;

     struct {
       OCSPResponse ocsp_response_list&lt;1..2^24-1&gt;;
     } OCSPResponseList;

   An &quot;OCSPResponse&quot; element (originally defined by [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>]) contains
   a complete, DER-encoded OCSP response (using the ASN.1 [<a href="#ref-X.680" title="&quot;Abstract Syntax Notation One (ASN.1): Specification of basic notation&quot;">X.680</a>] type
   OCSPResponse defined in [<a href="/doc/html/rfc6960" title="&quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&quot;">RFC6960</a>]).  Only one OCSP response, with a
   length of at least one byte, may be sent for status_type &quot;ocsp&quot;.

   An &quot;ocsp_response_list&quot; contains a list of &quot;OCSPResponse&quot; elements,
   as specified above, each containing the OCSP response for the
   matching corresponding certificate in the server&#x27;s Certificate TLS
   handshake message.  That is, the first entry is the OCSP response for
   the first certificate in the Certificate list, the second entry is
   the response for the second certificate, and so on.  The list MAY
   contain fewer OCSP responses than there were certificates in the
   Certificate handshake message, but there MUST NOT be more responses
   than there were certificates in the list.  Individual elements of the
   list MAY have a length of 0 (zero) bytes if the server does not have
   the OCSP response for that particular certificate stored, in which



<span class="grey">Pettersen                    Standards Track                    [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


   case the client MUST act as if a response was not received for that
   particular certificate.  If the client receives a
   &quot;ocsp_response_list&quot; that does not contain a response for one or more
   of the certificates in the completed certificate chain, the client
   SHOULD attempt to validate the certificate using an alternative
   retrieval method, such as downloading the relevant CRL; OCSP SHOULD
   in this situation only be used for the end-entity certificate, not
   intermediate CA certificates, for reasons stated above.

   Note that a server MAY also choose not to send a &quot;CertificateStatus&quot;
   message, even if it has received a &quot;status_request_v2&quot; extension in
   the client hello message and has sent a &quot;status_request_v2&quot; extension
   in the server hello message.  Additionally, note that a server MUST
   NOT send the &quot;CertificateStatus&quot; message unless it received either a
   &quot;status_request&quot; or &quot;status_request_v2&quot; extension in the client hello
   message and sent a corresponding &quot;status_request&quot; or
   &quot;status_request_v2&quot; extension in the server hello message.

   Clients requesting an OCSP response and receiving one or more OCSP
   responses in a &quot;CertificateStatus&quot; message MUST check the OCSP
   response(s) and abort the handshake if the response is a &quot;revoked&quot;
   status or other unacceptable responses (as determined by client
   policy) with a bad_certificate_status_response(113) alert.  This
   alert is always fatal.

   If the OCSP response received from the server does not result in a
   definite &quot;good&quot; or &quot;revoked&quot; status, it is inconclusive.  A TLS
   client in such a case MAY check the validity of the server
   certificate through other means, e.g., by directly querying the
   certificate issuer.  If such processing still results in an
   inconclusive response, then the application using the TLS connection
   will have to decide whether to close the connection or not.  Note
   that this problem cannot be decided by the generic TLS client code
   without information from the application.  If the application doesn&#x27;t
   provide any such information, then the client MUST abort the
   connection, since the server certificate has not been sufficiently
   validated.

   An example of where the application might wish to continue is with
   EAP-TLS (Extensible Authentication Protocol - TLS), where the
   application can use another mechanism to check the status of a
   certificate once it obtains network access.  In this case, the
   application could have the client continue with the handshake, but it
   MUST NOT disclose a username and password until it has fully
   validated the server certificate.






<span class="grey">Pettersen                    Standards Track                    [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  IANA Considerations</span>

   <a href="#section-2.1">Section 2.1</a> defines the new TLS extension status_request_v2 (17)
   enum, which has been added to the &quot;ExtensionType Values&quot; list in the
   IANA &quot;Transport Layer Security (TLS) Extensions&quot; registry.

   <a href="#section-2.2">Section 2.2</a> describes a TLS CertificateStatusType registry that is
   now maintained by IANA.  The &quot;TLS Certificate Status Types&quot; registry
   has been created under the &quot;Transport Layer Security (TLS)
   Extensions&quot; registry.  CertificateStatusType values are to be
   assigned via IETF Review as defined in [<a href="/doc/html/rfc5226" title="">RFC5226</a>].  The initial
   registry corresponds to the definition of &quot;CertificateStatusType&quot; in
   <a href="#section-2.2">Section 2.2</a>.

   Value   Description   Reference
   -----------------------------------------
   0       Reserved      [<a href="/doc/html/rfc6961">RFC6961</a>]
   1       ocsp          [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>] [<a href="/doc/html/rfc6961">RFC6961</a>]
   2       ocsp_multi    [<a href="/doc/html/rfc6961">RFC6961</a>]
   3-255   Unassigned

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Security Considerations</span>

   General security considerations for TLS extensions are covered in
   [<a href="/doc/html/rfc5246" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;">RFC5246</a>].  Security considerations for the particular extension
   specified in this document are given below.  In general, implementers
   should continue to monitor the state of the art and address any
   weaknesses identified.

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>.  Security Considerations for status_request_v2</span>

   If a client requests an OCSP response, it must take into account that
   an attacker&#x27;s server using a compromised key could (and probably
   would) pretend not to support the extension.  In this case, a client
   that requires OCSP validation of certificates SHOULD either contact
   the OCSP server directly or abort the handshake.

   Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may
   improve security against attacks that attempt to replay OCSP
   responses; see <a href="/doc/html/rfc6960#section-4.4.1">Section&nbsp;4.4.1 of [RFC6960]</a> for further details.

   This extension allows the client to send arbitrary data to the
   server.  The server implementers need to handle such data carefully
   to avoid introducing security vulnerabilities.

   The security considerations of [<a href="/doc/html/rfc6960" title="&quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&quot;">RFC6960</a>] apply to OCSP requests and
   responses.




<span class="grey">Pettersen                    Standards Track                    [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Acknowledgements</span>

   This document is based on [<a href="/doc/html/rfc6066" title="&quot;Transport Layer Security (TLS) Extensions: Extension Definitions&quot;">RFC6066</a>], authored by Donald Eastlake 3rd.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  References</span>

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>, March 1997.

   [<a id="ref-RFC5226">RFC5226</a>]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, <a href="/doc/html/bcp26">BCP 26</a>, <a href="/doc/html/rfc5226">RFC 5226</a>,
              May 2008.

   [<a id="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, <a href="/doc/html/rfc5246">RFC 5246</a>, August 2008.

   [<a id="ref-RFC5280">RFC5280</a>]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, &quot;Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile&quot;, <a href="/doc/html/rfc5280">RFC 5280</a>, May 2008.

   [<a id="ref-RFC6066">RFC6066</a>]  Eastlake, D., &quot;Transport Layer Security (TLS) Extensions:
              Extension Definitions&quot;, <a href="/doc/html/rfc6066">RFC 6066</a>, January 2011.

   [<a id="ref-RFC6960">RFC6960</a>]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, &quot;X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP&quot;,
              <a href="/doc/html/rfc6960">RFC 6960</a>, June 2013.

   [<a id="ref-X.680">X.680</a>]    ITU-T Recommendation X.680 (2008) | ISO/IEC 8824-1:2008,
              &quot;Abstract Syntax Notation One (ASN.1): Specification of
              basic notation&quot;, November 2008.

   [<a id="ref-X.690">X.690</a>]    ITU-T Recommendation X.690 (2008) | ISO/IEC 8825-1:2008,
              &quot;ASN.1 encoding rules: Specification of Basic Encoding
              Rules (BER), Canonical Encoding Rules (CER) and
              Distinguished Encoding Rules (DER)&quot;, November 2008.

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  Informative References</span>

   [<a id="ref-RFC2560">RFC2560</a>]  Myers, M., Ankney, R., Malpani, A., Galperin, S., and C.
              Adams, &quot;X.509 Internet Public Key Infrastructure Online
              Certificate Status Protocol - OCSP&quot;, <a href="/doc/html/rfc2560">RFC 2560</a>, June 1999.






<span class="grey">Pettersen                    Standards Track                    [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc6961">RFC 6961</a>          Multiple Certificate Status Extension        June 2013</span>


Author&#x27;s Address

   Yngve N. Pettersen

   EMail: yngve@spec-work.net














































Pettersen                    Standards Track                   [Page 10]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

