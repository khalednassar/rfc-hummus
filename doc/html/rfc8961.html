<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc8961
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-tcpm-rto-consider/">
  <meta name="description" content="Requirements for Time-Based Loss Detection (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgmagenta"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc8961.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc8961.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/rfc8961.xml" title="XML source for this document">xml</a>|<a href="https://www.rfc-editor.org/rfc/rfc8961.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc8961/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc8961/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/tcpm/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-tcpm-rto-consider@ietf.org?subject=draft-ietf-tcpm-rto-consider" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-tcpm-rto-consider-17.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-tcpm-rto-consider-17.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-tcpm-rto-consider-17.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-tcpm-rto-consider-17">draft-ietf-tcpm-rto-consider-17</a>              Best Current Practice</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                         M. Allman
Request for Comments: 8961                                          ICSI
BCP: 233                                                   November 2020
Category: Best Current Practice
ISSN: 2070-1721


               <span class="h1">Requirements for Time-Based Loss Detection</span>

Abstract

   Many protocols must detect packet loss for various reasons (e.g., to
   ensure reliability using retransmissions or to understand the level
   of congestion along a network path).  While many mechanisms have been
   designed to detect loss, ultimately, protocols can only count on the
   passage of time without delivery confirmation to declare a packet
   &quot;lost&quot;.  Each implementation of a time-based loss detection mechanism
   represents a balance between correctness and timeliness; therefore,
   no implementation suits all situations.  This document provides high-
   level requirements for time-based loss detectors appropriate for
   general use in unicast communication across the Internet.  Within the
   requirements, implementations have latitude to define particulars
   that best address each situation.

Status of This Memo

   This memo documents an Internet Best Current Practice.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   BCPs is available in <a href="/doc/html/rfc7841#section-2">Section&nbsp;2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8961">https://www.rfc-editor.org/info/rfc8961</a>.

Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Terminology
   2.  Context
   3.  Scope
   4.  Requirements
   5.  Discussion
   6.  Security Considerations
   7.  IANA Considerations
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Acknowledgments
   Author&#x27;s Address

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   As a network of networks, the Internet consists of a large variety of
   links and systems that support a wide variety of tasks and workloads.
   The service provided by the network varies from best-effort delivery
   among loosely connected components to highly predictable delivery
   within controlled environments (e.g., between physically connected
   nodes, within a tightly controlled data center).  Each path through
   the network has a set of path properties, e.g., available capacity,
   delay, and packet loss.  Given the range of networks that make up the
   Internet, these properties range from largely static to highly
   dynamic.

   This document provides guidelines for developing an understanding of
   one path property: packet loss.  In particular, we offer guidelines
   for developing and implementing time-based loss detectors that have
   been gradually learned over the last several decades.  We focus on
   the general case where the loss properties of a path are (a) unknown
   a priori and (b) dynamically varying over time.  Further, while there
   are numerous root causes of packet loss, we leverage the conservative
   notion that loss is an implicit indication of congestion [<a href="/doc/html/rfc5681" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].
   While this stance is not always correct, as a general assumption it
   has historically served us well [<a href="#ref-Jac88" title="&quot;Congestion avoidance and control&quot;">Jac88</a>].  As we discuss further in
   <a href="#section-2">Section 2</a>, the guidelines in this document should be viewed as a
   general default for unicast communication across best-effort networks
   and not as optimal -- or even applicable -- for all situations.

   Given that packet loss is routine in best-effort networks, loss
   detection is a crucial activity for many protocols and applications
   and is generally undertaken for two major reasons:

   (1)  Ensuring reliable data delivery

        This requires a data sender to develop an understanding of which
        transmitted packets have not arrived at the receiver.  This
        knowledge allows the sender to retransmit missing data.

   (2)  Congestion control

        As we mention above, packet loss is often taken as an implicit
        indication that the sender is transmitting too fast and is
        overwhelming some portion of the network path.  Data senders can
        therefore use loss to trigger transmission rate reductions.

   Various mechanisms are used to detect losses in a packet stream.
   Often, we use continuous or periodic acknowledgments from the
   recipient to inform the sender&#x27;s notion of which pieces of data are
   missing.  However, despite our best intentions and most robust
   mechanisms, we cannot place ultimate faith in receiving such
   acknowledgments but can only truly depend on the passage of time.
   Therefore, our ultimate backstop to ensuring that we detect all loss
   is a timeout.  That is, the sender sets some expectation for how long
   to wait for confirmation of delivery for a given piece of data.  When
   this time period passes without delivery confirmation, the sender
   concludes the data was lost in transit.

   The specifics of time-based loss detection schemes represent a
   tradeoff between correctness and responsiveness.  In other words, we
   wish to simultaneously:

   *  wait long enough to ensure the detection of loss is correct, and

   *  minimize the amount of delay we impose on applications (before
      repairing loss) and the network (before we reduce the congestion).

   Serving both of these goals is difficult, as they pull in opposite
   directions [<a href="#ref-AP99" title="&quot;On Estimating End-to-End Network Path Properties&quot;">AP99</a>].  By not waiting long enough to accurately
   determine a packet has been lost, we may provide a needed
   retransmission in a timely manner but risk both sending unnecessary
   (&quot;spurious&quot;) retransmissions and needlessly lowering the transmission
   rate.  By waiting long enough that we are unambiguously certain a
   packet has been lost, we cannot repair losses in a timely manner and
   we risk prolonging network congestion.

   Many protocols and applications -- such as TCP [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>], SCTP
   [<a href="/doc/html/rfc4960" title="&quot;Stream Control Transmission Protocol&quot;">RFC4960</a>], and SIP [<a href="/doc/html/rfc3261" title="&quot;SIP: Session Initiation Protocol&quot;">RFC3261</a>] -- use their own time-based loss
   detection mechanisms.  At this point, our experience leads to a
   recognition that often specific tweaks that deviate from standardized
   time-based loss detectors do not materially impact network safety
   with respect to congestion control [<a href="#ref-AP99" title="&quot;On Estimating End-to-End Network Path Properties&quot;">AP99</a>].  Therefore, in this
   document we outline a set of high-level, protocol-agnostic
   requirements for time-based loss detection.  The intent is to provide
   a safe foundation on which implementations have the flexibility to
   instantiate mechanisms that best realize their specific goals.

<span class="h3"><a class="selflink" id="section-1.1" href="#section-1.1">1.1</a>.  Terminology</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in
   <a href="/doc/html/bcp14">BCP 14</a> [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="/doc/html/rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Context</span>

   This document is different from the way we ideally like to engineer
   systems.  Usually, we strive to understand high-level requirements as
   a starting point.  We then methodically engineer specific protocols,
   algorithms, and systems that meet these requirements.  Within the
   IETF standards process, we have derived many time-based loss
   detection schemes without the benefit of some over-arching
   requirements document -- because we had no idea how to write such a
   document!  Therefore, we made the best specific decisions we could in
   response to specific needs.

   At this point, however, the community&#x27;s experience has matured to the
   point where we can define a set of general, high-level requirements
   for time-based loss detection schemes.  We now understand how to
   separate the strategies these mechanisms use that are crucial for
   network safety from those small details that do not materially impact
   network safety.  The requirements in this document may not be
   appropriate in all cases.  In particular, the guidelines in <a href="#section-4">Section 4</a>
   are concerned with the general case, but specific situations may
   allow for more flexibility in terms of loss detection because
   specific facets of the environment are known (e.g., when operating
   over a single physical link or within a tightly controlled data
   center).  Therefore, variants, deviations, or wholly different time-
   based loss detectors may be necessary or useful in some cases.  The
   correct way to view this document is as the default case and not as
   one-size-fits-all guidance that is optimal in all cases.

   Adding a requirements umbrella to a body of existing specifications
   is inherently messy and we run the risk of creating inconsistencies
   with both past and future mechanisms.  Therefore, we make the
   following statements about the relationship of this document to past
   and future specifications:

   *  This document does not update or obsolete any existing RFC.  These
      previous specifications -- while generally consistent with the
      requirements in this document -- reflect community consensus, and
      this document does not change that consensus.

   *  The requirements in this document are meant to provide for network
      safety and, as such, SHOULD be used by all future time-based loss
      detection mechanisms.

   *  The requirements in this document may not be appropriate in all
      cases; therefore, deviations and variants may be necessary in the
      future (hence the &quot;SHOULD&quot; in the last bullet).  However,
      inconsistencies MUST be (a) explained and (b) gather consensus.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Scope</span>

   The principles we outline in this document are protocol-agnostic and
   widely applicable.  We make the following scope statements about the
   application of the requirements discussed in <a href="#section-4">Section 4</a>:

   (S.1) While there are a bevy of uses for timers in protocols -- from
         rate-based pacing to connection failure detection and beyond --
         this document is focused only on loss detection.

   (S.2) The requirements for time-based loss detection mechanisms in
         this document are for the primary or &quot;last resort&quot; loss
         detection mechanism, whether the mechanism is the sole loss
         repair strategy or works in concert with other mechanisms.

         While a straightforward time-based loss detector is sufficient
         for simple protocols like DNS [<a href="/doc/html/rfc1034" title="&quot;Domain names - concepts and facilities&quot;">RFC1034</a>] [<a href="/doc/html/rfc1035" title="&quot;Domain names - implementation and specification&quot;">RFC1035</a>], more complex
         protocols often use more advanced loss detectors to aid
         performance.  For instance, TCP and SCTP have methods to detect
         (and repair) loss based on explicit endpoint state sharing
         [<a href="/doc/html/rfc2018" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>] [<a href="/doc/html/rfc4960" title="&quot;Stream Control Transmission Protocol&quot;">RFC4960</a>] [<a href="/doc/html/rfc6675" title="&quot;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&quot;">RFC6675</a>].  Such mechanisms often provide
         more timely and precise loss detection than time-based loss
         detectors.  However, these mechanisms do not obviate the need
         for a &quot;retransmission timeout&quot; or &quot;RTO&quot; because, as we discuss
         in <a href="#section-1">Section 1</a>, only the passage of time can ultimately be relied
         upon to detect loss.  In other words, we ultimately cannot
         count on acknowledgments to arrive at the data sender to
         indicate which packets never arrived at the receiver.  In cases
         such as these, we need a time-based loss detector to function
         as a &quot;last resort&quot;.

         Also, note that some recent proposals have incorporated time as
         a component of advanced loss detection methods either as an
         aggressive first loss detector in certain situations or in
         conjunction with endpoint state sharing [<a href="#ref-DCCM13" title="&quot;Tail Loss Probe (TLP): An Algorithm for Fast Recovery of Tail Losses&quot;">DCCM13</a>] [<a href="#ref-CCDJ20" title="&quot;The RACK-TLP loss detection algorithm for TCP&quot;">CCDJ20</a>]
         [<a href="#ref-IS20" title="&quot;QUIC Loss Detection and Congestion Control&quot;">IS20</a>].  While these mechanisms can aid timely loss recovery,
         the protocol ultimately leans on another more conservative
         timer to ensure reliability when these mechanisms break down.
         The requirements in this document are only directly applicable
         to last-resort loss detection.  However, we expect that many of
         the requirements can serve as useful guidelines for more
         aggressive non-last-resort timers as well.

   (S.3) The requirements in this document apply only to endpoint-to-
         endpoint unicast communication.  Reliable multicast (e.g.,
         [<a href="/doc/html/rfc5740" title="&quot;NACK-Oriented Reliable Multicast (NORM) Transport Protocol&quot;">RFC5740</a>]) protocols are explicitly outside the scope of this
         document.

         Protocols such as SCTP [<a href="/doc/html/rfc4960" title="&quot;Stream Control Transmission Protocol&quot;">RFC4960</a>] and Multipath TCP (MP-TCP)
         [<a href="/doc/html/rfc6182" title="&quot;Architectural Guidelines for Multipath TCP Development&quot;">RFC6182</a>] that communicate in a unicast fashion with multiple
         specific endpoints can leverage the requirements in this
         document provided they track state and follow the requirements
         for each endpoint independently.  That is, if host A
         communicates with addresses B and C, A needs to use independent
         time-based loss detector instances for traffic sent to B and C.

   (S.4) There are cases where state is shared across connections or
         flows (e.g., [<a href="/doc/html/rfc2140" title="&quot;TCP Control Block Interdependence&quot;">RFC2140</a>] and [<a href="/doc/html/rfc3124" title="&quot;The Congestion Manager&quot;">RFC3124</a>]).  State pertaining to
         time-based loss detection is often discussed as sharable.
         These situations raise issues that the simple flow-oriented
         time-based loss detection mechanism discussed in this document
         does not consider (e.g., how long to preserve state between
         connections).  Therefore, while the general principles given in
         <a href="#section-4">Section 4</a> are likely applicable, sharing time-based loss
         detection information across flows is outside the scope of this
         document.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Requirements</span>

   We now list the requirements that apply when designing primary or
   last-resort time-based loss detection mechanisms.  For historical
   reasons and ease of exposition, we refer to the time between sending
   a packet and determining the packet has been lost due to lack of
   delivery confirmation as the &quot;retransmission timeout&quot; or &quot;RTO&quot;.
   After the RTO passes without delivery confirmation, the sender may
   safely assume the packet is lost.  However, as discussed above, the
   detected loss need not be repaired (i.e., the loss could be detected
   only for congestion control and not reliability purposes).

   (1)  As we note above, loss detection happens when a sender does not
        receive delivery confirmation within some expected period of
        time.  In the absence of any knowledge about the latency of a
        path, the initial RTO MUST be conservatively set to no less than
        1 second.

        Correctness is of the utmost importance when transmitting into a
        network with unknown properties because:

        *  Premature loss detection can trigger spurious retransmits
           that could cause issues when a network is already congested.

        *  Premature loss detection can needlessly cause congestion
           control to dramatically lower the sender&#x27;s allowed
           transmission rate, especially since the rate is already
           likely low at this stage of the communication.  Recovering
           from such a rate change can take a relatively long time.

        *  Finally, as discussed below, sometimes using time-based loss
           detection and retransmissions can cause ambiguities in
           assessing the latency of a network path.  Therefore, it is
           especially important for the first latency sample to be free
           of ambiguities such that there is a baseline for the
           remainder of the communication.

        The specific constant (1 second) comes from the analysis of
        Internet round-trip times (RTTs) found in <a href="/doc/html/rfc6298#appendix-A">Appendix&nbsp;A of
        [RFC6298]</a>.

   (2)  We now specify four requirements that pertain to setting an
        expected time interval for delivery confirmation.

        Often, measuring the time required for delivery confirmation is
        framed as assessing the RTT of the network path.  The RTT is the
        minimum amount of time required to receive delivery confirmation
        and also often follows protocol behavior whereby acknowledgments
        are generated quickly after data arrives.  For instance, this is
        the case for the RTO used by TCP [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>] and SCTP [<a href="/doc/html/rfc4960" title="&quot;Stream Control Transmission Protocol&quot;">RFC4960</a>].
        However, this is somewhat misleading, and the expected latency
        is better framed as the &quot;feedback time&quot; (FT).  In other words,
        the expectation is not always simply a network property; it can
        include additional time before a sender should reasonably expect
        a response.

        For instance, consider a UDP-based DNS request from a client to
        a recursive resolver [<a href="/doc/html/rfc1035" title="&quot;Domain names - implementation and specification&quot;">RFC1035</a>].  When the request can be served
        from the resolver&#x27;s cache, the feedback time (FT) likely well
        approximates the network RTT between the client and resolver.
        However, on a cache miss, the resolver will request the needed
        information from one or more authoritative DNS servers, which
        will non-trivially increase the FT compared to the network RTT
        between the client and resolver.

        Therefore, we express the requirements in terms of FT.  Again,
        for ease of exposition, we use &quot;RTO&quot; to indicate the interval
        between a packet transmission and the decision that the packet
        has been lost, regardless of whether the packet will be
        retransmitted.

        (a)  The RTO SHOULD be set based on multiple observations of the
             FT when available.

             In other words, the RTO should represent an empirically
             derived reasonable amount of time that the sender should
             wait for delivery confirmation before deciding the given
             data is lost.  Network paths are inherently dynamic;
             therefore, it is crucial to incorporate multiple recent FT
             samples in the RTO to take into account the delay variation
             across time.

             For example, TCP&#x27;s RTO [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>] would satisfy this
             requirement due to its use of an exponentially weighted
             moving average (EWMA) to combine multiple FT samples into a
             &quot;smoothed RTT&quot;.  In the name of conservativeness, TCP goes
             further to also include an explicit variance term when
             computing the RTO.

             While multiple FT samples are crucial for capturing the
             delay dynamics of a path, we explicitly do not tightly
             specify the process -- including the number of FT samples
             to use and how/when to age samples out of the RTO
             calculation -- as the particulars could depend on the
             situation and/or goals of each specific loss detector.

             Finally, FT samples come from packet exchanges between
             peers.  We encourage protocol designers -- especially for
             new protocols -- to strive to ensure the feedback is not
             easily spoofable by on- or off-path attackers such that
             they can perturb a host&#x27;s notion of the FT.  Ideally, all
             messages would be cryptographically secure, but given that
             this is not always possible -- especially in legacy
             protocols -- using a healthy amount of randomness in the
             packets is encouraged.

        (b)  FT observations SHOULD be taken and incorporated into the
             RTO at least once per RTT or as frequently as data is
             exchanged in cases where that happens less frequently than
             once per RTT.

             Internet measurements show that taking only a single FT
             sample per TCP connection results in a relatively poorly
             performing RTO mechanism [<a href="#ref-AP99" title="&quot;On Estimating End-to-End Network Path Properties&quot;">AP99</a>], hence this requirement
             that the FT be sampled continuously throughout the lifetime
             of communication.

             As an example, TCP takes an FT sample roughly once per RTT,
             or, if using the timestamp option [<a href="/doc/html/rfc7323" title="&quot;TCP Extensions for High Performance&quot;">RFC7323</a>], on each
             acknowledgment arrival.  [<a href="#ref-AP99" title="&quot;On Estimating End-to-End Network Path Properties&quot;">AP99</a>] shows that both these
             approaches result in roughly equivalent performance for the
             RTO estimator.

        (c)  FT observations MAY be taken from non-data exchanges.

             Some protocols use non-data exchanges for various reasons,
             e.g., keepalives, heartbeats, and control messages.  To the
             extent that the latency of these exchanges mirrors data
             exchange, they can be leveraged to take FT samples within
             the RTO mechanism.  Such samples can help protocols keep
             their RTO accurate during lulls in data transmission.
             However, given that these messages may not be subject to
             the same delays as data transmission, we do not take a
             general view on whether this is useful or not.

        (d)  An RTO mechanism MUST NOT use ambiguous FT samples.

             Assume two copies of some packet X are transmitted at times
             t0 and t1.  Then, at time t2, the sender receives
             confirmation that X in fact arrived.  In some cases, it is
             not clear which copy of X triggered the confirmation;
             hence, the actual FT is either t2-t1 or t2-t0, but which is
             a mystery.  Therefore, in this situation, an implementation
             MUST NOT use either version of the FT sample and hence not
             update the RTO (as discussed in [<a href="#ref-KP87" title="&quot;Improving Round-Trip Time Estimates in Reliable Transport Protocols&quot;">KP87</a>] and [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>]).

             There are cases where two copies of some data are
             transmitted in a way whereby the sender can tell which is
             being acknowledged by an incoming ACK.  For example, TCP&#x27;s
             timestamp option [<a href="/doc/html/rfc7323" title="&quot;TCP Extensions for High Performance&quot;">RFC7323</a>] allows for packets to be
             uniquely identified and hence avoid the ambiguity.  In such
             cases, there is no ambiguity and the resulting samples can
             update the RTO.

   (3)  Loss detected by the RTO mechanism MUST be taken as an
        indication of network congestion and the sending rate adapted
        using a standard mechanism (e.g., TCP collapses the congestion
        window to one packet [<a href="/doc/html/rfc5681" title="&quot;TCP Congestion Control&quot;">RFC5681</a>]).

        This ensures network safety.

        An exception to this rule is if an IETF standardized mechanism
        determines that a particular loss is due to a non-congestion
        event (e.g., packet corruption).  In such a case, a congestion
        control action is not required.  Additionally, congestion
        control actions taken based on time-based loss detection could
        be reversed when a standard mechanism post facto determines that
        the cause of the loss was not congestion (e.g., [<a href="/doc/html/rfc5682" title="&quot;Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP&quot;">RFC5682</a>]).

   (4)  Each time the RTO is used to detect a loss, the value of the RTO
        MUST be exponentially backed off such that the next firing
        requires a longer interval.  The backoff SHOULD be removed after
        either (a) the subsequent successful transmission of non-
        retransmitted data, or (b) an RTO passes without detecting
        additional losses.  The former will generally be quicker.  The
        latter covers cases where loss is detected but not repaired.

        A maximum value MAY be placed on the RTO.  The maximum RTO MUST
        NOT be less than 60 seconds (as specified in [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>]).

        This ensures network safety.

        As with guideline (3), an exception to this rule exists if an
        IETF standardized mechanism determines that a particular loss is
        not due to congestion.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Discussion</span>

   We note that research has shown the tension between the
   responsiveness and correctness of time-based loss detection seems to
   be a fundamental tradeoff in the context of TCP [<a href="#ref-AP99" title="&quot;On Estimating End-to-End Network Path Properties&quot;">AP99</a>].  That is,
   making the RTO more aggressive (e.g., via changing TCP&#x27;s
   exponentially weighted moving average (EWMA) gains, lowering the
   minimum RTO, etc.) can reduce the time required to detect actual
   loss.  However, at the same time, such aggressiveness leads to more
   cases of mistakenly declaring packets lost that ultimately arrived at
   the receiver.  Therefore, being as aggressive as the requirements
   given in the previous section allow in any particular situation may
   not be the best course of action because detecting loss, even if
   falsely, carries a requirement to invoke a congestion response that
   will ultimately reduce the transmission rate.

   While the tradeoff between responsiveness and correctness seems
   fundamental, the tradeoff can be made less relevant if the sender can
   detect and recover from mistaken loss detection.  Several mechanisms
   have been proposed for this purpose, such as Eifel [<a href="/doc/html/rfc3522" title="&quot;The Eifel Detection Algorithm for TCP&quot;">RFC3522</a>], Forward
   RTO-Recovery (F-RTO) [<a href="/doc/html/rfc5682" title="&quot;Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP&quot;">RFC5682</a>], and Duplicate Selective
   Acknowledgement (DSACK) [<a href="/doc/html/rfc2883" title="&quot;An Extension to the Selective Acknowledgement (SACK) Option for TCP&quot;">RFC2883</a>] [<a href="/doc/html/rfc3708" title="&quot;Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions&quot;">RFC3708</a>].  Using such mechanisms
   may allow a data originator to tip towards being more responsive
   without incurring (as much of) the attendant costs of mistakenly
   declaring packets to be lost.

   Also, note that, in addition to the experiments discussed in [<a href="#ref-AP99" title="&quot;On Estimating End-to-End Network Path Properties&quot;">AP99</a>],
   the Linux TCP implementation has been using various non-standard RTO
   mechanisms for many years seemingly without large-scale problems
   (e.g., using different EWMA gains than specified in [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>]).
   Further, a number of TCP implementations use a steady-state minimum
   RTO that is less than the 1 second specified in [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>].  While the
   implication of these deviations from the standard may be more
   spurious retransmits (per [<a href="#ref-AP99" title="&quot;On Estimating End-to-End Network Path Properties&quot;">AP99</a>]), we are aware of no large-scale
   network safety issues caused by this change to the minimum RTO.  This
   informs the guidelines in the last section (e.g., there is no minimum
   RTO specified).

   Finally, we note that while allowing implementations to be more
   aggressive could in fact increase the number of needless
   retransmissions, the above requirements fail safely in that they
   insist on exponential backoff and a transmission rate reduction.
   Therefore, providing implementers more latitude than they have
   traditionally been given in IETF specifications of RTO mechanisms
   does not somehow open the flood gates to aggressive behavior.  Since
   there is a downside to being aggressive, the incentives for proper
   behavior are retained in the mechanism.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Security Considerations</span>

   This document does not alter the security properties of time-based
   loss detection mechanisms.  See [<a href="/doc/html/rfc6298" title="&quot;Computing TCP&#x27;s Retransmission Timer&quot;">RFC6298</a>] for a discussion of these
   within the context of TCP.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  IANA Considerations</span>

   This document has no IANA actions.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  References</span>

<span class="h3"><a class="selflink" id="section-8.1" href="#section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in <a href="/doc/html/rfc2119">RFC</a>
              <a href="/doc/html/rfc2119">2119</a> Key Words&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

<span class="h3"><a class="selflink" id="section-8.2" href="#section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-AP99">AP99</a>]     Allman, M. and V. Paxson, &quot;On Estimating End-to-End
              Network Path Properties&quot;, Proceedings of the ACM SIGCOMM
              Technical Symposium, September 1999.

   [<a id="ref-CCDJ20">CCDJ20</a>]   Cheng, Y., Cardwell, N., Dukkipati, N., and P. Jha, &quot;The
              RACK-TLP loss detection algorithm for TCP&quot;, Work in
              Progress, Internet-Draft, <a href="/doc/html/draft-ietf-tcpm-rack-13">draft-ietf-tcpm-rack-13</a>, 2
              November 2020,
              &lt;<a href="https://tools.ietf.org/html/draft-ietf-tcpm-rack-13">https://tools.ietf.org/html/draft-ietf-tcpm-rack-13</a>&gt;.

   [<a id="ref-DCCM13">DCCM13</a>]   Dukkipati, N., Cardwell, N., Cheng, Y., and M. Mathis,
              &quot;Tail Loss Probe (TLP): An Algorithm for Fast Recovery of
              Tail Losses&quot;, Work in Progress, Internet-Draft, <a href="/doc/html/draft-dukkipati-tcpm-tcp-loss-probe-01">draft-</a>
              <a href="/doc/html/draft-dukkipati-tcpm-tcp-loss-probe-01">dukkipati-tcpm-tcp-loss-probe-01</a>, 25 February 2013,
              &lt;<a href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-</a>
              <a href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">loss-probe-01</a>&gt;.

   [<a id="ref-IS20">IS20</a>]     Iyengar, J., Ed. and I. Swett, Ed., &quot;QUIC Loss Detection
              and Congestion Control&quot;, Work in Progress, Internet-Draft,
              <a href="/doc/html/draft-ietf-quic-recovery-32">draft-ietf-quic-recovery-32</a>, 20 October 2020,
              &lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-32">https://tools.ietf.org/html/draft-ietf-quic-recovery-32</a>&gt;.

   [<a id="ref-Jac88">Jac88</a>]    Jacobson, V., &quot;Congestion avoidance and control&quot;, ACM
              SIGCOMM, DOI 10.1145/52325.52356, August 1988,
              &lt;<a href="https://doi.org/10.1145/52325.52356">https://doi.org/10.1145/52325.52356</a>&gt;.

   [<a id="ref-KP87">KP87</a>]     Karn, P. and C. Partridge, &quot;Improving Round-Trip Time
              Estimates in Reliable Transport Protocols&quot;, SIGCOMM 87.

   [<a id="ref-RFC1034">RFC1034</a>]  Mockapetris, P., &quot;Domain names - concepts and facilities&quot;,
              STD 13, <a href="/doc/html/rfc1034">RFC 1034</a>, DOI 10.17487/RFC1034, November 1987,
              &lt;<a href="https://www.rfc-editor.org/info/rfc1034">https://www.rfc-editor.org/info/rfc1034</a>&gt;.

   [<a id="ref-RFC1035">RFC1035</a>]  Mockapetris, P., &quot;Domain names - implementation and
              specification&quot;, STD 13, <a href="/doc/html/rfc1035">RFC 1035</a>, DOI 10.17487/RFC1035,
              November 1987, &lt;<a href="https://www.rfc-editor.org/info/rfc1035">https://www.rfc-editor.org/info/rfc1035</a>&gt;.

   [<a id="ref-RFC2018">RFC2018</a>]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &quot;TCP
              Selective Acknowledgment Options&quot;, <a href="/doc/html/rfc2018">RFC 2018</a>,
              DOI 10.17487/RFC2018, October 1996,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;.

   [<a id="ref-RFC2140">RFC2140</a>]  Touch, J., &quot;TCP Control Block Interdependence&quot;, <a href="/doc/html/rfc2140">RFC 2140</a>,
              DOI 10.17487/RFC2140, April 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2140">https://www.rfc-editor.org/info/rfc2140</a>&gt;.

   [<a id="ref-RFC2883">RFC2883</a>]  Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, &quot;An
              Extension to the Selective Acknowledgement (SACK) Option
              for TCP&quot;, <a href="/doc/html/rfc2883">RFC 2883</a>, DOI 10.17487/RFC2883, July 2000,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2883">https://www.rfc-editor.org/info/rfc2883</a>&gt;.

   [<a id="ref-RFC3124">RFC3124</a>]  Balakrishnan, H. and S. Seshan, &quot;The Congestion Manager&quot;,
              <a href="/doc/html/rfc3124">RFC 3124</a>, DOI 10.17487/RFC3124, June 2001,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3124">https://www.rfc-editor.org/info/rfc3124</a>&gt;.

   [<a id="ref-RFC3261">RFC3261</a>]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, &quot;SIP: Session Initiation Protocol&quot;, <a href="/doc/html/rfc3261">RFC 3261</a>,
              DOI 10.17487/RFC3261, June 2002,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3261">https://www.rfc-editor.org/info/rfc3261</a>&gt;.

   [<a id="ref-RFC3522">RFC3522</a>]  Ludwig, R. and M. Meyer, &quot;The Eifel Detection Algorithm
              for TCP&quot;, <a href="/doc/html/rfc3522">RFC 3522</a>, DOI 10.17487/RFC3522, April 2003,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3522">https://www.rfc-editor.org/info/rfc3522</a>&gt;.

   [<a id="ref-RFC3708">RFC3708</a>]  Blanton, E. and M. Allman, &quot;Using TCP Duplicate Selective
              Acknowledgement (DSACKs) and Stream Control Transmission
              Protocol (SCTP) Duplicate Transmission Sequence Numbers
              (TSNs) to Detect Spurious Retransmissions&quot;, <a href="/doc/html/rfc3708">RFC 3708</a>,
              DOI 10.17487/RFC3708, February 2004,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3708">https://www.rfc-editor.org/info/rfc3708</a>&gt;.

   [<a id="ref-RFC4960">RFC4960</a>]  Stewart, R., Ed., &quot;Stream Control Transmission Protocol&quot;,
              <a href="/doc/html/rfc4960">RFC 4960</a>, DOI 10.17487/RFC4960, September 2007,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4960">https://www.rfc-editor.org/info/rfc4960</a>&gt;.

   [<a id="ref-RFC5681">RFC5681</a>]  Allman, M., Paxson, V., and E. Blanton, &quot;TCP Congestion
              Control&quot;, <a href="/doc/html/rfc5681">RFC 5681</a>, DOI 10.17487/RFC5681, September 2009,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;.

   [<a id="ref-RFC5682">RFC5682</a>]  Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata,
              &quot;Forward RTO-Recovery (F-RTO): An Algorithm for Detecting
              Spurious Retransmission Timeouts with TCP&quot;, <a href="/doc/html/rfc5682">RFC 5682</a>,
              DOI 10.17487/RFC5682, September 2009,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5682">https://www.rfc-editor.org/info/rfc5682</a>&gt;.

   [<a id="ref-RFC5740">RFC5740</a>]  Adamson, B., Bormann, C., Handley, M., and J. Macker,
              &quot;NACK-Oriented Reliable Multicast (NORM) Transport
              Protocol&quot;, <a href="/doc/html/rfc5740">RFC 5740</a>, DOI 10.17487/RFC5740, November 2009,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5740">https://www.rfc-editor.org/info/rfc5740</a>&gt;.

   [<a id="ref-RFC6182">RFC6182</a>]  Ford, A., Raiciu, C., Handley, M., Barre, S., and J.
              Iyengar, &quot;Architectural Guidelines for Multipath TCP
              Development&quot;, <a href="/doc/html/rfc6182">RFC 6182</a>, DOI 10.17487/RFC6182, March 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6182">https://www.rfc-editor.org/info/rfc6182</a>&gt;.

   [<a id="ref-RFC6298">RFC6298</a>]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              &quot;Computing TCP&#x27;s Retransmission Timer&quot;, <a href="/doc/html/rfc6298">RFC 6298</a>,
              DOI 10.17487/RFC6298, June 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;.

   [<a id="ref-RFC6675">RFC6675</a>]  Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo, M.,
              and Y. Nishida, &quot;A Conservative Loss Recovery Algorithm
              Based on Selective Acknowledgment (SACK) for TCP&quot;,
              <a href="/doc/html/rfc6675">RFC 6675</a>, DOI 10.17487/RFC6675, August 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;.

   [<a id="ref-RFC7323">RFC7323</a>]  Borman, D., Braden, B., Jacobson, V., and R.
              Scheffenegger, Ed., &quot;TCP Extensions for High Performance&quot;,
              <a href="/doc/html/rfc7323">RFC 7323</a>, DOI 10.17487/RFC7323, September 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7323">https://www.rfc-editor.org/info/rfc7323</a>&gt;.

Acknowledgments

   This document benefits from years of discussions with Ethan Blanton,
   Sally Floyd, Jana Iyengar, Shawn Ostermann, Vern Paxson, and the
   members of the TCPM and TCPIMPL Working Groups.  Ran Atkinson,
   Yuchung Cheng, David Black, Stewart Bryant, Martin Duke, Wesley Eddy,
   Gorry Fairhurst, Rahul Arvind Jadhav, Benjamin Kaduk, Mirja
   Kühlewind, Nicolas Kuhn, Jonathan Looney, and Michael Scharf provided
   useful comments on previous draft versions of this document.

Author&#x27;s Address

   Mark Allman
   International Computer Science Institute
   2150 Shattuck Ave., Suite 1100
   Berkeley, CA 94704
   United States of America

   Email: mallman@icir.org
   URI:   <a href="https://www.icir.org/mallman">https://www.icir.org/mallman</a>
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

