<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc8698
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.34.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.34.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-rmcat-nada/">
  <meta name="description" content="Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion Control Scheme for Real-Time Media (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.34.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.34.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgyellow"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc8698.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc8698.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/rfc8698.xml" title="XML source for this document">xml</a>|<a href="https://www.rfc-editor.org/rfc/rfc8698.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc8698/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc8698/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/rmcat/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-rmcat-nada@ietf.org?subject=draft-ietf-rmcat-nada" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-rmcat-nada-13.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-rmcat-nada-13.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-rmcat-nada-13.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-rmcat-nada-13">draft-ietf-rmcat-nada-13</a>                              Experimental
                                                        <a class="text-warning" href="/ipr/search/?submit=draft&amp;id=draft-ietf-rmcat-nada">IPR declarations</a></pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                            X. Zhu
Request for Comments: 8698                                 Cisco Systems
Category: Experimental                                            R. Pan
ISSN: 2070-1721                                        Intel Corporation
                                                              M. Ramalho
                                                           AcousticComms
                                                                 S. Mena
                                                           Cisco Systems
                                                           February 2020


Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion Control
                       Scheme for Real-Time Media

Abstract

   This document describes Network-Assisted Dynamic Adaptation (NADA), a
   novel congestion control scheme for interactive real-time media
   applications such as video conferencing.  In the proposed scheme, the
   sender regulates its sending rate, based on either implicit or
   explicit congestion signaling, in a unified approach.  The scheme can
   benefit from Explicit Congestion Notification (ECN) markings from
   network nodes.  It also maintains consistent sender behavior in the
   absence of such markings by reacting to queuing delays and packet
   losses instead.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for examination, experimental implementation, and
   evaluation.

   This document defines an Experimental Protocol for the Internet
   community.  This document is a product of the Internet Engineering
   Task Force (IETF).  It represents the consensus of the IETF
   community.  It has received public review and has been approved for
   publication by the Internet Engineering Steering Group (IESG).  Not
   all documents approved by the IESG are candidates for any level of
   Internet Standard; see <a href="/doc/html/rfc7841#section-2">Section&nbsp;2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8698">https://www.rfc-editor.org/info/rfc8698</a>.

Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
   3.  System Overview
   4.  Core Congestion Control Algorithm
     4.1.  Mathematical Notations
     4.2.  Receiver-Side Algorithm
     4.3.  Sender-Side Algorithm
   5.  Practical Implementation of NADA
     5.1.  Receiver-Side Operation
       5.1.1.  Estimation of One-Way Delay and Queuing Delay
       5.1.2.  Estimation of Packet Loss/Marking Ratio
       5.1.3.  Estimation of Receiving Rate
     5.2.  Sender-Side Operation
       5.2.1.  Rate-Shaping Buffer
       5.2.2.  Adjusting Video Target Rate and Sending Rate
     5.3.  Feedback Message Requirements
   6.  Discussions and Further Investigations
     6.1.  Choice of Delay Metrics
     6.2.  Method for Delay, Loss, and Marking Ratio Estimation
     6.3.  Impact of Parameter Values
     6.4.  Sender-Based vs. Receiver-Based Calculation
     6.5.  Incremental Deployment
   7.  Reference Implementations
   8.  Suggested Experiments
   9.  IANA Considerations
   10. Security Considerations
   11. References
     11.1.  Normative References
     11.2.  Informative References
   <a href="#appendix-A">Appendix A</a>.  Network Node Operations
     A.1.  Default Behavior of Drop-Tail Queues
     A.2.  RED-Based ECN Marking
     A.3.  Random Early Marking with Virtual Queues
   Acknowledgments
   Contributors
   Authors&#x27; Addresses

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   Interactive real-time media applications introduce a unique set of
   challenges for congestion control.  Unlike TCP, the mechanism used
   for real-time media needs to adapt quickly to instantaneous bandwidth
   changes, accommodate fluctuations in the output of video encoder rate
   control, and cause low queuing delay over the network.  An ideal
   scheme should also make effective use of all types of congestion
   signals, including packet loss, queuing delay, and explicit
   congestion notification (ECN) [<a href="/doc/html/rfc3168">RFC3168</a>] markings.  The requirements
   for the congestion control algorithm are outlined in [<a href="#ref-RMCAT-CC">RMCAT-CC</a>].  The
   requirements highlight that the desired congestion control scheme
   should 1) avoid flow starvation and attain a reasonable fair share of
   bandwidth when competing against other flows, 2) adapt quickly, and
   3) operate in a stable manner.

   This document describes an experimental congestion control scheme
   called Network-Assisted Dynamic Adaptation (NADA).  The design of
   NADA benefits from explicit congestion control signals (e.g., ECN
   markings) from the network, yet also operates when only implicit
   congestion indicators (delay and/or loss) are available.  Such a
   unified sender behavior distinguishes NADA from other congestion
   control schemes for real-time media.  In addition, its core
   congestion control algorithm is designed to guarantee stability for
   path round-trip times (RTTs) below a prescribed bound (e.g., 250 ms
   with default parameter choices).  It further supports weighted
   bandwidth sharing among competing video flows with different
   priorities.  The signaling mechanism consists of standard Real-time
   Transport Protocol (RTP) timestamp [<a href="/doc/html/rfc3550">RFC3550</a>] and Real-time Transport
   Control Protocol (RTCP) feedback reports.  The definition of the
   desired RTCP feedback message is described in detail in
   [<a href="#ref-RTCP-FEEDBACK">RTCP-FEEDBACK</a>] so as to support the successful operation of several
   congestion control schemes for real-time interactive media.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Terminology</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in
   <a href="/doc/html/bcp14">BCP 14</a> [<a href="/doc/html/rfc2119">RFC2119</a>] [<a href="/doc/html/rfc8174">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  System Overview</span>

   Figure 1 shows the end-to-end system for real-time media transport
   that NADA operates in.  Note that there also exist network nodes
   along the reverse (potentially uncongested) path that the RTCP
   feedback reports traverse.  Those network nodes are not shown in the
   figure for the sake of brevity.

     +---------+  r_vin  +--------+        +--------+     +----------+
     |  Media  |&lt;--------|  RTP   |        |Network |     |   RTP    |
     | Encoder |========&gt;| Sender |=======&gt;|  Node  |====&gt;| Receiver |
     +---------+  r_vout +--------+ r_send +--------+     +----------+
                             /|\                                |
                              |                                 |
                              +---------------------------------+
                                    RTCP Feedback Report

                         Figure 1: System Overview

   Media encoder with rate control capabilities:  Encodes raw media
      (audio and video) frames into a compressed bitstream that is later
      packetized into RTP packets.  As discussed in [<a href="/doc/html/rfc8593">RFC8593</a>], the
      actual output rate from the encoder r_vout may fluctuate around
      the target r_vin.  Furthermore, it is possible that the encoder
      can only react to bit rate changes at rather coarse time
      intervals, e.g., once every 0.5 seconds.

   RTP sender:  Responsible for calculating the NADA reference rate
      based on network congestion indicators (delay, loss, or ECN
      marking reports from the receiver), for updating the video encoder
      with a new target rate r_vin and for regulating the actual sending
      rate r_send accordingly.  The RTP sender also generates a sending
      timestamp for each outgoing packet.

   RTP receiver:  Responsible for measuring and estimating end-to-end
      delay (based on sender timestamp), packet loss (based on RTP
      sequence number), ECN marking ratios (based on [<a href="/doc/html/rfc6679">RFC6679</a>]), and
      receiving rate (r_recv) of the flow.  It calculates the aggregated
      congestion signal (x_curr) that accounts for queuing delay, ECN
      markings, and packet losses.  The receiver also determines the
      mode for sender rate adaptation (rmode) based on whether the flow
      has encountered any standing non-zero congestion.  The receiver
      sends periodic RTCP reports back to the sender, containing values
      of x_curr, rmode, and r_recv.

   Network node with several modes of operation:  The system can work
      with the default behavior of a simple drop-tail queue.  It can
      also benefit from advanced Active Queue Management (AQM) features
      such as Proportional Integral Controller Enhanced (PIE) [<a href="/doc/html/rfc8033">RFC8033</a>],
      Flow Queue Controlling Queue Delay (FQ-CoDel) [<a href="/doc/html/rfc8290">RFC8290</a>], ECN
      marking based on Random Early Detection (RED) [<a href="/doc/html/rfc7567">RFC7567</a>], and Pre-
      Congestion Notification (PCN) marking using a token bucket
      algorithm [<a href="/doc/html/rfc6660">RFC6660</a>].  Note that network node operation is out of
      scope for the design of NADA.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Core Congestion Control Algorithm</span>

   Like TCP-Friendly Rate Control (TFRC) [<a href="#ref-FLOYD-CCR00">FLOYD-CCR00</a>] [<a href="/doc/html/rfc5348">RFC5348</a>], NADA
   is a rate-based congestion control algorithm.  In its simplest form,
   the sender reacts to the collection of network congestion indicators
   in the form of an aggregated congestion signal and operates in one of
   two modes:

   Accelerated ramp up:  When the bottleneck is deemed to be
      underutilized, the rate increases multiplicatively with respect to
      the rate of previously successful transmissions.  The rate
      increase multiplier (gamma) is calculated based on the observed
      round-trip time and target feedback interval, so as to limit self-
      inflicted queuing delay.

   Gradual rate update:  In the presence of a non-zero aggregate
      congestion signal, the sending rate is adjusted in reaction to
      both its value (x_curr) and its change in value (x_diff).

   This section introduces the list of mathematical notations and
   describes the core congestion control algorithm at the sender and
   receiver, respectively.  Additional details on recommended practical
   implementations are described in Sections <a href="#section-5.1">5.1</a> and <a href="#section-5.2">5.2</a>.

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>.  Mathematical Notations</span>

   This section summarizes the list of variables and parameters used in
   the NADA algorithm.  Table 2 also includes the default values for
   choosing the algorithm parameters to represent either a typical
   setting in practical applications or a setting based on theoretical
   and simulation studies.  See <a href="#section-6.3">Section 6.3</a> for some of the discussions
   on the impact of parameter values.  Additional studies in real-world
   settings suggested in <a href="#section-8">Section 8</a> could gather further insight on how
   to choose and adapt these parameter values in practical deployment.

   +------------+------------------------------------------------+
   | Notation   | Variable Name                                  |
   +============+================================================+
   | t_curr     | Current timestamp                              |
   +------------+------------------------------------------------+
   | t_last     | Last time sending/receiving a feedback message |
   +------------+------------------------------------------------+
   | delta      | Observed interval between current and previous |
   |            | feedback reports: delta = t_curr-t_last        |
   +------------+------------------------------------------------+
   | r_ref      | Reference rate based on network congestion     |
   +------------+------------------------------------------------+
   | r_send     | Sending rate                                   |
   +------------+------------------------------------------------+
   | r_recv     | Receiving rate                                 |
   +------------+------------------------------------------------+
   | r_vin      | Target rate for video encoder                  |
   +------------+------------------------------------------------+
   | r_vout     | Output rate from video encoder                 |
   +------------+------------------------------------------------+
   | d_base     | Estimated baseline delay                       |
   +------------+------------------------------------------------+
   | d_fwd      | Measured and filtered one-way delay            |
   +------------+------------------------------------------------+
   | d_queue    | Estimated queuing delay                        |
   +------------+------------------------------------------------+
   | d_tilde    | Equivalent delay after non-linear warping      |
   +------------+------------------------------------------------+
   | p_mark     | Estimated packet ECN marking ratio             |
   +------------+------------------------------------------------+
   | p_loss     | Estimated packet loss ratio                    |
   +------------+------------------------------------------------+
   | x_curr     | Aggregate congestion signal                    |
   +------------+------------------------------------------------+
   | x_prev     | Previous value of aggregate congestion signal  |
   +------------+------------------------------------------------+
   | x_diff     | Change in aggregate congestion signal w.r.t.   |
   |            | its previous value: x_diff = x_curr - x_prev   |
   +------------+------------------------------------------------+
   | rmode      | Rate update mode: (0 = accelerated ramp up; 1  |
   |            | = gradual update)                              |
   +------------+------------------------------------------------+
   | gamma      | Rate increase multiplier in accelerated ramp-  |
   |            | up mode                                        |
   +------------+------------------------------------------------+
   | loss_int   | Measured average loss interval in packet count |
   +------------+------------------------------------------------+
   | loss_exp   | Threshold value for setting the last observed  |
   |            | packet loss to expiration                      |
   +------------+------------------------------------------------+
   | rtt        | Estimated round-trip time at sender            |
   +------------+------------------------------------------------+
   | buffer_len | Rate-shaping buffer occupancy measured in      |
   |            | bytes                                          |
   +------------+------------------------------------------------+

                      Table 1: List of Variables

   +-----------+-------------------------------------------+---------+
   | Notation  | Parameter Name                            | Default |
   |           |                                           | Value   |
   +===========+===========================================+=========+
   | PRIO      | Weight of priority of the flow            | 1.0     |
   +-----------+-------------------------------------------+---------+
   | RMIN      | Minimum rate of application supported by  | 150     |
   |           | media encoder                             | Kbps    |
   +-----------+-------------------------------------------+---------+
   | RMAX      | Maximum rate of application supported by  | 1.5     |
   |           | media encoder                             | Mbps    |
   +-----------+-------------------------------------------+---------+
   | XREF      | Reference congestion level                | 10 ms   |
   +-----------+-------------------------------------------+---------+
   | KAPPA     | Scaling parameter for gradual rate update | 0.5     |
   |           | calculation                               |         |
   +-----------+-------------------------------------------+---------+
   | ETA       | Scaling parameter for gradual rate update | 2.0     |
   |           | calculation                               |         |
   +-----------+-------------------------------------------+---------+
   | TAU       | Upper bound of RTT in gradual rate update | 500 ms  |
   |           | calculation                               |         |
   +-----------+-------------------------------------------+---------+
   | DELTA     | Target feedback interval                  | 100 ms  |
   +-----------+-------------------------------------------+---------+
   | LOGWIN    | Observation window in time for            | 500 ms  |
   |           | calculating packet summary statistics at  |         |
   |           | receiver                                  |         |
   +-----------+-------------------------------------------+---------+
   | QEPS      | Threshold for determining queuing delay   | 10 ms   |
   |           | buildup at receiver                       |         |
   +-----------+-------------------------------------------+---------+
   | DFILT     | Bound on filtering delay                  | 120 ms  |
   +-----------+-------------------------------------------+---------+
   | GAMMA_MAX | Upper bound on rate increase ratio for    | 0.5     |
   |           | accelerated ramp up                       |         |
   +-----------+-------------------------------------------+---------+
   | QBOUND    | Upper bound on self-inflicted queuing     | 50 ms   |
   |           | delay during ramp up                      |         |
   +-----------+-------------------------------------------+---------+
   | MULTILOSS | Multiplier for self-scaling the           | 7.0     |
   |           | expiration threshold of the last observed |         |
   |           | loss (loss_exp) based on measured average |         |
   |           | loss interval (loss_int)                  |         |
   +-----------+-------------------------------------------+---------+
   | QTH       | Delay threshold for invoking non-linear   | 50 ms   |
   |           | warping                                   |         |
   +-----------+-------------------------------------------+---------+
   | LAMBDA    | Scaling parameter in the exponent of non- | 0.5     |
   |           | linear warping                            |         |
   +-----------+-------------------------------------------+---------+
   | PLRREF    | Reference packet loss ratio               | 0.01    |
   +-----------+-------------------------------------------+---------+
   | PMRREF    | Reference packet marking ratio            | 0.01    |
   +-----------+-------------------------------------------+---------+
   | DLOSS     | Reference delay penalty for loss when     | 10 ms   |
   |           | packet loss ratio is at PLRREF            |         |
   +-----------+-------------------------------------------+---------+
   | DMARK     | Reference delay penalty for ECN marking   | 2 ms    |
   |           | when packet marking is at PMRREF          |         |
   +-----------+-------------------------------------------+---------+
   | FPS       | Frame rate of incoming video              | 30      |
   +-----------+-------------------------------------------+---------+
   | BETA_S    | Scaling parameter for modulating outgoing | 0.1     |
   |           | sending rate                              |         |
   +-----------+-------------------------------------------+---------+
   | BETA_V    | Scaling parameter for modulating video    | 0.1     |
   |           | encoder target rate                       |         |
   +-----------+-------------------------------------------+---------+
   | ALPHA     | Smoothing factor in exponential smoothing | 0.1     |
   |           | of packet loss and marking ratios         |         |
   +-----------+-------------------------------------------+---------+

      Table 2: List of Algorithm Parameters and Their Default Values

<span class="h3"><a class="selflink" id="section-4.2" href="#section-4.2">4.2</a>.  Receiver-Side Algorithm</span>

   The receiver-side algorithm can be outlined as below:

      On initialization:

         set d_base = +INFINITY

         set p_loss = 0

         set p_mark = 0

         set r_recv = 0

         set both t_last and t_curr as current time in milliseconds

      On receiving a media packet:

         obtain current timestamp t_curr from system clock

         obtain from packet header sending time stamp t_sent

         obtain one-way delay measurement: d_fwd = t_curr - t_sent

         update baseline delay: d_base = min(d_base, d_fwd)

         update queuing delay: d_queue = d_fwd - d_base

         update packet loss ratio estimate p_loss

         update packet marking ratio estimate p_mark

         update measurement of receiving rate r_recv

      On time to send a new feedback report (t_curr - t_last &gt; DELTA):

         calculate non-linear warping of delay d_tilde if packet loss
         exists

         calculate current aggregate congestion signal x_curr

         determine mode of rate adaptation for sender: rmode

         send feedback containing values of: rmode, x_curr, and r_recv

         update t_last = t_curr

   In order for a delay-based flow to hold its ground when competing
   against loss-based flows (e.g., loss-based TCP), it is important to
   distinguish between different levels of observed queuing delay.  For
   instance, over wired connections, a moderate queuing delay value on
   the order of tens of milliseconds is likely self-inflicted or induced
   by other delay-based flows, whereas a high queuing delay value of
   several hundreds of milliseconds may indicate the presence of a loss-
   based flow that does not refrain from increased delay.

   If the last observed packet loss is within the expiration window of
   loss_exp (measured in terms of packet counts), the estimated queuing
   delay follows a non-linear warping:

              / d_queue,                   if d_queue &lt; QTH
              |
   d_tilde = &lt;                                           (1)
              |                  (d_queue-QTH)
              \ QTH exp(-LAMBDA ---------------) , otherwise
                                    QTH

   In Equation (1), the queuing delay value is unchanged when it is
   below the first threshold QTH; otherwise, it is scaled down following
   a non-linear curve.  This non-linear warping is inspired by the
   delay-adaptive congestion window backoff policy in [<a href="#ref-BUDZISZ-AIMD-CC">BUDZISZ-AIMD-CC</a>]
   so as to &quot;gradually nudge&quot; the controller to operate based on loss-
   induced congestion signals when competing against loss-based flows.
   The exact form of the non-linear function has been simplified with
   respect to [<a href="#ref-BUDZISZ-AIMD-CC">BUDZISZ-AIMD-CC</a>].  The value of the threshold QTH should
   be carefully tuned for different operational environments so as to
   avoid potential risks of prematurely discounting the congestion
   signal level.  Typically, a higher value of QTH is required in a
   noisier environment (e.g., over wireless connections or where the
   video stream encounters many time-varying background competing
   traffic) so as to stay robust against occasional non-congestion-
   induced delay spikes.  Additional insights on how this value can be
   tuned or auto-tuned should be gathered from carrying out experimental
   studies in different real-world deployment scenarios.

   The value of loss_exp is configured to self-scale with the average
   packet loss interval loss_int with a multiplier MULTILOSS:

    loss_exp = MULTILOSS *
   loss_int.

   Estimation of the average loss interval loss_int, in turn, follows
   <a href="#section-5.4">Section 5.4</a> of &quot;TCP Friendly Rate Control (TFRC): Protocol
   Specification&quot; [<a href="/doc/html/rfc5348">RFC5348</a>].

   In practice, it is recommended to linearly interpolate between the
   warped (d_tilde) and non-warped (d_queue) values of the queuing delay
   during the transitional period lasting for the duration of loss_int.

   The aggregate congestion signal is:

                            / p_mark \^2        / p_loss \^2
   x_curr = d_tilde + DMARK*|--------|  + DLOSS*|--------|   (2)
                            \ PMRREF /          \ PLRREF /

   Here, DMARK is prescribed a reference delay penalty associated with
   ECN markings at the reference marking ratio of PMRREF; DLOSS is
   prescribed a reference delay penalty associated with packet losses at
   the reference packet loss ratio of PLRREF.  The value of DLOSS and
   DMARK does not depend on configurations at the network node.  Since
   ECN-enabled active queue management schemes typically mark a packet
   before dropping it, the value of DLOSS SHOULD be higher than that of
   DMARK.  Furthermore, the values of DLOSS and DMARK need to be set
   consistently across all NADA flows sharing the same bottleneck link
   so that they can compete fairly.

   In the absence of packet marking and losses, the value of x_curr
   reduces to the observed queuing delay d_queue.  In that case, the
   NADA algorithm operates in the regime of delay-based adaptation.

   Given observed per-packet delay and loss information, the receiver is
   also in a good position to determine whether or not the network is
   underutilized and then recommend the corresponding rate adaptation
   mode for the sender.  The criteria for operating in accelerated ramp-
   up mode are:

   *  No recent packet losses within the observation window LOGWIN; and

   *  No buildup of queuing delay: d_fwd-d_base &lt; QEPS for all previous
      delay samples within the observation window LOGWIN.

   Otherwise, the algorithm operates in graduate update mode.

<span class="h3"><a class="selflink" id="section-4.3" href="#section-4.3">4.3</a>.  Sender-Side Algorithm</span>

   The sender-side algorithm is outlined as follows:

      On initialization:

         set r_ref = RMIN

         set rtt = 0

         set x_prev = 0

         set t_last and t_curr as current system clock time

      On receiving feedback report:

         obtain current timestamp from system clock: t_curr

         obtain values of rmode, x_curr, and r_recv from feedback report

         update estimation of rtt

         measure feedback interval: delta = t_curr - t_last

         if rmode == 0:

            update r_ref following accelerated ramp-up rules

         else:

            update r_ref following gradual update rules

         clip rate r_ref within the range of minimum rate (RMIN) and
         maximum rate (RMAX).

         set x_prev = x_curr

         set t_last = t_curr

   In accelerated ramp-up mode, the rate r_ref is updated as follows:

                                   QBOUND
       gamma = min(GAMMA_MAX, ------------------)       (3)
                               rtt+DELTA+DFILT

                               r_ref = max(r_ref, (1+gamma) r_recv)
                               (4)

   The rate increase multiplier gamma is calculated as a function of the
   upper bound of self-inflicted queuing delay (QBOUND), round-trip time
   (rtt), and target feedback interval (DELTA); it is bound on the
   filtering delay for calculating d_queue (DFILT).  It has a maximum
   value of GAMMA_MAX.  The rationale behind Equations (3)-(4) is that
   the longer it takes for the sender to observe self-inflicted queuing
   delay buildup, the more conservative the sender should be in
   increasing its rate and, hence, the smaller the rate increase
   multiplier.

   In gradual update mode, the rate r_ref is updated as:

       x_offset = x_curr - PRIO*XREF*RMAX/r_ref          (5)

       x_diff   = x_curr - x_prev                        (6)

                              delta    x_offset
       r_ref = r_ref - KAPPA*-------*------------*r_ref
                               TAU       TAU

                                   x_diff
                     - KAPPA*ETA*---------*r_ref         (7)
                                    TAU

   The rate changes in proportion to the previous rate decision.  It is
   affected by two terms: the offset of the aggregate congestion signal
   from its value at equilibrium (x_offset) and its change (x_diff).
   The calculation of x_offset depends on the maximum rate of the flow
   (RMAX), its weight of priority (PRIO), as well as a reference
   congestion signal (XREF).  The value of XREF is chosen so that the
   maximum rate of RMAX can be achieved when the observed congestion
   signal level is below PRIO*XREF.

   At equilibrium, the aggregated congestion signal stabilizes at x_curr
   = PRIO*XREF*RMAX/r_ref.  This ensures that when multiple flows share
   the same bottleneck and observe a common value of x_curr, their rates
   at equilibrium will be proportional to their respective priority
   levels (PRIO) and the range between minimum and maximum rate.  Values
   of the minimum rate (RMIN) and maximum rate (RMAX) will be provided
   by the media codec, for instance, as outlined by [<a href="#ref-RMCAT-CC-RTP">RMCAT-CC-RTP</a>].  In
   the absence of such information, the NADA sender will choose a
   default value of 0 for RMIN and 3 Mbps for RMAX.

   As mentioned in the sender-side algorithm, the final rate is always
   clipped within the dynamic range specified by the application:

       r_ref = min(r_ref, RMAX)                         (8)

       r_ref = max(r_ref, RMIN)                         (9)

   The above operations ignore many practical issues such as clock
   synchronization between sender and receiver, the filtering of noise
   in delay measurements, and base delay expiration.  These will be
   addressed in <a href="#section-5">Section 5</a>.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Practical Implementation of NADA</span>

<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a>.  Receiver-Side Operation</span>

   The receiver continuously monitors end-to-end per-packet statistics
   in terms of delay, loss, and/or ECN marking ratios.  It then
   aggregates all forms of congestion indicators into the form of an
   equivalent delay and periodically reports this back to the sender.
   In addition, the receiver tracks the receiving rate of the flow and
   includes that in the feedback message.

<span class="h4"><a class="selflink" id="section-5.1.1" href="#section-5.1.1">5.1.1</a>.  Estimation of One-Way Delay and Queuing Delay</span>

   The delay estimation process in NADA follows an approach similar to
   that of earlier delay-based congestion control schemes, such as Low
   Extra Delay Background Transport (LEDBAT) [<a href="/doc/html/rfc6817">RFC6817</a>].  For
   experimental implementations, instead of relying on RTP timestamps
   and the transmission time offset RTP header extension [<a href="/doc/html/rfc5450">RFC5450</a>], the
   NADA sender can generate its own timestamp based on the local system
   clock and embed that information in the transport packet header.  The
   NADA receiver estimates the forward delay as having a constant base
   delay component plus a time-varying queuing delay component.  The
   base delay is estimated as the minimum value of one-way delay
   observed over a relatively long period (e.g., tens of minutes),
   whereas the individual queuing delay value is taken to be the
   difference between one-way delay and base delay.  By re-estimating
   the base delay periodically, one can avoid the potential issue of
   base delay expiration, whereby an earlier measured base delay value
   is no longer valid due to underlying route changes or a cumulative
   timing difference introduced by the clock-rate skew between sender
   and receiver.  All delay estimations are based on sender timestamps
   with a recommended granularity of 100 microseconds or finer.

   The individual sample values of queuing delay should be further
   filtered against various non-congestion-induced noise, such as spikes
   due to a processing &quot;hiccup&quot; at the network nodes.  Therefore, in
   addition to calculating the value of queuing delay using d_queue =
   d_fwd - d_base, as expressed in <a href="#section-5.1">Section 5.1</a>, the current
   implementation further employs a minimum filter with a window size of
   15 samples over per-packet queuing delay values.

<span class="h4"><a class="selflink" id="section-5.1.2" href="#section-5.1.2">5.1.2</a>.  Estimation of Packet Loss/Marking Ratio</span>

   The receiver detects packet losses via gaps in the RTP sequence
   numbers of received packets.  For interactive real-time media
   applications with stringent latency constraints (e.g., video
   conferencing), the receiver avoids the packet reordering delay by
   treating out-of-order packets as losses.  The instantaneous packet
   loss ratio p_inst is estimated as the ratio between the number of
   missing packets over the number of total transmitted packets within
   the recent observation window LOGWIN.  The packet loss ratio p_loss
   is obtained after exponential smoothing:


               p_loss = ALPHA*p_inst + (1-ALPHA)*p_loss        (10)

   The filtered result is reported back to the sender as the observed
   packet loss ratio p_loss.

   The estimation of the packet marking ratio p_mark follows the same
   procedure as above.  It is assumed that ECN marking information at
   the IP header can be passed to the receiving endpoint, e.g., by
   following the mechanism described in [<a href="/doc/html/rfc6679">RFC6679</a>].

<span class="h4"><a class="selflink" id="section-5.1.3" href="#section-5.1.3">5.1.3</a>.  Estimation of Receiving Rate</span>

   It is fairly straightforward to estimate the receiving rate r_recv.
   NADA maintains a recent observation window with a time span of LOGWIN
   and simply divides the total size of packets arriving during that
   window over the time span.  The receiving rate (r_recv) can be either
   calculated at the sender side based on the per-packet feedback from
   the receiver or included as part of the feedback report.

<span class="h3"><a class="selflink" id="section-5.2" href="#section-5.2">5.2</a>.  Sender-Side Operation</span>

   Figure 2 provides a detailed view of the NADA sender.  Upon receipt
   of an RTCP feedback report from the receiver, the NADA sender
   calculates the reference rate r_ref as specified in <a href="#section-4.3">Section 4.3</a>.  It
   further adjusts both the target rate for the live video encoder r_vin
   and the sending rate r_send over the network based on the updated
   value of r_ref and rate-shaping buffer occupancy buffer_len.

   The NADA sender behavior stays the same in the presence of all types
   of congestion indicators: delay, loss, and ECN marking.  This unified
   approach allows a graceful transition of the scheme as the network
   shifts dynamically between light and heavy congestion levels.

                      +----------------+
                      |  Calculate     | &lt;---- RTCP report
                      | Reference Rate |
                      -----------------+
                              | r_ref
                 +------------+-------------+
                 |                          |
                \|/                        \|/
         +-----------------+           +---------------+
         | Calculate Video |           |   Calculate   |
         |  Target Rate    |           | Sending Rate  |
         +-----------------+           +---------------+
             |        /|\                 /|\      |
       r_vin |         |                   |       |
            \|/        +-------------------+       |
         +----------+          | buffer_len        |  r_send
         |  Video   | r_vout  -----------+        \|/
         |  Encoder |--------&gt;   |||||||||=================&gt;
         +----------+         -----------+    RTP packets
         Rate-Shaping Buffer

                      Figure 2: NADA Sender Structure

<span class="h4"><a class="selflink" id="section-5.2.1" href="#section-5.2.1">5.2.1</a>.  Rate-Shaping Buffer</span>

   The operation of the live video encoder is out of the scope of the
   design for the congestion control scheme in NADA.  Instead, its
   behavior is treated as a black box.

   A rate-shaping buffer is employed to absorb any instantaneous
   mismatch between the encoder rate output r_vout and the regulated
   sending rate r_send.  Its current level of occupancy is measured in
   bytes and is denoted as buffer_len.

   A large rate-shaping buffer contributes to higher end-to-end delay,
   which may harm the performance of real-time media communications.
   Therefore, the sender has a strong incentive to prevent the rate-
   shaping buffer from building up.  The mechanisms adopted are:

   *  To deplete the rate-shaping buffer faster by increasing the
      sending rate r_send; and

   *  To limit incoming packets of the rate-shaping buffer by reducing
      the video encoder target rate r_vin.

<span class="h4"><a class="selflink" id="section-5.2.2" href="#section-5.2.2">5.2.2</a>.  Adjusting Video Target Rate and Sending Rate</span>

   If the level of occupancy in the rate-shaping buffer is accessible at
   the sender, such information can be leveraged to further adjust the
   target rate of the live video encoder r_vin as well as the actual
   sending rate r_send.  The purpose of such adjustments is to mitigate
   the additional latencies introduced by the rate-shaping buffer.  The
   amount of rate adjustment can be calculated as follows:

       r_diff_v = min(0.05*r_ref, BETA_V*8*buffer_len*FPS)     (11)
       r_diff_s = min(0.05*r_ref, BETA_S*8*buffer_len*FPS)     (12)
       r_vin  = max(RMIN, r_ref - r_diff_v)                    (13)
       r_send = min(RMAX, r_ref + r_diff_s)                    (14)

   In Equations (11) and (12), the amount of adjustment is calculated as
   proportional to the size of the rate-shaping buffer but is bounded by
   5% of the reference rate r_ref calculated from network congestion
   feedback alone.  This ensures that the adjustment introduced by the
   rate-shaping buffer will not counteract with the core congestion
   control process.  Equations (13) and (14) indicate the influence of
   the rate-shaping buffer.  A large rate-shaping buffer nudges the
   encoder target rate slightly below (and the sending rate slightly
   above) the reference rate r_ref.  The final video target rate (r_vin)
   and sending rate (r_send) are further bounded within the original
   range of [RMIN, RMAX].

   Intuitively, the amount of extra rate offset needed to completely
   drain the rate-shaping buffer within the duration of a single video
   frame is given by 8*buffer_len*FPS, where FPS stands for the
   reference frame rate of the video.  The scaling parameters BETA_V and
   BETA_S can be tuned to balance between the competing goals of
   maintaining a small rate-shaping buffer and deviating from the
   reference rate point.  Empirical observations show that the rate-
   shaping buffer for a responsive live video encoder typically stays
   empty and only occasionally holds a large frame (e.g., when an intra-
   frame is produced) in transit.  Therefore, the rate adjustment
   introduced by this mechanism is expected to be minor.  For instance,
   a rate-shaping buffer of 2000 bytes will lead to a rate adjustment of
   48 Kbps given the recommended scaling parameters of BETA_V = 0.1 and
   BETA_S = 0.1, and the reference frame rate of FPS = 30.

<span class="h3"><a class="selflink" id="section-5.3" href="#section-5.3">5.3</a>.  Feedback Message Requirements</span>

   The following list of information is required for NADA congestion
   control to function properly:

   Recommended rate adaptation mode (rmode):  A 1-bit flag indicating
      whether the sender should operate in accelerated ramp-up mode
      (rmode=0) or gradual update mode (rmode=1).

   Aggregated congestion signal (x_curr):  The most recently updated
      value, calculated by the receiver according to <a href="#section-4.2">Section 4.2</a>.  This
      information can be expressed with a unit of 100 microseconds
      (i.e., 1/10 of a millisecond) in 15 bits.  This allows a maximum
      value of x_curr at approximately 3.27 seconds.

   Receiving rate (r_recv):  The most recently measured receiving rate
      according to <a href="#section-5.1.3">Section 5.1.3</a>.  This information is expressed with a
      unit of bits per second (bps) in 32 bits (unsigned int).  This
      allows a maximum rate of approximately 4.3 Gbps, approximately
      1000 times the streaming rate of a typical high-definition (HD)
      video conferencing session today.  This field can be expanded
      further by a few more bytes if an even higher rate needs to be
      specified.

   The above list of information can be accommodated by 48 bits, or 6
   bytes, in total.  They can be either included in the feedback report
   from the receiver or, in the case where all receiver-side
   calculations are moved to the sender, derived from per-packet
   information from the feedback message as defined in [<a href="#ref-RTCP-FEEDBACK">RTCP-FEEDBACK</a>].
   Choosing the feedback message interval DELTA is discussed in
   <a href="#section-6.3">Section 6.3</a>.  A target feedback interval of DELTA = 100 ms is
   recommended.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Discussions and Further Investigations</span>

   This section discusses the various design choices made by NADA,
   potential alternative variants of its implementation, and guidelines
   on how the key algorithm parameters can be chosen.  <a href="#section-8">Section 8</a>
   recommends additional experimental setups to further explore these
   topics.

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Choice of Delay Metrics</span>

   The current design works with relative one-way delay (OWD) as the
   main indication of congestion.  The value of the relative OWD is
   obtained by maintaining the minimum value of observed OWD over a
   relatively long time horizon and subtracting that out from the
   observed absolute OWD value.  Such an approach cancels out the fixed
   difference between the sender and receiver clocks.  It has been
   widely adopted by other delay-based congestion control approaches
   such as [<a href="/doc/html/rfc6817">RFC6817</a>].  As discussed in [<a href="/doc/html/rfc6817">RFC6817</a>], the time horizon for
   tracking the minimum OWD needs to be chosen with care; it must be
   long enough for an opportunity to observe the minimum OWD with zero
   standing queue along the path, and it must be sufficiently short
   enough to timely reflect &quot;true&quot; changes in minimum OWD introduced by
   route changes and other rare events and to mitigate the cumulative
   impact of clock rate skew over time.

   The potential drawback in relying on relative OWD as the congestion
   signal is that when multiple flows share the same bottleneck, the
   flow arriving late at the network experiencing a non-empty queue may
   mistakenly consider the standing queuing delay as part of the fixed
   path propagation delay.  This will lead to slightly unfair bandwidth
   sharing among the flows.

   Alternatively, one could move the per-packet statistical handling to
   the sender instead and use relative round-trip time (RTT) in lieu of
   relative OWD, assuming that per-packet acknowledgments are available.
   The main drawback of an RTT-based approach is the noise in the
   measured delay in the reverse direction.

   Note that the choice of either delay metric (relative OWD vs. RTT)
   involves no change in the proposed rate adaptation algorithm.
   Therefore, comparing the pros and cons regarding which delay metric
   to adopt can be kept as an orthogonal direction of investigation.

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  Method for Delay, Loss, and Marking Ratio Estimation</span>

   Like other delay-based congestion control schemes, performance of
   NADA depends on the accuracy of its delay measurement and estimation
   module.  <a href="/doc/html/rfc6817#appendix-A">Appendix&nbsp;A of [RFC6817]</a> provides an extensive discussion on
   this aspect.

   The current recommended practice of applying minimum filter with a
   window size of 15 samples suffices in guarding against processing
   delay outliers observed in wired connections.  For wireless
   connections with a higher packet delay variation (PDV), more
   sophisticated techniques on denoising, outlier rejection, and trend
   analysis may be needed.

   More sophisticated methods in packet loss ratio calculation, such as
   that adopted by [<a href="#ref-FLOYD-CCR00">FLOYD-CCR00</a>], will likely be beneficial.  These
   alternatives are part of the experiments this document proposes.

<span class="h3"><a class="selflink" id="section-6.3" href="#section-6.3">6.3</a>.  Impact of Parameter Values</span>

   In the gradual rate update mode, the parameter TAU indicates the
   upper bound of round-trip time (RTT) in the feedback control loop.
   Typically, the observed feedback interval delta is close to the
   target feedback interval DELTA, and the relative ratio of delta/TAU
   versus ETA dictates the relative strength of influence from the
   aggregate congestion signal offset term (x_offset) versus its recent
   change (x_diff), respectively.  These two terms are analogous to the
   integral and proportional terms in a proportional-integral (PI)
   controller.  The recommended choice of TAU = 500 ms, DELTA = 100 ms,
   and ETA = 2.0 corresponds to a relative ratio of 1:10 between the
   gains of the integral and proportional terms.  Consequently, the rate
   adaptation is mostly driven by the change in the congestion signal
   with a long-term shift towards its equilibrium value driven by the
   offset term.  Finally, the scaling parameter KAPPA determines the
   overall speed of the adaptation and needs to strike a balance between
   responsiveness and stability.

   The choice of the target feedback interval DELTA needs to strike the
   right balance between timely feedback and low RTCP feedback message
   counts.  A target feedback interval of DELTA = 100 ms is recommended,
   corresponding to a feedback bandwidth of 16 Kbps with 200 bytes per
   feedback message -- approximately 1.6% overhead for a 1 Mbps flow.
   Furthermore, both simulation studies and frequency-domain analysis in
   [<a href="#ref-IETF-95">IETF-95</a>] have established that a feedback interval below 250 ms
   (i.e., more frequently than 4 feedback messages per second) will not
   break up the feedback control loop of NADA congestion control.

   In calculating the non-linear warping of delay in Equation (1), the
   current design uses fixed values of QTH for determining whether to
   perform the non-linear warping.  Its value should be carefully tuned
   for different operational environments (e.g., over wired vs. wireless
   connections) so as to avoid the potential risk of prematurely
   discounting the congestion signal level.  It is possible to adapt its
   value based on past observed patterns of queuing delay in the
   presence of packet losses.  It needs to be noted that the non-linear
   warping mechanism may lead to multiple NADA streams stuck in loss-
   based mode when competing against each other.

   In calculating the aggregate congestion signal x_curr, the choice of
   DMARK and DLOSS influence the steady-state packet loss/marking ratio
   experienced by the flow at a given available bandwidth.  Higher
   values of DMARK and DLOSS result in lower steady-state loss/marking
   ratios but are more susceptible to the impact of individual packet
   loss/marking events.  While the value of DMARK and DLOSS are fixed
   and predetermined in the current design, this document also
   encourages further explorations of a scheme for automatically tuning
   these values based on desired bandwidth sharing behavior in the
   presence of other competing loss-based flows (e.g., loss-based TCP).

<span class="h3"><a class="selflink" id="section-6.4" href="#section-6.4">6.4</a>.  Sender-Based vs. Receiver-Based Calculation</span>

   In the current design, the aggregated congestion signal x_curr is
   calculated at the receiver, keeping the sender operation completely
   independent of the form of actual network congestion indications
   (delay, loss, or marking) in use.

   Alternatively, one can shift receiver-side calculations to the
   sender, whereby the receiver simply reports on per-packet information
   via periodic feedback messages as defined in [<a href="#ref-RTCP-FEEDBACK">RTCP-FEEDBACK</a>].  Such
   an approach enables interoperability amongst senders operating on
   different congestion control schemes but requires slightly higher
   overhead in the feedback messages.  See additional discussions in
   [<a href="#ref-RTCP-FEEDBACK">RTCP-FEEDBACK</a>] regarding the desired format of the feedback messages
   and the recommended feedback intervals.

<span class="h3"><a class="selflink" id="section-6.5" href="#section-6.5">6.5</a>.  Incremental Deployment</span>

   One nice property of NADA is the consistent video endpoint behavior
   irrespective of network node variations.  This facilitates gradual,
   incremental adoption of the scheme.

   Initially, the proposed congestion control mechanism can be
   implemented without any explicit support from the network and relies
   solely on observed relative one-way delay measurements and packet
   loss ratios as implicit congestion signals.

   When ECN is enabled at the network nodes with RED-based marking, the
   receiver can fold its observations of ECN markings into the
   calculation of the equivalent delay.  The sender can react to these
   explicit congestion signals without any modification.

   Ultimately, networks equipped with proactive marking based on the
   level of token bucket metering can reap the additional benefits of
   zero standing queues and lower end-to-end delay and work seamlessly
   with existing senders and receivers.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  Reference Implementations</span>

   The NADA scheme has been implemented in both ns-2 [<a href="#ref-NS-2">NS-2</a>] and ns-3
   [<a href="#ref-NS-3">NS-3</a>] simulation platforms.  The implementation in ns-2 hosts the
   calculations as described in <a href="#section-4.2">Section 4.2</a> at the receiver side,
   whereas the implementation in ns-3 hosts these receiver-side
   calculations at the sender for the sake of interoperability.
   Extensive ns-2 simulation evaluations of an earlier draft version of
   this document are recorded in [<a href="#ref-ZHU-PV13">ZHU-PV13</a>].  An open-source
   implementation of NADA as part of an ns-3 module is available at
   [<a href="#ref-NS3-RMCAT">NS3-RMCAT</a>].  Evaluation results of this document based on ns-3 are
   presented in [<a href="#ref-IETF-90">IETF-90</a>] and [<a href="#ref-IETF-91">IETF-91</a>] for wired test cases as
   documented in [<a href="#ref-RMCAT-EVAL-TEST">RMCAT-EVAL-TEST</a>].  Evaluation results of NADA over Wi-
   Fi-based test cases as defined in [<a href="#ref-WIRELESS-TESTS">WIRELESS-TESTS</a>] are presented in
   [<a href="#ref-IETF-93">IETF-93</a>].  These simulation-based evaluations have shown that NADA
   flows can obtain their fair share of bandwidth when competing against
   each other.  They typically adapt fast in reaction to the arrival and
   departure of other flows and can sustain a reasonable throughput when
   competing against loss-based TCP flows.

   [<a id="ref-IETF-90">IETF-90</a>] describes the implementation and evaluation of NADA in a
   lab setting.  Preliminary evaluation results of NADA in single-flow
   and multi-flow test scenarios are presented in [<a href="#ref-IETF-91">IETF-91</a>].

   A reference implementation of NADA has been carried out by modifying
   the WebRTC module embedded in the Mozilla open-source browser.
   Presentations from [<a href="#ref-IETF-103">IETF-103</a>] and [<a href="#ref-IETF-105">IETF-105</a>] document real-world
   evaluations of the modified browser driven by NADA.  The experimental
   setting involves remote connections with endpoints over either home
   or enterprise wireless networks.  These evaluations validate the
   effectiveness of NADA flows in recovering quickly from throughput
   drops caused by intermittent delay spikes over the last-hop wireless
   connections.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  Suggested Experiments</span>

   NADA has been extensively evaluated under various test scenarios,
   including the collection of test cases specified by [<a href="#ref-RMCAT-EVAL-TEST">RMCAT-EVAL-TEST</a>]
   and the subset of Wi-Fi-based test cases in [<a href="#ref-WIRELESS-TESTS">WIRELESS-TESTS</a>].
   Additional evaluations have been carried out to characterize how NADA
   interacts with various AQM schemes such as RED, Controlling Queue
   Delay (CoDel), and Proportional Integral Controller Enhanced (PIE).
   Most of these evaluations have been carried out in simulators.  A few
   key test cases have been evaluated in lab environments with
   implementations embedded in video conferencing clients.  It is
   strongly recommended to carry out implementation and experimentation
   of NADA in real-world settings.  Such exercises will provide insights
   on how to choose or automatically adapt the values of the key
   algorithm parameters (see list in Table 2) as discussed in <a href="#section-6">Section 6</a>.

   Additional experiments are suggested for the following scenarios,
   preferably over real-world networks:

   *  Experiments reflecting the setup of a typical WAN connection.

   *  Experiments with ECN marking capability turned on at the network
      for existing test cases.

   *  Experiments with multiple NADA streams bearing different user-
      specified priorities.

   *  Experiments with additional access technologies, especially over
      cellular networks such as 3G/LTE.

   *  Experiments with various media source contents, including audio
      only, audio and video, and application content sharing (e.g.,
      slideshows).

<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>.  IANA Considerations</span>

   This document has no IANA actions.

<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>.  Security Considerations</span>

   The rate adaptation mechanism in NADA relies on feedback from the
   receiver.  As such, it is vulnerable to attacks where feedback
   messages are hijacked, replaced, or intentionally injected with
   misleading information resulting in denial of service, similar to
   those that can affect TCP.  Therefore, it is RECOMMENDED that the
   RTCP feedback message is at least integrity checked.  In addition,
   [<a href="#ref-RTCP-FEEDBACK">RTCP-FEEDBACK</a>] discusses the potential risk of a receiver providing
   misleading congestion feedback information and the mechanisms for
   mitigating such risks.

   The modification of the sending rate based on the sender-side rate-
   shaping buffer may lead to temporary excessive congestion over the
   network in the presence of an unresponsive video encoder.  However,
   this effect can be mitigated by limiting the amount of rate
   modification introduced by the rate-shaping buffer, bounding the size
   of the rate-shaping buffer at the sender, and maintaining a maximum
   allowed sending rate by NADA.

<span class="h2"><a class="selflink" id="section-11" href="#section-11">11</a>.  References</span>

<span class="h3"><a class="selflink" id="section-11.1" href="#section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3168">RFC3168</a>]  Ramakrishnan, K., Floyd, S., and D. Black, &quot;The Addition
              of Explicit Congestion Notification (ECN) to IP&quot;,
              <a href="/doc/html/rfc3168">RFC 3168</a>, DOI 10.17487/RFC3168, September 2001,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;.

   [<a id="ref-RFC3550">RFC3550</a>]  Schulzrinne, H., Casner, S., Frederick, R., and V.
              Jacobson, &quot;RTP: A Transport Protocol for Real-Time
              Applications&quot;, STD 64, <a href="/doc/html/rfc3550">RFC 3550</a>, DOI 10.17487/RFC3550,
              July 2003, &lt;<a href="https://www.rfc-editor.org/info/rfc3550">https://www.rfc-editor.org/info/rfc3550</a>&gt;.

   [<a id="ref-RFC5348">RFC5348</a>]  Floyd, S., Handley, M., Padhye, J., and J. Widmer, &quot;TCP
              Friendly Rate Control (TFRC): Protocol Specification&quot;,
              <a href="/doc/html/rfc5348">RFC 5348</a>, DOI 10.17487/RFC5348, September 2008,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5348">https://www.rfc-editor.org/info/rfc5348</a>&gt;.

   [<a id="ref-RFC6679">RFC6679</a>]  Westerlund, M., Johansson, I., Perkins, C., O&#x27;Hanlon, P.,
              and K. Carlberg, &quot;Explicit Congestion Notification (ECN)
              for RTP over UDP&quot;, <a href="/doc/html/rfc6679">RFC 6679</a>, DOI 10.17487/RFC6679, August
              2012, &lt;<a href="https://www.rfc-editor.org/info/rfc6679">https://www.rfc-editor.org/info/rfc6679</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in <a href="/doc/html/rfc2119">RFC</a>
              <a href="/doc/html/rfc2119">2119</a> Key Words&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

<span class="h3"><a class="selflink" id="section-11.2" href="#section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-BUDZISZ-AIMD-CC">BUDZISZ-AIMD-CC</a>]
              Budzisz, L., Stanojevic, R., Schlote, A., Baker, F., and
              R. Shorten, &quot;On the Fair Coexistence of Loss- and Delay-
              Based TCP&quot;, IEEE/ACM Transactions on Networking, vol. 19,
              no. 6, pp. 1811-1824, DOI 10.1109/TNET.2011.2159736,
              December 2011,
              &lt;<a href="https://doi.org/10.1109/TNET.2011.2159736">https://doi.org/10.1109/TNET.2011.2159736</a>&gt;.

   [<a id="ref-FLOYD-CCR00">FLOYD-CCR00</a>]
              Floyd, S., Handley, M., Padhye, J., and J. Widmer,
              &quot;Equation-based congestion control for unicast
              applications&quot;, ACM SIGCOMM Computer Communications Review,
              vol. 30, no. 4, pp. 43-56, DOI 10.1145/347057.347397,
              October 2000, &lt;<a href="https://doi.org/10.1145/347057.347397">https://doi.org/10.1145/347057.347397</a>&gt;.

   [<a id="ref-IETF-103">IETF-103</a>] Zhu, X., Pan, R., Ramalho, M., Mena, S., Jones, P., Fu,
              J., and S. D&#x27;Aronco, &quot;NADA Implementation in Mozilla
              Browser&quot;, IETF 103, November 2018,
              &lt;<a href="https://datatracker.ietf.org/meeting/103/materials/slides-103-rmcat-nada-implementation-in-mozilla-browser-00">https://datatracker.ietf.org/meeting/103/materials/</a>
              <a href="https://datatracker.ietf.org/meeting/103/materials/slides-103-rmcat-nada-implementation-in-mozilla-browser-00">slides-103-rmcat-nada-implementation-in-mozilla-browser-</a>
              <a href="https://datatracker.ietf.org/meeting/103/materials/slides-103-rmcat-nada-implementation-in-mozilla-browser-00">00</a>&gt;.

   [<a id="ref-IETF-105">IETF-105</a>] Zhu, X., Pan, R., Ramalho, M., Mena, S., Jones, P., Fu,
              J., and S. D&#x27;Aronco, &quot;NADA Implementation in Mozilla
              Browser and Draft Update&quot;, IETF 105, July 2019,
              &lt;<a href="https://datatracker.ietf.org/meeting/105/materials/slides-105-rmcat-nada-update-02.pdf">https://datatracker.ietf.org/meeting/105/materials/</a>
              <a href="https://datatracker.ietf.org/meeting/105/materials/slides-105-rmcat-nada-update-02.pdf">slides-105-rmcat-nada-update-02.pdf</a>&gt;.

   [<a id="ref-IETF-90">IETF-90</a>]  Zhu, X., Ramalho, M., Ganzhorn, C., Jones, P., and R. Pan,
              &quot;NADA Update: Algorithm, Implementation, and Test Case
              Evaluation Results&quot;, IETF 90, July 2014,
              &lt;<a href="https://tools.ietf.org/agenda/90/slides/slides-90-rmcat-6.pdf">https://tools.ietf.org/agenda/90/slides/slides-90-rmcat-</a>
              <a href="https://tools.ietf.org/agenda/90/slides/slides-90-rmcat-6.pdf">6.pdf</a>&gt;.

   [<a id="ref-IETF-91">IETF-91</a>]  Zhu, X., Pan, R., Ramalho, M., Mena, S., Ganzhorn, C.,
              Jones, P., and S. D&#x27;Aronco, &quot;NADA Algorithm Update and
              Test Case Evaluations&quot;, IETF 91, November 2014,
              &lt;<a href="https://www.ietf.org/proceedings/interim/2014/11/09/rmcat/slides/slides-interim-2014-rmcat-1-2.pdf">https://www.ietf.org/proceedings/interim/2014/11/09/</a>
              <a href="https://www.ietf.org/proceedings/interim/2014/11/09/rmcat/slides/slides-interim-2014-rmcat-1-2.pdf">rmcat/slides/slides-interim-2014-rmcat-1-2.pdf</a>&gt;.

   [<a id="ref-IETF-93">IETF-93</a>]  Zhu, X., Pan, R., Ramalho, M., Mena, S., Ganzhorn, C.,
              Jones, P., D&#x27;Aronco, S., and J. Fu, &quot;Updates on NADA&quot;,
              IETF 93, July 2015,
              &lt;<a href="https://www.ietf.org/proceedings/93/slides/slides-93-rmcat-0.pdf">https://www.ietf.org/proceedings/93/slides/slides-93-</a>
              <a href="https://www.ietf.org/proceedings/93/slides/slides-93-rmcat-0.pdf">rmcat-0.pdf</a>&gt;.

   [<a id="ref-IETF-95">IETF-95</a>]  Zhu, X., Pan, R., Ramalho, M., Mena, S., Jones, P., Fu,
              J., D&#x27;Aronco, S., and C. Ganzhorn, &quot;Updates on NADA:
              Stability Analysis and Impact of Feedback Intervals&quot;, IETF
              95, April 2016,
              &lt;<a href="https://www.ietf.org/proceedings/95/slides/slides-95-rmcat-5.pdf">https://www.ietf.org/proceedings/95/slides/slides-95-</a>
              <a href="https://www.ietf.org/proceedings/95/slides/slides-95-rmcat-5.pdf">rmcat-5.pdf</a>&gt;.

   [<a id="ref-NS-2">NS-2</a>]     &quot;ns-2&quot;, December 2014,
              &lt;<a href="http://nsnam.sourceforge.net/wiki/index.php/Main_Page">http://nsnam.sourceforge.net/wiki/index.php/Main_Page</a>&gt;.

   [<a id="ref-NS-3">NS-3</a>]     &quot;ns-3 Network Simulator&quot;, &lt;<a href="https://www.nsnam.org/">https://www.nsnam.org/</a>&gt;.

   [<a id="ref-NS3-RMCAT">NS3-RMCAT</a>]
              Fu, J., Mena, S., and X. Zhu, &quot;Simulator of IETF RMCAT
              congestion control protocols&quot;, November 2017,
              &lt;<a href="https://github.com/cisco/ns3-rmcat">https://github.com/cisco/ns3-rmcat</a>&gt;.

   [<a id="ref-RFC5450">RFC5450</a>]  Singer, D. and H. Desineni, &quot;Transmission Time Offsets in
              RTP Streams&quot;, <a href="/doc/html/rfc5450">RFC 5450</a>, DOI 10.17487/RFC5450, March 2009,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5450">https://www.rfc-editor.org/info/rfc5450</a>&gt;.

   [<a id="ref-RFC6660">RFC6660</a>]  Briscoe, B., Moncaster, T., and M. Menth, &quot;Encoding Three
              Pre-Congestion Notification (PCN) States in the IP Header
              Using a Single Diffserv Codepoint (DSCP)&quot;, <a href="/doc/html/rfc6660">RFC 6660</a>,
              DOI 10.17487/RFC6660, July 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6660">https://www.rfc-editor.org/info/rfc6660</a>&gt;.

   [<a id="ref-RFC6817">RFC6817</a>]  Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind,
              &quot;Low Extra Delay Background Transport (LEDBAT)&quot;, <a href="/doc/html/rfc6817">RFC 6817</a>,
              DOI 10.17487/RFC6817, December 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6817">https://www.rfc-editor.org/info/rfc6817</a>&gt;.

   [<a id="ref-RFC7567">RFC7567</a>]  Baker, F., Ed. and G. Fairhurst, Ed., &quot;IETF
              Recommendations Regarding Active Queue Management&quot;,
              <a href="/doc/html/bcp197">BCP 197</a>, <a href="/doc/html/rfc7567">RFC 7567</a>, DOI 10.17487/RFC7567, July 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7567">https://www.rfc-editor.org/info/rfc7567</a>&gt;.

   [<a id="ref-RFC8033">RFC8033</a>]  Pan, R., Natarajan, P., Baker, F., and G. White,
              &quot;Proportional Integral Controller Enhanced (PIE): A
              Lightweight Control Scheme to Address the Bufferbloat
              Problem&quot;, <a href="/doc/html/rfc8033">RFC 8033</a>, DOI 10.17487/RFC8033, February 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8033">https://www.rfc-editor.org/info/rfc8033</a>&gt;.

   [<a id="ref-RFC8290">RFC8290</a>]  Hoeiland-Joergensen, T., McKenney, P., Taht, D., Gettys,
              J., and E. Dumazet, &quot;The Flow Queue CoDel Packet Scheduler
              and Active Queue Management Algorithm&quot;, <a href="/doc/html/rfc8290">RFC 8290</a>,
              DOI 10.17487/RFC8290, January 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8290">https://www.rfc-editor.org/info/rfc8290</a>&gt;.

   [<a id="ref-RFC8593">RFC8593</a>]  Zhu, X., Mena, S., and Z. Sarker, &quot;Video Traffic Models
              for RTP Congestion Control Evaluations&quot;, <a href="/doc/html/rfc8593">RFC 8593</a>,
              DOI 10.17487/RFC8593, May 2019,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8593">https://www.rfc-editor.org/info/rfc8593</a>&gt;.

   [<a id="ref-RMCAT-CC">RMCAT-CC</a>] Jesup, R. and Z. Sarker, &quot;Congestion Control Requirements
              for Interactive Real-Time Media&quot;, Work in Progress,
              Internet-Draft, <a href="/doc/html/draft-ietf-rmcat-cc-requirements-09">draft-ietf-rmcat-cc-requirements-09</a>, 12
              December 2014, &lt;<a href="https://tools.ietf.org/html/draft-ietf-rmcat-cc-requirements-09">https://tools.ietf.org/html/draft-ietf-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-rmcat-cc-requirements-09">rmcat-cc-requirements-09</a>&gt;.

   [<a id="ref-RMCAT-CC-RTP">RMCAT-CC-RTP</a>]
              Zanaty, M., Singh, V., Nandakumar, S., and Z. Sarker,
              &quot;Congestion Control and Codec interactions in RTP
              Applications&quot;, Work in Progress, Internet-Draft, <a href="/doc/html/draft-ietf-rmcat-cc-codec-interactions-02">draft-</a>
              <a href="/doc/html/draft-ietf-rmcat-cc-codec-interactions-02">ietf-rmcat-cc-codec-interactions-02</a>, 18 March 2016,
              &lt;<a href="https://tools.ietf.org/html/draft-ietf-rmcat-cc-codec-interactions-02">https://tools.ietf.org/html/draft-ietf-rmcat-cc-codec-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-rmcat-cc-codec-interactions-02">interactions-02</a>&gt;.

   [<a id="ref-RMCAT-EVAL-TEST">RMCAT-EVAL-TEST</a>]
              Sarker, Z., Singh, V., Zhu, X., and M. Ramalho, &quot;Test
              Cases for Evaluating RMCAT Proposals&quot;, Work in Progress,
              Internet-Draft, <a href="/doc/html/draft-ietf-rmcat-eval-test-10">draft-ietf-rmcat-eval-test-10</a>, 23 May
              2019, &lt;<a href="https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10">https://tools.ietf.org/html/draft-ietf-rmcat-eval-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10">test-10</a>&gt;.

   [<a id="ref-RTCP-FEEDBACK">RTCP-FEEDBACK</a>]
              Sarker, Z., Perkins, C., Singh, V., and M. Ramalho, &quot;RTP
              Control Protocol (RTCP) Feedback for Congestion Control&quot;,
              Work in Progress, Internet-Draft, <a href="/doc/html/draft-ietf-avtcore-cc-feedback-message-05">draft-ietf-avtcore-cc-</a>
              <a href="/doc/html/draft-ietf-avtcore-cc-feedback-message-05">feedback-message-05</a>, 4 November 2019,
              &lt;<a href="https://tools.ietf.org/html/draft-ietf-avtcore-cc-feedback-message-05">https://tools.ietf.org/html/draft-ietf-avtcore-cc-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-avtcore-cc-feedback-message-05">feedback-message-05</a>&gt;.

   [<a id="ref-WIRELESS-TESTS">WIRELESS-TESTS</a>]
              Sarker, Z., Johansson, I., Zhu, X., Fu, J., Tan, W., and
              M. Ramalho, &quot;Evaluation Test Cases for Interactive Real-
              Time Media over Wireless Networks&quot;, Work in Progress,
              Internet-Draft, <a href="/doc/html/draft-ietf-rmcat-wireless-tests-08">draft-ietf-rmcat-wireless-tests-08</a>, 5 July
              2019, &lt;<a href="https://tools.ietf.org/html/draft-ietf-rmcat-wireless-tests-08">https://tools.ietf.org/html/draft-ietf-rmcat-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-rmcat-wireless-tests-08">wireless-tests-08</a>&gt;.

   [<a id="ref-ZHU-PV13">ZHU-PV13</a>] Zhu, X. and R. Pan, &quot;NADA: A Unified Congestion Control
              Scheme for Low-Latency Interactive Video&quot;, Proc. IEEE
              International Packet Video Workshop, San Jose, CA, USA,
              DOI 10.1109/PV.2013.6691448, December 2013,
              &lt;<a href="https://doi.org/10.1109/PV.2013.6691448">https://doi.org/10.1109/PV.2013.6691448</a>&gt;.

<span class="h2"><a class="selflink" id="appendix-A" href="#appendix-A">Appendix A</a>.  Network Node Operations</span>

   NADA can work with different network queue management schemes and
   does not assume any specific network node operation.  As an example,
   this appendix describes three variants of queue management behavior
   at the network node, leading to either implicit or explicit
   congestion signals.  It needs to be acknowledged that NADA has not
   yet been tested with non-probabilistic ECN marking behaviors.

   In all three flavors described below, the network queue operates with
   the simple First In, First Out (FIFO) principle.  There is no need to
   maintain per-flow state.  The system can scale easily with a large
   number of video flows and at high link capacity.

<span class="h3"><a class="selflink" id="appendix-A.1" href="#appendix-A.1">A.1</a>.  Default Behavior of Drop-Tail Queues</span>

   In a conventional network with drop-tail or RED queues, congestion is
   inferred from the estimation of end-to-end delay and/or packet loss.
   Packet drops at the queue are detected at the receiver and contribute
   to the calculation of the aggregated congestion signal x_curr.  No
   special action is required at the network node.

<span class="h3"><a class="selflink" id="appendix-A.2" href="#appendix-A.2">A.2</a>.  RED-Based ECN Marking</span>

   In this mode, the network node randomly marks the ECN field in the IP
   packet header following the Random Early Detection (RED) algorithm
   [<a href="/doc/html/rfc7567">RFC7567</a>].  Calculation of the marking probability involves the
   following steps on packet arrival:

   1.  update smoothed queue size q_avg as:

         q_avg = w*q + (1-w)*q_avg

   2.  calculate marking probability p as:

              / 0,                    if q &lt; q_lo
              |
              |        q_avg - q_lo
          p= &lt;  p_max*--------------, if q_lo &lt;= q &lt; q_hi
              |         q_hi - q_lo
              |
              \ p = 1,                if q &gt;= q_hi

   Here, q_lo and q_hi correspond to the low and high thresholds of
   queue occupancy.  The maximum marking probability is p_max.

   The ECN marking events will contribute to the calculation of an
   equivalent delay x_curr at the receiver.  No changes are required at
   the sender.

<span class="h3"><a class="selflink" id="appendix-A.3" href="#appendix-A.3">A.3</a>.  Random Early Marking with Virtual Queues</span>

   Advanced network nodes may support random early marking based on a
   token bucket algorithm originally designed for Pre-Congestion
   Notification (PCN) [<a href="/doc/html/rfc6660">RFC6660</a>].  The early congestion notification
   (ECN) bit in the IP header of packets is marked randomly.  The
   marking probability is calculated based on a token bucket algorithm
   originally designed for PCN [<a href="/doc/html/rfc6660">RFC6660</a>].  The target link utilization
   is set as 90%; the marking probability is designed to grow linearly
   with the token bucket size when it varies between 1/3 and 2/3 of the
   full token bucket limit.

   Calculation of the marking probability involves the following steps
   upon packet arrival:

   1.  meter packet against token bucket (r,b)

   2.  update token level b_tk

   3.  calculate the marking probability as:

               / 0,                     if b-b_tk &lt; b_lo
               |
               |          b-b_tk-b_lo
          p = &lt;  p_max* --------------, if b_lo &lt;= b-b_tk &lt; b_hi
               |           b_hi-b_lo
               |
               \ 1,                     if b-b_tk &gt;= b_hi

   Here, the token bucket lower and upper limits are denoted by b_lo and
   b_hi, respectively.  The parameter b indicates the size of the token
   bucket.  The parameter r is chosen to be below capacity, resulting in
   slight underutilization of the link.  The maximum marking probability
   is p_max.

   The ECN marking events will contribute to the calculation of an
   equivalent delay x_curr at the receiver.  No changes are required at
   the sender.  The virtual queuing mechanism from the PCN-based marking
   algorithm will lead to additional benefits such as zero standing
   queues.

Acknowledgments

   The authors would like to thank Randell Jesup, Luca De Cicco, Piers
   O&#x27;Hanlon, Ingemar Johansson, Stefan Holmer, Cesar Ilharco Magalhaes,
   Safiqul Islam, Michael Welzl, Mirja Kühlewind, Karen Elisabeth Egede
   Nielsen, Julius Flohr, Roland Bless, Andreas Smas, and Martin
   Stiemerling for their valuable review comments and helpful input to
   this specification.

Contributors

   The following individuals contributed to the implementation and
   evaluation of the proposed scheme and, therefore, helped to validate
   and substantially improve this specification.

   Paul E. Jones &lt;paulej@packetizer.com&gt; of Cisco Systems implemented an
   early version of the NADA congestion control scheme and helped with
   its lab-based testbed evaluations.

   Jiantao Fu &lt;jianfu@cisco.com&gt; of Cisco Systems helped with the
   implementation and extensive evaluation of NADA both in Mozilla web
   browsers and in earlier simulation-based evaluation efforts.

   Stefano D&#x27;Aronco &lt;stefano.daronco@geod.baug.ethz.ch&gt; of ETH Zurich
   (previously at Ecole Polytechnique Federale de Lausanne when
   contributing to this work) helped with the implementation and
   evaluation of an early version of NADA in [<a href="#ref-NS-3">NS-3</a>].

   Charles Ganzhorn &lt;charles.ganzhorn@gmail.com&gt; contributed to the
   testbed-based evaluation of NADA during an early stage of its
   development.

Authors&#x27; Addresses

   Xiaoqing Zhu
   Cisco Systems
   12515 Research Blvd., Building 4
   Austin, TX 78759
   United States of America

   Email: xiaoqzhu@cisco.com


   Rong Pan
   Intel Corporation
   2200 Mission College Blvd
   Santa Clara, CA 95054
   United States of America

   Email: rong.pan@intel.com


   Michael A. Ramalho
   AcousticComms Consulting
   6310 Watercrest Way Unit 203
   Lakewood Ranch, FL 34202-5211
   United States of America

   Phone: +1 732 832 9723
   Email: mar42@cornell.edu
   URI:   <a href="http://ramalho.webhop.info/">http://ramalho.webhop.info/</a>


   Sergio Mena
   Cisco Systems
   EPFL, Quartier de l&#x27;Innovation, Batiment E
   CH-1015 Ecublens
   Switzerland

   Email: semena@cisco.com
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

