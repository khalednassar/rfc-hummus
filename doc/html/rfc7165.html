<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc7165
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-jose-use-cases/">
  <meta name="description" content="Use Cases and Requirements for JSON Object Signing and Encryption (JOSE) (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgorange"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc7165.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc7165.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7165.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc7165/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc7165/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/jose/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-jose-use-cases@ietf.org?subject=draft-ietf-jose-use-cases" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-jose-use-cases-06.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-jose-use-cases-06.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-jose-use-cases-06.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-jose-use-cases-06">draft-ietf-jose-use-cases-06</a>                         Informational</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                         R. Barnes
Request for Comments: 7165                                       Mozilla
Category: Informational                                       April 2014
ISSN: 2070-1721


                     <span class="h1">Use Cases and Requirements for</span>
               <span class="h1">JSON Object Signing and Encryption (JOSE)</span>

Abstract

   Many Internet applications have a need for object-based security
   mechanisms in addition to security mechanisms at the network layer or
   transport layer.  For many years, the Cryptographic Message Syntax
   (CMS) has provided a binary secure object format based on ASN.1.
   Over time, binary object encodings such as ASN.1 have become less
   common than text-based encodings, such as the JavaScript Object
   Notation (JSON).  This document defines a set of use cases and
   requirements for a secure object format encoded using JSON, drawn
   from a variety of application security mechanisms currently in
   development.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="/doc/html/rfc5741#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7165">http://www.rfc-editor.org/info/rfc7165</a>.














<span class="grey">Barnes                        Informational                     [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Definitions . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Basic Requirements  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-4">4</a>.  Requirements on Application Protocols . . . . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-5">5</a>.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.1">5.1</a>.  Security Tokens . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.2">5.2</a>.  OAuth . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.3">5.3</a>.  OpenID Connect  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-5.4">5.4</a>.  XMPP  . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-5.5">5.5</a>.  ALTO  . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-5.6">5.6</a>.  Emergency Alerting  . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-5.7">5.7</a>.  Web Cryptography  . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-5.8">5.8</a>.  Constrained Devices . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
       <a href="#section-5.8.1">5.8.1</a>.  Example: MAC Based on ECDH-Derived Key  . . . . . . .  <a href="#page-16">16</a>
       <a href="#section-5.8.2">5.8.2</a>.  Object Security for CoAP  . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#section-6">6</a>.  Requirements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-6.1">6.1</a>.  Functional Requirements . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-6.2">6.2</a>.  Security Requirements . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-6.3">6.3</a>.  Desiderata  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#section-7">7</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#section-8">8</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-8.1">8.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-8.2">8.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#appendix-A">Appendix A</a>.  Acknowledgements . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>










<span class="grey">Barnes                        Informational                     [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   Internet applications rest on the layered architecture of the
   Internet and take advantage of security mechanisms at all layers.
   Many applications rely primarily on channel-based security
   technologies such as IPsec and Transport Layer Security (TLS), which
   create a secure channel at the IP layer or transport layer over which
   application data can flow [<a href="/doc/html/rfc4301" title="&quot;Security Architecture for the Internet Protocol&quot;">RFC4301</a>] [<a href="/doc/html/rfc5246" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;">RFC5246</a>].  These mechanisms,
   however, cannot provide end-to-end security in some cases.  For
   example, in protocols with application-layer intermediaries, channel-
   based security protocols would protect messages from attackers
   between intermediaries, but not from the intermediaries themselves.
   These cases require object-based security technologies, which embed
   application data within a secure object that can be safely handled by
   untrusted entities.

   The most well-known example of such a protocol today is the use of
   Secure/Multipurpose Internet Mail Extensions (S/MIME) protections
   within the email system [<a href="/doc/html/rfc5751" title="&quot;Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification&quot;">RFC5751</a>] [<a href="/doc/html/rfc5322" title="&quot;Internet Message Format&quot;">RFC5322</a>].  An email message
   typically passes through a series of intermediate Mail Transfer
   Agents (MTAs) en route to its destination.  While these MTAs often
   apply channel-based security protections to their interactions (e.g.,
   STARTTLS [<a href="/doc/html/rfc3207" title="&quot;SMTP Service Extension for Secure SMTP over Transport Layer Security&quot;">RFC3207</a>]), these protections do not prevent the MTAs from
   interfering with the message.  In order to provide end-to-end
   security protections in the presence of untrusted MTAs, mail users
   can use S/MIME to embed message bodies in a secure object format that
   can provide confidentiality, integrity, and data origin
   authentication.

   S/MIME is based on the Cryptographic Message Syntax (CMS) for secure
   objects [<a href="/doc/html/rfc5652" title="&quot;Cryptographic Message Syntax (CMS)&quot;">RFC5652</a>].  CMS is defined using Abstract Syntax Notation 1
   (ASN.1) and typically encoded using the ASN.1 Distinguished Encoding
   Rules (DER), which define a binary encoding of the protected message
   and associated parameters [<a href="#ref-ITU.X690.2002">ITU.X690.2002</a>].  In recent years, usage of
   ASN.1 has decreased (along with other binary encodings for general
   objects), while more applications have come to rely on text-based
   formats such as the Extensible Markup Language (XML) [<a href="#ref-W3C.REC-xml">W3C.REC-xml</a>] or
   the JavaScript Object Notation (JSON) [<a href="/doc/html/rfc7159" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC7159</a>].

   Many current applications thus have much more robust support for
   processing objects in these text-based formats than ASN.1 objects;
   indeed, many lack the ability to process ASN.1 objects at all.  To
   simplify the addition of object-based security features to these
   applications, the IETF JSON Object Signing and Encryption (JOSE)
   working group has been chartered to develop a secure object format
   based on JSON.  While the basic requirements for this object format
   are straightforward -- namely, confidentiality and integrity
   mechanisms encoded in JSON -- discussions in the working group



<span class="grey">Barnes                        Informational                     [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   indicated that different applications hoping to use the formats
   defined by JOSE have different requirements.  This document
   summarizes the use cases for JOSE envisioned by those potential
   applications and the resulting requirements for security mechanisms
   and object encodings.

   Some systems that use XML have specified the use of XML-based
   security mechanisms for object security, namely XML Digital
   Signatures and XML Encryption [<a href="#ref-W3C.xmldsig-core">W3C.xmldsig-core</a>] [<a href="#ref-W3C.xmlenc-core">W3C.xmlenc-core</a>].
   These mechanisms are used by several security token systems (e.g.,
   Security Assertion Markup Language (SAML) [<a href="#ref-OASIS.saml-core-2.0-os">OASIS.saml-core-2.0-os</a>],
   Web Services Federation [<a href="#ref-WS-Federation">WS-Federation</a>]), and the Common Alerting
   Protocol (CAP) emergency alerting format [<a href="#ref-CAP" title="&quot;Common Alerting Protocol, v1.1&quot;">CAP</a>].  In practice,
   however, XML-based secure object formats introduce similar levels of
   complexity to ASN.1 (e.g., due to the need for XML canonicalization),
   so developers that lack the tools or motivation to handle ASN.1
   aren&#x27;t likely to use XML security either.  This situation motivates
   the creation of a JSON-based secure object format that is simple
   enough to implement and deploy that it can be easily adopted by
   developers with minimal effort and tools.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Definitions</span>

   This document makes extensive use of standard security terminology
   [<a href="/doc/html/rfc4949" title="&quot;Internet Security Glossary, Version 2&quot;">RFC4949</a>].  In addition, because the use cases for JOSE and CMS are
   similar, we will sometimes make analogies to some CMS concepts
   [<a href="/doc/html/rfc5652" title="&quot;Cryptographic Message Syntax (CMS)&quot;">RFC5652</a>].

   The JOSE working group charter calls for the group to define three
   basic JSON object formats:

   1.  Integrity-protected object format

   2.  Confidentiality-protected object format

   3.  A format for expressing keys

   In this document, we will refer to these as the &quot;signed object
   format&quot;, the &quot;encrypted object format&quot;, and the &quot;key format&quot;,
   respectively.  The JOSE working group items intended to describe
   these formats are JSON Web Signature [<a href="#ref-JWS" title="&quot;JSON Web Signature (JWS)&quot;">JWS</a>], JSON Web Encryption
   [<a href="#ref-JWE" title="&quot;JSON Web Encryption (JWE)&quot;">JWE</a>], and JSON Web Key [<a href="#ref-JWK" title="&quot;JSON Web Key (JWK)&quot;">JWK</a>], respectively.  Algorithms and
   algorithm identifiers used by JWS, JWE, and JWK are defined in JSON
   Web Algorithms [<a href="#ref-JWA" title="&quot;JSON Web Algorithms (JWA)&quot;">JWA</a>].

   In general, where there is no need to distinguish between asymmetric
   and symmetric operations, we will use the terms &quot;signing&quot;,
   &quot;signature&quot;, etc., to denote both true digital signatures involving



<span class="grey">Barnes                        Informational                     [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   asymmetric cryptography as well as Message Authentication Codes
   (MACs) using symmetric keys.

   In the lifespan of a secure object, there are two basic roles, an
   entity that creates the object (e.g., encrypting or signing a
   payload) and an entity that uses the object (decrypting and
   verifying).  We will refer to these roles as &quot;sender&quot; and
   &quot;recipient&quot;, respectively.  Note that while some requirements and use
   cases may refer to these as single entities, each object may have
   multiple entities in each role.  For example, a message may be signed
   by multiple senders or decrypted by multiple recipients.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Basic Requirements</span>

   For the encrypted and signed object formats, the necessary
   protections will be created using appropriate cryptographic
   mechanisms: symmetric or asymmetric encryption for confidentiality
   and MACs or digital signatures for integrity protection.  In both
   cases, it is necessary for the JOSE format to support both symmetric
   and asymmetric operations.

   o  The JOSE encrypted object format must support object encryption in
      the case where the sender and receiver share a symmetric key.

   o  The JOSE encrypted object format must support object encryption in
      the case where the sender has only a public key for the receiver.

   o  The JOSE signed object format must support integrity protection
      using MACs, for the case where the sender and receiver share only
      a symmetric key.

   o  The JOSE signed object format must support integrity protection
      using digital signatures, for the case where the receiver has only
      a public key for the sender.

   In some applications, the key used to process a JOSE object is
   indicated by application context, instead of directly in the JOSE
   object.  However, in order to avoid confusion, endpoints that lack
   the necessary context need to be able to recognize this and fail
   cleanly.  Other than keys, JOSE objects do not support pre-
   negotiation; all cryptographic parameters must be expressed directly
   in the JOSE object.

   o  The JOSE signed and encrypted object formats must define the
      process by which an implementation recognizes whether it has the
      key required to process a given object, whether the key is
      specified by the object or by some out-of-band mechanism.




<span class="grey">Barnes                        Informational                     [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   o  Each algorithm used for JOSE must define which parameters are
      required to be present in a JOSE object using that algorithm.

   In cases where two entities are going to be exchanging several JOSE
   objects, it might be helpful to pre-negotiate some parameters so that
   they do not have to be signaled in every JOSE object.  However, so as
   not to confuse endpoints that do not support pre-negotiation, it is
   useful to signal when pre-negotiated parameters are in use in those
   cases.

   o  It should be possible to extend the base JOSE signed and encrypted
      object formats to indicate that pre-negotiated parameters are to
      be used to process the object.  This extension should also provide
      a means of indicating which parameters are to be used.

   The purpose of the key format is to provide the recipient with
   sufficient information to use the encoded key to process
   cryptographic messages.  Thus, it is sometimes necessary to include
   additional parameters along with the bare key.

   o  The JOSE key format must enable inclusion of all algorithm
      parameters necessary to use the encoded key, including an
      identifier for the algorithm with which the key is used as well as
      any additional parameters required by the algorithm (e.g.,
      elliptic curve parameters).

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Requirements on Application Protocols</span>

   The JOSE secure object formats describe how cryptographic processing
   is done on secured content, ensuring that the recipient of an object
   is able to properly decrypt an encrypted object or verify a
   signature.  In order to make use of JOSE, however, applications will
   need to specify several aspects of how JOSE is to be used:

   o  What application content is to be protected

   o  Which cryptographic algorithms are to be used

   o  How application protocol entities establish keys

   o  Whether keys are to be explicitly indicated in JOSE objects or
      associated by application context

   o  Which serialization(s) of JOSE objects are to be used







<span class="grey">Barnes                        Informational                     [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Use Cases</span>

   Several IETF working groups developing application-layer protocols
   have expressed a desire to use the JOSE data formats in their designs
   for end-to-end security features.  In this section, we summarize the
   use cases proposed by these groups and discuss the requirements that
   they imply for the JOSE object formats.

<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a>.  Security Tokens</span>

   Security tokens are a common use case for object-based security, for
   example, SAML assertions [<a href="#ref-OASIS.saml-core-2.0-os">OASIS.saml-core-2.0-os</a>].  Security tokens
   are used to convey information about a subject entity (&quot;claims&quot; or
   &quot;assertions&quot;) from an issuer to a recipient.  The security features
   of a token format enable the recipient to verify that the claims came
   from the issuer and, if the object is confidentiality protected, that
   they were not visible to other parties.

   Security tokens are used in federation protocols such as SAML 2.0
   [<a href="#ref-OASIS.saml-core-2.0-os">OASIS.saml-core-2.0-os</a>], WS-Federation [<a href="#ref-WS-Federation">WS-Federation</a>], Mozilla
   Persona [<a href="#ref-Persona" title="&quot;Mozilla Persona&quot;">Persona</a>], and OpenID Connect [<a href="#ref-OpenID.Core">OpenID.Core</a>], as well as in
   resource authorization protocols such as OAuth 2.0 [<a href="/doc/html/rfc6749" title="&quot;The OAuth 2.0 Authorization Framework&quot;">RFC6749</a>],
   including for OAuth bearer tokens [<a href="/doc/html/rfc6750" title="&quot;The OAuth 2.0 Authorization Framework: Bearer Token Usage&quot;">RFC6750</a>].  In some cases, security
   tokens are used for client authentication and for access control
   [<a href="#ref-JWT-BEARER">JWT-BEARER</a>] [<a href="#ref-SAML2" title="&quot;SAML 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants&quot;">SAML2</a>].

   JSON Web Token [<a href="#ref-JWT" title="&quot;JSON Web Token (JWT)&quot;">JWT</a>] is a security token format based on JSON and
   JOSE.  It is used with Mozilla Persona, OpenID Connect, and OAuth.
   Because JWTs are often used in contexts with limited space (e.g.,
   HTTP query parameters), it is a core requirement for JWTs, and thus
   JOSE, to have a compact, URL-safe representation.

<span class="h3"><a class="selflink" id="section-5.2" href="#section-5.2">5.2</a>.  OAuth</span>

   The OAuth protocol defines a mechanism for distributing and using
   authorization tokens using HTTP [<a href="/doc/html/rfc6749" title="&quot;The OAuth 2.0 Authorization Framework&quot;">RFC6749</a>].  A client that wishes to
   access a protected resource requests authorization from the resource
   owner.  If the resource owner allows this access, he directs an
   authorization server to issue an access token to the client.  When
   the client wishes to access the protected resource, he presents the
   token to the relevant resource server, which verifies the validity of
   the token before providing access to the protected resource.









<span class="grey">Barnes                        Informational                     [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


                 +---------------+          +---------------+
                 |               |          |               |
                 |   Resource    |&lt;........&gt;| Authorization |
                 |    Server     |          |     Server    |
                 |               |          |               |
                 +---------------+          +---------------+
                              ^                |
                              |                |
                              |                |
                              |                |
                              |                |
                 +------------|--+          +--|------------+
                 |            +----------------+            |
                 |               |          |   Resource    |
                 |     Client    |          |     Owner     |
                 |               |          |               |
                 +---------------+          +---------------+

                        Figure 1: The OAuth Process

   In effect, this process moves the token from the authorization server
   (as a sender of the object) to the resource server (recipient) via
   the client as well as the resource owner (the latter because of the
   HTTP mechanics underlying the protocol).  As with email, we have a
   case where an application object is transported via untrusted
   intermediaries.

   This application has two essential security requirements: integrity
   and data origin authentication.  Integrity protection is required so
   that the resource owner and the client cannot modify the permission
   encoded in the token.  Although the resource owner is ultimately the
   entity that grants authorization, it is not trusted to modify the
   authorization token, since this could, for example, grant access to
   resources not owned by the resource owner.

   Data origin authentication is required so that the resource server
   can verify that the token was issued by a trusted authorization
   server.

   Confidentiality protection may also be needed if the authorization
   server is concerned about the visibility of permissions information
   to the resource owner or client.  For example, permissions related to
   social networking might be considered private information.  Note,
   however, that OAuth already requires that the underlying HTTP
   transactions be protected by TLS, so tokens are already
   confidentiality protected from entities other than the resource owner
   and client.




<span class="grey">Barnes                        Informational                     [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   The confidentiality and integrity needs are met by the basic
   requirements for signed and encrypted object formats, whether the
   signing and encryption are provided using asymmetric or symmetric
   cryptography.  The choice of which mechanism is applied will depend
   on the relationship between the two servers, namely whether they
   share a symmetric key or only public keys.

   Authentication requirements will also depend on deployment
   characteristics.  Where there is a relatively strong binding between
   the resource server and the authorization server, it may suffice for
   the authorization server issuing a token to be identified by the key
   used to sign the token.  This requires that the protocol carry either
   the public key of the authorization server or an identifier for the
   public or symmetric key.  In OAuth, the &quot;client_id&quot; parameter
   (external to the token) identifies the key to be used.

   There may also be more advanced cases where the authorization
   server&#x27;s key is not known in advance to the resource server.  This
   may happen, for instance, if an entity instantiated a collection of
   authorization servers (say for load balancing), each of which has an
   independent key pair.  In these cases, it may be necessary to also
   include a certificate or certificate chain for the authorization
   server, so that the resource server can verify that the authorization
   server is an entity that it trusts.

   The HTTP transport for OAuth imposes a particular constraint on the
   encoding.  In the OAuth protocol, tokens frequently need to be passed
   as query parameters in HTTP URIs [<a href="/doc/html/rfc2616" title="&quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;">RFC2616</a>] after having been
   base64url encoded [<a href="/doc/html/rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>].  While there is no specified limit on
   the length of URIs (and thus of query parameters), in practice, URIs
   of more than 2,048 characters are rejected by some user agents.  So
   this use case requires that JOSE objects be sufficiently small, even
   after being signed and possibly encrypted.

<span class="h3"><a class="selflink" id="section-5.3" href="#section-5.3">5.3</a>.  OpenID Connect</span>

   The OpenID Connect protocol [<a href="#ref-OpenID.Core">OpenID.Core</a>] is a simple, REST/JSON-
   based identity federation protocol layered on OAuth 2.0.  It uses the
   JWT and JOSE formats both to represent security tokens and to provide
   security for other protocol messages (performing signing and
   optionally encryption).  OpenID Connect negotiates the algorithms to
   be used and distributes information about the keys to be used using
   protocol elements that are not part of the JWT and JOSE header
   parameters.

   In the OpenID Connect context, it is possible for the recipient of a
   JWT to accept it without integrity protection in the JWT itself.  In
   such cases, the recipient chooses to rely on transport security



<span class="grey">Barnes                        Informational                     [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   rather than object security.  For example, if the payload is
   delivered over a TLS-protected channel, the recipient may regard the
   protections provided by TLS as sufficient, so JOSE protection would
   not be required.

   However, even in this case, it is desirable to associate some
   metadata with the JWT payload (claim set), such as the content type,
   or other application-specific metadata.  In a signed or encrypted
   object, these metadata values could be carried in a header with other
   metadata required for signing or encryption.  It would thus simplify
   the design of OpenID Connect if there could be a JOSE object format
   that does not apply cryptographic protections to its payload, but
   allows a header to be attached to the payload in the same way as a
   signed or encrypted object.

<span class="h3"><a class="selflink" id="section-5.4" href="#section-5.4">5.4</a>.  XMPP</span>

   The Extensible Messaging and Presence Protocol (XMPP) routes messages
   from one end client to another by way of XMPP servers [<a href="/doc/html/rfc6120" title="&quot;Extensible Messaging and Presence Protocol (XMPP): Core&quot;">RFC6120</a>].
   There are typically two servers involved in delivering any given
   message: The first client (Alice) sends a message for another client
   (Bob) to her server (A).  Server A uses Bob&#x27;s identity and the DNS to
   locate the server for Bob&#x27;s domain (B) and then delivers the message
   to that server.  Server B then routes the message to Bob.

            +-------+   +----------+   +----------+   +-----+
            | Alice |--&gt;| Server A |--&gt;| Server B |--&gt;| Bob |
            +-------+   +----------+   +----------+   +-----+

                   Figure 2: Delivering an XMPP Message

   The untrusted-intermediary problems are especially acute for XMPP
   because in many current deployments, the holder of an XMPP domain
   outsources the operation of the domain&#x27;s servers to a different
   entity.  In this environment, there is a clear risk of exposing the
   domain holder&#x27;s private information to the domain operator.  XMPP
   already has a defined mechanism for end-to-end security using S/MIME,
   but it has failed to gain widespread deployment [<a href="/doc/html/rfc3923" title="&quot;End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP)&quot;">RFC3923</a>], in part
   because of key management challenges and in part because of the
   difficulty of processing S/MIME objects.

   The XMPP working group is in the process of developing a new
   end-to-end encryption system with an encoding based on JOSE and a
   clearer key management system [<a href="#ref-XMPP-E2E" title="&quot;End-to-End Object Encryption and Signatures for the Extensible Messaging and Presence Protocol (XMPP)&quot;">XMPP-E2E</a>].  The process of sending an
   encrypted message in this system involves two steps: First, the
   sender generates a symmetric Session Master Key (SMK), encrypts the
   message content (including a per-message Content Master Key), and
   sends the encrypted message to the desired set of recipients.



<span class="grey">Barnes                        Informational                    [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   Second, each recipient &quot;dials back&quot; to the sender, providing his
   public key.  The sender then responds with the relevant SMK, wrapped
   with the recipient&#x27;s public key.

            +-------+   +----------+   +----------+   +-----+
            | Alice |&lt;-&gt;| Server A |&lt;-&gt;| Server B |&lt;-&gt;| Bob |
            +-------+   +----------+   +----------+   +-----+
                |             |              |           |
                |------------Encrypted message----------&gt;|
                |             |              |           |
                |&lt;---------------Public key--------------|
                |             |              |           |
                |---------------Wrapped SMK-------------&gt;|
                |             |              |           |

                Figure 3: Delivering a Secure XMPP Message

   The main thing that this system requires from the JOSE formats is
   confidentiality protection via content encryption, plus an integrity
   check via a MAC derived from the same symmetric key.  The separation
   of the key exchange from the transmission of the encrypted content,
   however, requires that the JOSE encrypted object format allow wrapped
   symmetric keys to be carried separately from the encrypted payload.
   In addition, the encrypted object will need to have a tag for the key
   that was used to encrypt the content, so that the recipient (Bob) can
   present the tag to the sender (Alice) when requesting the wrapped
   key.

   Another important feature of XMPP is that it allows for the
   simultaneous delivery of a message to multiple recipients.  In the
   diagrams above, Server A could deliver the message not only to Server
   B (for Bob) but also to Servers C, D, E, etc., for other users.  In
   such cases, to avoid the multiple &quot;dial back&quot; transactions implied by
   the above mechanism, XMPP systems will likely reuse a given SMK for
   multiple individual messages, refreshing the SMK on a periodic and/or
   event-driven basis (e.g., when the recipient&#x27;s presence changes).
   They might also cache public keys for end recipients, so that wrapped
   keys can be sent along with content on future messages.  This implies
   that the JOSE encrypted object format must support the provision of
   multiple versions of the same wrapped SMK (much as a CMS
   EnvelopedData structure can include multiple RecipientInfo
   structures).

   In the current draft of the XMPP end-to-end security system, each
   party is authenticated by virtue of the other party&#x27;s trust in the
   XMPP message routing system.  The sender is authenticated to the
   receiver because he can receive messages for the identifier &quot;Alice&quot;
   (in particular, the request for wrapped keys) and can originate



<span class="grey">Barnes                        Informational                    [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   messages for that identifier (the wrapped key).  Likewise, the
   receiver is authenticated to the sender because he received the
   original encrypted message and originated the request for a wrapped
   key.  So, the authentication here requires not only that XMPP routing
   be done properly, but also that TLS be used on every hop.  Moreover,
   it requires that the TLS channels have strong authentication, since a
   man in the middle on any of the three hops can masquerade as Bob and
   obtain the key material for an encrypted message.

   Because this authentication is quite weak (depending on the use of
   TLS on three hops) and unverifiable by the endpoints, it is possible
   that the XMPP working group will integrate some sort of credentials
   for end recipients, in which case there would need to be a way to
   associate these credentials with JOSE objects.

   Finally, it&#x27;s worth noting that XMPP is based on XML, not JSON.  So
   by using JOSE, XMPP will be carrying JSON objects within XML.  It is
   thus a desirable property for JOSE objects to be encoded in such a
   way as to be safe for inclusion in XML.  Otherwise, an explicit CDATA
   indication must be given to the parser to indicate that it is not to
   be parsed as XML.  One way to meet this requirement would be to apply
   base64url encoding, but for XMPP messages of medium-to-large size,
   this could impose a fair degree of overhead.

<span class="h3"><a class="selflink" id="section-5.5" href="#section-5.5">5.5</a>.  ALTO</span>

   Application-Layer Traffic Optimization (ALTO) is a system for
   distributing network topology information to end devices, so that
   those devices can modify their behavior to have a lower impact on the
   network [<a href="/doc/html/rfc6708" title="&quot;Application-Layer Traffic Optimization (ALTO) Requirements&quot;">RFC6708</a>].  The ALTO protocol distributes topology
   information in the form of JSON objects carried in HTTP [<a href="/doc/html/rfc2616" title="&quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;">RFC2616</a>]
   [<a href="#ref-ALTO" title="&quot;ALTO Protocol&quot;">ALTO</a>].  The basic version of ALTO is simply a client-server
   protocol, so simple use of HTTPS suffices for this case [<a href="/doc/html/rfc2818" title="&quot;HTTP Over TLS&quot;">RFC2818</a>].
   However, there is beginning to be some discussion of use cases for
   ALTO in which these JSON objects will be distributed through a
   collection of intermediate servers before reaching the client, while
   still preserving the ability of the client to authenticate the
   original source of the object.  Even the base ALTO protocol notes
   that &quot;ALTO Clients obtaining ALTO information through redistribution
   must be able to validate the received ALTO information&quot; to ensure
   that it was generated by an appropriate ALTO server.

   In this case, the security requirements are straightforward.  JOSE
   objects carrying ALTO payloads will need to bear digital signatures
   from the originating servers, which will be bound to certificates
   attesting to the identities of the servers.  There is no requirement
   for confidentiality in this case, since ALTO information is generally
   public.



<span class="grey">Barnes                        Informational                    [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   The more interesting questions are encoding questions.  ALTO objects
   are likely to be much larger than payloads in the two cases above,
   with sizes of up to several megabytes.  Processing of such large
   objects can be done more quickly if it can be done in a single pass,
   which may be possible if JOSE objects require specific orderings of
   fields within the JSON structure.

   In addition, because ALTO objects are also encoded as JSON, they are
   already safe for inclusion in a JOSE object.  Signed JOSE objects
   will likely carry the signed data in a string alongside the
   signature.  JSON objects have the property that they can be safely
   encoded in JSON strings.  All they require is that unnecessary white
   space be removed, a much simpler transformation than, say, base64url
   encoding.  This raises the question of whether it might be possible
   to optimize the JOSE encoding for certain &quot;JSON-safe&quot; cases.

   Finally, it may be desirable for ALTO to have a &quot;detached signature&quot;
   mechanism, that is, a way to encode signature information separate
   from the protected content.  This would allow the ALTO protocol to
   include the signature in an HTTPS header, with the signed content as
   the HTTPS entity body.

<span class="h3"><a class="selflink" id="section-5.6" href="#section-5.6">5.6</a>.  Emergency Alerting</span>

   Emergency alerting is an emerging use case for IP networks
   [<a href="#ref-ALERT-REQ">ALERT-REQ</a>].  Alerting systems allow authorities to warn users of
   impending danger by sending alert messages to connected devices.  For
   example, in the event of a hurricane or tornado, alerts might be sent
   to all devices in the path of the storm.

   The most critical security requirement for alerting systems is that
   it must not be possible for an attacker to send false alerts to
   devices.  Such a capability would potentially allow an attacker to
   create wide-spread panic.  In practice, alert systems prevent these
   attacks both by controls on sending messages at points where alerts
   are originated, and by having recipients of alerts verify that the
   alert was sent by an authorized source.  The former type of control
   is implemented with local security on hosts from which alerts can be
   originated.  The latter type is implemented by digital signatures on
   alert messages (using channel-based or object-based mechanisms).
   With an object-based mechanism, the signature value is encoded in a
   secure object.  With a channel-based mechanism, the alert is &quot;signed&quot;
   by virtue of being sent over an authenticated, integrity-protected
   channel.







<span class="grey">Barnes                        Informational                    [Page 13]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-14" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   Alerts typically reach end recipients via a series of intermediaries.
   For example, while a national weather service might originate a
   hurricane alert, it might first be delivered to a national gateway
   and then to network operators, who broadcast it to end subscribers.

           +------------+    +------------+    +------------+
           | Originator |    | Originator |    | Originator |
           +------------+    +------------+    +------------+
                 |                 .                 .
                 +-----------------+..................
                                   |
                                   V
                              +---------+
                              | Gateway |
                              +---------+
                                   |
                      +------------+------------+
                      |                         |
                      V                         V
                 +---------+               +---------+
                 | Network |               | Network |
                 +---------+               +---------+
                      |                         |
               +------+-----+            +------+-----+
               |            |            |            |
               V            V            V            V
           +--------+   +--------+   +--------+   +--------+
           | Device |   | Device |   | Device |   | Device |
           +--------+   +--------+   +--------+   +--------+

                  Figure 4: Delivering an Emergency Alert

   In order to verify alert signatures, recipients must be provisioned
   with the proper public keys for trusted alert authorities.  This
   trust may be &quot;piece-wise&quot; along the path the alert takes.  For
   example, the alert relays operated by networks might have a full set
   of certificates for all alert originators, while end devices may only
   trust their local alert relay.  Or, devices might require that a
   device be signed by an authorized originator and by its local
   network&#x27;s relay.

   This scenario creates a need for multiple signatures on alert
   documents, so that an alert can bear signatures from any or all of
   the entities that processed it along the path.  In order to minimize
   complexity, these signatures should be &quot;modular&quot; in the sense that a
   new signature can be added without a need to alter or recompute
   previous signatures.




<span class="grey">Barnes                        Informational                    [Page 14]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-15" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


<span class="h3"><a class="selflink" id="section-5.7" href="#section-5.7">5.7</a>.  Web Cryptography</span>

   The W3C Web Cryptography API defines a standard cryptographic API for
   the Web [<a href="#ref-WebCrypto">WebCrypto</a>].  If a browser exposes this API, then JavaScript
   provided as part of a Web page can ask the browser to perform
   cryptographic operations, such as digest, MAC, encryption, or digital
   signing.

   One of the key reasons to have the browser perform cryptographic
   operations is to avoid allowing JavaScript code to access the keying
   material used for these operations.  For example, this separation
   would prevent code injected through a cross-site scripting (XSS)
   attack from reading and exfiltrating keys stored within a browser.
   While the malicious code could still use the key while running in the
   browser, this vulnerability can only be exercised while the malicious
   code is active in a user&#x27;s browser.

   However, the Web Cryptography API also provides a key export
   functionality, which can allow JavaScript to extract a key from the
   API in wrapped form.  For example, JavaScript code might provide a
   public key for which the corresponding private key is held by another
   device.  The wrapped key provided by the API could then be used to
   safely transport the key to the new device.  While this could
   potentially allow malicious code to export a key, the need for an
   explicit export operation provides a control point, allowing for user
   notification or consent verification.

   The Web Cryptography API also allows browsers to impose limitations
   on the usage of the keys it handles.  For example, a symmetric key
   might be marked as usable only for encryption, and not for MAC.  When
   a key is exported in wrapped form, these attributes should be carried
   along with it.

   The Web Cryptography API thus requires formats to express several
   forms of keys.  Obviously, the public key from an asymmetric key pair
   can be freely imported to and exported from the browser, so there
   needs to be a format for public keys.  There is also a need for a
   format to express private keys and symmetric keys.  For non-public
   keys, the primary need is for a wrapped form, where the
   confidentiality and integrity of the key is assured
   cryptographically; these protections should also apply to any
   attributes of the key.  It may also be useful to define a direct,
   unwrapped format for use within a security boundary.








<span class="grey">Barnes                        Informational                    [Page 15]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-16" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


<span class="h3"><a class="selflink" id="section-5.8" href="#section-5.8">5.8</a>.  Constrained Devices</span>

   This section describes use cases for constrained devices as defined
   in [<a href="#ref-CONSTRAINED">CONSTRAINED</a>].  Typical issues with this type of device are
   limited memory, limited power supply, low processing power, and
   severe message size limitations for the communication protocols.

<span class="h4"><a class="selflink" id="section-5.8.1" href="#section-5.8.1">5.8.1</a>.  Example: MAC Based on ECDH-Derived Key</span>

   Suppose a small, low power device maker has decided on using the
   output of the JOSE working group as their encryption and
   authentication framework.  The device maker has a limited budget for
   both gates and power.  For this reason there are a number of short
   cuts and design decisions that have been made in order to minimize
   these needs.

   The design team has determined that the use of MACs is going to be
   sufficient to provide the necessary authentication.  However,
   although a MAC is going to be used, they do not want to use a single
   long-term shared secret.  Instead, they have adopted the following
   proposal for computing a shared secret that can be validated:

   o  An Elliptic-Curve Diffie-Hellman (ECDH) key pair is generated for
      the device at the time of manufacturing.  (Or, as part of the
      configuration process during installation.)

   o  An ECDH public key for the controller is configured at the time of
      configuration.

   o  The configuration system performs the ECDH computation and
      configures the device with the resulting shared secret.  This
      process eliminates the need for the device to be able to perform
      the required ECDH processing.  The security requirements on
      protecting this computed shared secret are the same as the
      requirements on protecting the private ECDH key.

   o  A counter and an increment value are configured onto the device.

   o  When a message is to be sent by the device, the counter is
      incremented and a new MAC key is computed from the ECDH secret and
      the counter value.  A custom Key Derivation Function (KDF) based
      on AES-CBC is used to derive the required MAC key.  The MAC key is
      then used to compute the MAC value for the message.








<span class="grey">Barnes                        Informational                    [Page 16]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-17" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   In a similar manner, the KDF function can be used to compute an
   Authenticated Encryption with Associated Data (AEAD) algorithm key
   when the system needs to provide confidentiality for the message.
   The controller, being a larger device, will perform the ECDH step and
   use a random number generator to generate the sender nonce value.

<span class="h4"><a class="selflink" id="section-5.8.2" href="#section-5.8.2">5.8.2</a>.  Object Security for CoAP</span>

   This use case deals with constrained devices of class C0/C1 (see
   [<a href="#ref-CONSTRAINED">CONSTRAINED</a>]).  These devices communicate using RESTful requests and
   responses transferred using the Constrained Application Protocol
   [<a href="#ref-CoAP" title="&quot;Constrained Application Protocol (CoAP)&quot;">CoAP</a>].  To simplify matters, all communication is assumed to be
   unicast; i.e., these security measures don&#x27;t cover multicast or
   broadcast.

   In this type of setting, it may be too costly to use session-based
   security (e.g., to run a 4-pass authentication protocol) since
   receiving and in particular sending consumes a lot of power,
   especially for wireless devices.  Therefore, to just secure the CoAP
   payload by replacing a plaintext payload of a request or response
   with a JWE object is an important alternative solution, which allows
   a trade-off between protection (the CoAP headers are not protected)
   and performance.

   In a simple setting, consider the payload of a CoAP GET response from
   a sensor type device.  The information in a sensor reading may be
   privacy or business sensitive and needs both integrity protection and
   encryption.

   However, some sensor readings are very short, say, a few bytes, and
   in this case, default encryption and integrity protection algorithms
   (such as 128-bit AES-CBC with HMAC_SHA256) may cause a dramatic
   expansion of the payload, even disregarding JWE headers.

   Also, the value of certain sensor readings may decline rapidly, e.g.,
   traffic or environmental measurements, so it must be possible to
   reduce the security overhead.

   This leads to the following requirements that could be covered by
   specific JWE/JWS profiles:

   o  The size of the secure object shall be as small as possible.
      Receiving an object may cost orders of magnitude more in terms of
      power than performing, say, public key cryptography on the object,
      in particular in a wireless setting.






<span class="grey">Barnes                        Informational                    [Page 17]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-18" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   o  Integrity protection: The object shall be able to support
      integrity protection, i.e., have a field containing a digital
      signature, both public key signatures and keyed MACs shall be
      supported.

   o  Encryption: The object shall be able to support encryption as an
      optional addition to integrity protection.  It shall be possible
      to exclude certain fields from encryption, which are needed before
      verifying integrity or decrypting the object.

   o  Cipher suites: It should be possible to support a variety of
      cipher suites to support the constrained devices&#x27; use cases.  For
      example:

      *  Block ciphers with block sizes of, e.g., 96 bits, in addition
         to the standard 128 bits.

      *  Modes of operation for block ciphers that do not expand the
         message size to a block boundary, such as AES-GCM.

      *  Cipher suites that support combined encryption and MAC
         calculation (i.e., AEAD modes for block ciphers).

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Requirements</span>

   This section summarizes the requirements from the above use cases and
   lists further requirements not directly derived from the above use
   cases.  There are also some constraints that are not hard
   requirements but that are still desirable properties for the JOSE
   system to have.

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Functional Requirements</span>

   F1 Define formats for secure objects that provide the following
      security properties:

      *  Digital signature (integrity/authentication under an asymmetric
         key pair)

      *  Message authentication (integrity/authentication under a
         symmetric key)

      *  Authenticated encryption

   F2 Define a format for public keys and private keys for asymmetric
      cryptographic algorithms, with associated attributes, including a
      wrapped form for private keys.




<span class="grey">Barnes                        Informational                    [Page 18]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-19" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   F3 Define a format for symmetric keys with associated attributes,
      allowing for both wrapped and unwrapped keys.

   F4 Define a JSON serialization for each of the above objects.  An
      object in this encoding must be valid according to the JSON ABNF
      syntax [<a href="/doc/html/rfc7159" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC7159</a>].

   F5 Define a compact, URL-safe text serialization for the encrypted
      and signed object formats.

   F6 Allow for attributes associated to wrapped keys to be bound to
      them cryptographically.

   F7 Allow for wrapped keys to be separated from a secure object that
      uses a symmetric key.  In such cases, cryptographic components of
      the secure object other than the wrapped key (e.g., ciphertext,
      MAC values) must be independent of the wrapped form of the key.
      For example, if an encrypted object is prepared for multiple
      recipients, then only the wrapped key may vary, not the
      ciphertext.

   F8 Do not impose more overhead than is required to meet the
      requirements in this document, especially when a large amount of
      application content is being protected.

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  Security Requirements</span>

   S1 Provide mechanisms to avoid repeated use of the same symmetric key
      for encryption or MAC computation.  Instead, long-lived keys
      should be used only for key wrapping, not for direct encryption/
      MAC.  It should be possible to use any of the key management
      techniques provided in CMS [<a href="/doc/html/rfc5652" title="&quot;Cryptographic Message Syntax (CMS)&quot;">RFC5652</a>]:

      *  Key transport (wrapping for a public key)

      *  Key encipherment (wrapping for a symmetric key)

      *  Key agreement (wrapping for a Diffie-Hellman (DH) public key)

      *  Password-based encryption (wrapping under a key derived from a
         password)

   S2 Where long-lived symmetric keys are used directly for
      cryptographic operations (i.e., where requirement S1 is not met),
      provide deployment guidance on key management practices, such as
      the need to limit key lifetimes.





<span class="grey">Barnes                        Informational                    [Page 19]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-20" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   S3 Use cryptographic algorithms in a manner compatible with major
      validation processes.  For example, if typical validation
      standards allow algorithm A to be used for purpose X but not
      purpose Y, then JOSE should not recommend using algorithm A for
      purpose Y.

   S4 Support operation with or without pre-negotiation.  It must be
      possible to create or process secure objects without any
      configuration beyond key provisioning.  If it is possible for keys
      to be derived from application context, it must be possible for a
      recipient to recognize when it does not have the appropriate key.

<span class="h3"><a class="selflink" id="section-6.3" href="#section-6.3">6.3</a>.  Desiderata</span>

   D1 Maximize compatibility with the W3C Web Crypto specifications,
      e.g., by coordinating with the Web Crypto working group to
      encourage alignment of algorithms and algorithm identifiers.

   D2 Avoid JSON canonicalization to the extent possible.  That is, all
      other things being equal, techniques that rely on fixing a
      serialization of an object (e.g., by encoding it with base64url)
      are preferred over those that require converting an object to a
      canonical form.

   D3 Maximize the extent to which the inputs and outputs of JOSE
      cryptographic operations can be controlled by the applications, as
      opposed to involving processing specific to JOSE.  This allows
      JOSE the flexibility to address the needs of many cryptographic
      protocols.  For example, in some cases, it might allow JOSE
      objects to be translated to legacy formats such as CMS without the
      need for re-encryption or re-signing.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  Security Considerations</span>

   The primary focus of this document is the requirements for a JSON-
   based secure object format.  At the level of general security
   considerations for object-based security technologies, the security
   considerations for this format are the same as for CMS [<a href="/doc/html/rfc5652" title="&quot;Cryptographic Message Syntax (CMS)&quot;">RFC5652</a>].
   The primary difference between the JOSE format and CMS is that JOSE
   is based on JSON, which does not have a canonical representation.
   The lack of a canonical form means that it is difficult to determine
   whether two JSON objects represent the same information, which could
   lead to vulnerabilities in some usages of JOSE.








<span class="grey">Barnes                        Informational                    [Page 20]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-21" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  References</span>

<span class="h3"><a class="selflink" id="section-8.1" href="#section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC4949">RFC4949</a>]  Shirey, R., &quot;Internet Security Glossary, Version 2&quot;, <a href="/doc/html/rfc4949">RFC</a>
              <a href="/doc/html/rfc4949">4949</a>, August 2007.

   [<a id="ref-RFC5652">RFC5652</a>]  Housley, R., &quot;Cryptographic Message Syntax (CMS)&quot;, STD 70,
              <a href="/doc/html/rfc5652">RFC 5652</a>, September 2009.

   [<a id="ref-RFC6120">RFC6120</a>]  Saint-Andre, P., &quot;Extensible Messaging and Presence
              Protocol (XMPP): Core&quot;, <a href="/doc/html/rfc6120">RFC 6120</a>, March 2011.

   [<a id="ref-RFC6708">RFC6708</a>]  Kiesel, S., Previdi, S., Stiemerling, M., Woundy, R., and
              Y. Yang, &quot;Application-Layer Traffic Optimization (ALTO)
              Requirements&quot;, <a href="/doc/html/rfc6708">RFC 6708</a>, September 2012.

   [<a id="ref-RFC6749">RFC6749</a>]  Hardt, D., &quot;The OAuth 2.0 Authorization Framework&quot;, <a href="/doc/html/rfc6749">RFC</a>
              <a href="/doc/html/rfc6749">6749</a>, October 2012.

   [<a id="ref-RFC7159">RFC7159</a>]  Bray, T., &quot;The JavaScript Object Notation (JSON) Data
              Interchange Format&quot;, <a href="/doc/html/rfc7159">RFC 7159</a>, March 2014.

   [<a id="ref-W3C.REC-xml">W3C.REC-xml</a>]
              Bray, T., Maler, E., Paoli, J., and C. Sperberg-McQueen,
              &quot;Extensible Markup Language (XML) 1.0 (Fifth Edition)&quot;,
              W3C Recommendation, November 2008,
              &lt;<a href="http://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/</a>&gt;.

   [<a id="ref-WebCrypto">WebCrypto</a>]
              Dahl, D. and R. Sleevi, &quot;Web Cryptography API&quot;, W3C
              Working Draft, January 2013,
              &lt;<a href="http://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/">http://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/</a>&gt;.

<span class="h3"><a class="selflink" id="section-8.2" href="#section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-ALERT-REQ">ALERT-REQ</a>]
              Schulzrinne, H., Norreys, S., Rosen, B., and H.
              Tschofenig, &quot;Requirements, Terminology and Framework for
              Exigent Communications&quot;, Work in Progress, March 2012.

   [<a id="ref-ALTO">ALTO</a>]     Alimi, R., Ed., Penno, R., Ed., and Y. Yang, Ed., &quot;ALTO
              Protocol&quot;, Work in Progress, March 2014.

   [<a id="ref-CAP">CAP</a>]      Botterell, A. and E. Jones, &quot;Common Alerting Protocol,
              v1.1&quot;, OASIS Standard CAP-V1.1, October 2005,
              &lt;<a href="http://www.oasis-open.org/committees/download.php/15135/emergency-CAPv1.1-Corrected_DOM.pdf">http://www.oasis-open.org/committees/download.php/15135/</a>
              <a href="http://www.oasis-open.org/committees/download.php/15135/emergency-CAPv1.1-Corrected_DOM.pdf">emergency-CAPv1.1-Corrected_DOM.pdf</a>&gt;.



<span class="grey">Barnes                        Informational                    [Page 21]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-22" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   [<a id="ref-CONSTRAINED">CONSTRAINED</a>]
              Bormann, C., Ersue, M., and A. Keranen, &quot;Terminology for
              Constrained Node Networks&quot;, Work in Progress, March 2014.

   [<a id="ref-CoAP">CoAP</a>]     Shelby, Z., Hartke, K., and C. Bormann, &quot;Constrained
              Application Protocol (CoAP)&quot;, Work in Progress, June 2013.

   [<a id="ref-ITU.X690.2002">ITU.X690.2002</a>]
              International Telecommunications Union, &quot;Information
              Technology - ASN.1 encoding rules: Specification of Basic
              Encoding Rules (BER), Canonical Encoding Rules (CER) and
              Distinguished Encoding Rules (DER)&quot;, ITU-T Recommendation
              X.690, July 2002.

   [<a id="ref-JWA">JWA</a>]      Jones, M., &quot;JSON Web Algorithms (JWA)&quot;, Work in Progress,
              March 2014.

   [<a id="ref-JWE">JWE</a>]      Jones, M. and J. Hildebrand, &quot;JSON Web Encryption (JWE)&quot;,
              Work in Progress, March 2014.

   [<a id="ref-JWK">JWK</a>]      Jones, M., &quot;JSON Web Key (JWK)&quot;, Work in Progress, March
              2014.

   [<a id="ref-JWS">JWS</a>]      Jones, M., Bradley, J., and N. Sakimura, &quot;JSON Web
              Signature (JWS)&quot;, Work in Progress, March 2014.

   [<a id="ref-JWT-BEARER">JWT-BEARER</a>]
              Jones, M., Campbell, B., and C. Mortimore, &quot;JSON Web Token
              (JWT) Profile for OAuth 2.0 Client Authentication and
              Authorization Grants&quot;, Work in Progress, March 2014.

   [<a id="ref-JWT">JWT</a>]      Jones, M., Bradley, J., and N. Sakimura, &quot;JSON Web Token
              (JWT)&quot;, Work in Progress, March 2014.

   [<a id="ref-OASIS.saml-core-2.0-os">OASIS.saml-core-2.0-os</a>]
              Cantor, S., Kemp, J., Maler, E., and R. Philpott,
              &quot;Assertions and Protocols for the OASIS Security Assertion
              Markup Language (SAML) V2.0&quot;, Oasis Standard, March 2005,
              &lt;<a href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">http://docs.oasis-open.org/security/saml/v2.0/</a>
              <a href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">saml-core-2.0-os.pdf</a>&gt;.

   [<a id="ref-OpenID.Core">OpenID.Core</a>]
              Bradley, J., de Medeiros, B., Jones, M., Mortimore, C.,
              and N. Sakimura, &quot;OpenID Connect Core 1.0&quot;, December 2013,
              &lt;<a href="http://openid.net/specs/openid-connect-core-1_0.html">http://openid.net/specs/openid-connect-core-1_0.html</a>&gt;.

   [<a id="ref-Persona">Persona</a>]  Mozilla Developer Network, &quot;Mozilla Persona&quot;, April 2013,
              &lt;<a href="https://developer.mozilla.org/en-US/docs/Persona">https://developer.mozilla.org/en-US/docs/Persona</a>&gt;.



<span class="grey">Barnes                        Informational                    [Page 22]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-23" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   [<a id="ref-RFC2616">RFC2616</a>]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, <a href="/doc/html/rfc2616">RFC 2616</a>, June 1999.

   [<a id="ref-RFC2818">RFC2818</a>]  Rescorla, E., &quot;HTTP Over TLS&quot;, <a href="/doc/html/rfc2818">RFC 2818</a>, May 2000.

   [<a id="ref-RFC3207">RFC3207</a>]  Hoffman, P., &quot;SMTP Service Extension for Secure SMTP over
              Transport Layer Security&quot;, <a href="/doc/html/rfc3207">RFC 3207</a>, February 2002.

   [<a id="ref-RFC3923">RFC3923</a>]  Saint-Andre, P., &quot;End-to-End Signing and Object Encryption
              for the Extensible Messaging and Presence Protocol
              (XMPP)&quot;, <a href="/doc/html/rfc3923">RFC 3923</a>, October 2004.

   [<a id="ref-RFC4301">RFC4301</a>]  Kent, S. and K. Seo, &quot;Security Architecture for the
              Internet Protocol&quot;, <a href="/doc/html/rfc4301">RFC 4301</a>, December 2005.

   [<a id="ref-RFC4648">RFC4648</a>]  Josefsson, S., &quot;The Base16, Base32, and Base64 Data
              Encodings&quot;, <a href="/doc/html/rfc4648">RFC 4648</a>, October 2006.

   [<a id="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, <a href="/doc/html/rfc5246">RFC 5246</a>, August 2008.

   [<a id="ref-RFC5322">RFC5322</a>]  Resnick, P., Ed., &quot;Internet Message Format&quot;, <a href="/doc/html/rfc5322">RFC 5322</a>,
              October 2008.

   [<a id="ref-RFC5751">RFC5751</a>]  Ramsdell, B. and S. Turner, &quot;Secure/Multipurpose Internet
              Mail Extensions (S/MIME) Version 3.2 Message
              Specification&quot;, <a href="/doc/html/rfc5751">RFC 5751</a>, January 2010.

   [<a id="ref-RFC6750">RFC6750</a>]  Jones, M. and D. Hardt, &quot;The OAuth 2.0 Authorization
              Framework: Bearer Token Usage&quot;, <a href="/doc/html/rfc6750">RFC 6750</a>, October 2012.

   [<a id="ref-SAML2">SAML2</a>]    Campbell, B., Mortimore, C., and M. Jones, &quot;SAML 2.0
              Profile for OAuth 2.0 Client Authentication and
              Authorization Grants&quot;, Work in Progress, March 2014.

   [<a id="ref-W3C.xmldsig-core">W3C.xmldsig-core</a>]
              Eastlake, D., Reagle, J., and D. Solo, &quot;XML-Signature
              Syntax and Processing&quot;, W3C Recommendation, June 2008,
              &lt;<a href="http://www.w3.org/TR/2008/REC-xmldsig-core-20080610/">http://www.w3.org/TR/2008/REC-xmldsig-core-20080610/</a>&gt;.

   [<a id="ref-W3C.xmlenc-core">W3C.xmlenc-core</a>]
              Eastlake, D. and J. Reagle, &quot;XML Encryption Syntax and
              Processing&quot;, W3C Candidate Recommendation, December 2002,
              &lt;<a href="http://www.w3.org/TR/2002/REC-xmlenc-core-20021210/">http://www.w3.org/TR/2002/REC-xmlenc-core-20021210/</a>&gt;.






<span class="grey">Barnes                        Informational                    [Page 23]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-24" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


   [<a id="ref-WS-Federation">WS-Federation</a>]
              Goodner, M., Kaler, C., McIntosh, M., and A. Nadalin, &quot;Web
              Services Federation Language (WS-Federation) Version 1.2&quot;,
              Oasis Standard, May 2009, &lt;<a href="http://docs.oasis-open.org/wsfed/federation/v1.2/os/ws-federation-1.2-spec-os.html">http://docs.oasis-open.org/</a>
              <a href="http://docs.oasis-open.org/wsfed/federation/v1.2/os/ws-federation-1.2-spec-os.html">wsfed/federation/v1.2/os/ws-federation-1.2-spec-os.html</a>&gt;.

   [<a id="ref-XMPP-E2E">XMPP-E2E</a>] Miller, M., &quot;End-to-End Object Encryption and Signatures
              for the Extensible Messaging and Presence Protocol
              (XMPP)&quot;, Work in Progress, June 2013.










































<span class="grey">Barnes                        Informational                    [Page 24]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-25" ></span>
<span class="grey"><a href="/doc/html/rfc7165">RFC 7165</a>                     JOSE Use Cases                   April 2014</span>


<span class="h2"><a class="selflink" id="appendix-A" href="#appendix-A">Appendix A</a>.  Acknowledgements</span>

   Thanks to Matt Miller for discussions related to the XMPP end-to-end
   security model and to Mike Jones for considerations related to
   security tokens and XML security.  Thanks to Mark Watson for raising
   the need for representing symmetric keys and binding attributes to
   them.  Thanks to Ludwig Seitz for contributing the constrained device
   use case.

Author&#x27;s Address

   Richard Barnes
   Mozilla
   331 E. Evelyn Ave.
   Mountain View, CA  94041
   US

   EMail: rlb@ipv.sx

































Barnes                        Informational                    [Page 25]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

