<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc8835
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-rtcweb-transports/">
  <meta name="description" content="Transports for WebRTC (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgblue"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc8835.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc8835.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/rfc8835.xml" title="XML source for this document">xml</a>|<a href="https://www.rfc-editor.org/rfc/rfc8835.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc8835/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc8835/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/rtcweb/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-rtcweb-transports@ietf.org?subject=draft-ietf-rtcweb-transports" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-rtcweb-transports-17.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-transports-17.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-rtcweb-transports-17.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-rtcweb-transports-17">draft-ietf-rtcweb-transports-17</a>                  Proposed Standard</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                     H. Alvestrand
Request for Comments: 8835                                        Google
Category: Standards Track                                   January 2021
ISSN: 2070-1721


                         <span class="h1">Transports for WebRTC</span>

Abstract

   This document describes the data transport protocols used by Web
   Real-Time Communication (WebRTC), including the protocols used for
   interaction with intermediate boxes such as firewalls, relays, and
   NAT boxes.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="/doc/html/rfc7841#section-2">Section&nbsp;2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8835">https://www.rfc-editor.org/info/rfc8835</a>.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Requirements Language
   3.  Transport and Middlebox Specification
     3.1.  System-Provided Interfaces
     3.2.  Ability to Use IPv4 and IPv6
     3.3.  Usage of Temporary IPv6 Addresses
     3.4.  Middlebox-Related Functions
     3.5.  Transport Protocols Implemented
   4.  Media Prioritization
     4.1.  Local Prioritization
     4.2.  Usage of Quality of Service -- DSCP and Multiplexing
   5.  IANA Considerations
   6.  Security Considerations
   7.  References
     7.1.  Normative References
     7.2.  Informative References
   Acknowledgements
   Author&#x27;s Address

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   WebRTC is a protocol suite aimed at real-time multimedia exchange
   between browsers, and between browsers and other entities.

   WebRTC is described in the WebRTC overview document [<a href="/doc/html/rfc8825" title="&quot;Overview: Real-Time Protocols for Browser-Based Applications&quot;">RFC8825</a>], which
   also defines terminology used in this document, including the terms
   &quot;WebRTC endpoint&quot; and &quot;WebRTC browser&quot;.

   Terminology for RTP sources is taken from [<a href="/doc/html/rfc7656" title="&quot;A Taxonomy of Semantics and Mechanisms for Real-Time Transport Protocol (RTP) Sources&quot;">RFC7656</a>].

   This document focuses on the data transport protocols that are used
   by conforming implementations, including the protocols used for
   interaction with intermediate boxes such as firewalls, relays, and
   NAT boxes.

   This protocol suite is intended to satisfy the security
   considerations described in the WebRTC security documents, [<a href="/doc/html/rfc8826" title="&quot;Security Considerations for WebRTC&quot;">RFC8826</a>]
   and [<a href="/doc/html/rfc8827" title="&quot;WebRTC Security Architecture&quot;">RFC8827</a>].

   This document describes requirements that apply to all WebRTC
   endpoints.  When there are requirements that apply only to WebRTC
   browsers, this is called out explicitly.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Requirements Language</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="/doc/html/bcp14">BCP</a>
   <a href="/doc/html/bcp14">14</a> [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="/doc/html/rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Transport and Middlebox Specification</span>


<span class="h3"><a class="selflink" id="section-3.1" href="#section-3.1">3.1</a>.  System-Provided Interfaces</span>

   The protocol specifications used here assume that the following
   protocols are available to the implementations of the WebRTC
   protocols:

   UDP [<a href="/doc/html/rfc0768" title="&quot;User Datagram Protocol&quot;">RFC0768</a>]:  This is the protocol assumed by most protocol
      elements described.

   TCP [<a href="/doc/html/rfc0793" title="&quot;Transmission Control Protocol&quot;">RFC0793</a>]:  This is used for HTTP/WebSockets, as well as TURN/TLS
      and ICE-TCP.

   For both protocols, IPv4 and IPv6 support is assumed.

   For UDP, this specification assumes the ability to set the
   Differentiated Services Code Point (DSCP) of the sockets opened on a
   per-packet basis, in order to achieve the prioritizations described
   in [<a href="/doc/html/rfc8837" title="&quot;Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS&quot;">RFC8837</a>] (see <a href="#section-4.2">Section 4.2</a> of this document) when multiple media
   types are multiplexed.  It does not assume that the DSCPs will be
   honored and does assume that they may be zeroed or changed, since
   this is a local configuration issue.

   Platforms that do not give access to these interfaces will not be
   able to support a conforming WebRTC endpoint.

   This specification does not assume that the implementation will have
   access to ICMP or raw IP.

   The following protocols may be used, but they can be implemented by a
   WebRTC endpoint and are therefore not defined as &quot;system-provided
   interfaces&quot;:

   TURN:  Traversal Using Relays Around NAT [<a href="/doc/html/rfc8656" title="&quot;Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)&quot;">RFC8656</a>]

   STUN:  Session Traversal Utilities for NAT [<a href="/doc/html/rfc5389" title="&quot;Session Traversal Utilities for NAT (STUN)&quot;">RFC5389</a>]

   ICE:  Interactive Connectivity Establishment [<a href="/doc/html/rfc8445" title="&quot;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&quot;">RFC8445</a>]

   TLS:  Transport Layer Security [<a href="/doc/html/rfc8446" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.3&quot;">RFC8446</a>]

   DTLS:  Datagram Transport Layer Security [<a href="/doc/html/rfc6347" title="&quot;Datagram Transport Layer Security Version 1.2&quot;">RFC6347</a>]

<span class="h3"><a class="selflink" id="section-3.2" href="#section-3.2">3.2</a>.  Ability to Use IPv4 and IPv6</span>

   Web applications running in a WebRTC browser MUST be able to utilize
   both IPv4 and IPv6 where available -- that is, when two peers have
   only IPv4 connectivity to each other, or they have only IPv6
   connectivity to each other, applications running in the WebRTC
   browser MUST be able to communicate.

   When TURN is used, and the TURN server has IPv4 or IPv6 connectivity
   to the peer or the peer&#x27;s TURN server, candidates of the appropriate
   types MUST be supported.  The &quot;Happy Eyeballs&quot; specification for ICE
   [<a href="/doc/html/rfc8421" title="&quot;Guidelines for Multihomed and IPv4/IPv6 Dual-Stack Interactive Connectivity Establishment (ICE)&quot;">RFC8421</a>] SHOULD be supported.

<span class="h3"><a class="selflink" id="section-3.3" href="#section-3.3">3.3</a>.  Usage of Temporary IPv6 Addresses</span>

   The IPv6 default address selection specification [<a href="/doc/html/rfc6724" title="&quot;Default Address Selection for Internet Protocol Version 6 (IPv6)&quot;">RFC6724</a>] specifies
   that temporary addresses [<a href="/doc/html/rfc4941" title="&quot;Privacy Extensions for Stateless Address Autoconfiguration in IPv6&quot;">RFC4941</a>] are to be preferred over permanent
   addresses.  This is a change from the rules specified by [<a href="/doc/html/rfc3484" title="&quot;Default Address Selection for Internet Protocol version 6 (IPv6)&quot;">RFC3484</a>].
   For applications that select a single address, this is usually done
   by the IPV6_PREFER_SRC_TMP preference flag specified in [<a href="/doc/html/rfc5014" title="&quot;IPv6 Socket API for Source Address Selection&quot;">RFC5014</a>].
   However, this rule, which is intended to ensure that privacy-enhanced
   addresses are used in preference to static addresses, doesn&#x27;t have
   the right effect in ICE, where all addresses are gathered and
   therefore revealed to the application.  Therefore, the following rule
   is applied instead:

      When a WebRTC endpoint gathers all IPv6 addresses on its host, and
      both nondeprecated temporary addresses and permanent addresses of
      the same scope are present, the WebRTC endpoint SHOULD discard the
      permanent addresses before exposing addresses to the application
      or using them in ICE.  This is consistent with the default policy
      described in [<a href="/doc/html/rfc6724" title="&quot;Default Address Selection for Internet Protocol Version 6 (IPv6)&quot;">RFC6724</a>].

      If some, but not all, of the temporary IPv6 addresses are marked
      deprecated, the WebRTC endpoint SHOULD discard the deprecated
      addresses, unless they are used by an ongoing connection.  In an
      ICE restart, deprecated addresses that are currently in use MAY be
      retained.

<span class="h3"><a class="selflink" id="section-3.4" href="#section-3.4">3.4</a>.  Middlebox-Related Functions</span>

   The primary mechanism for dealing with middleboxes is ICE, which is
   an appropriate way to deal with NAT boxes and firewalls that accept
   traffic from the inside, but only from the outside if it is in
   response to inside traffic (simple stateful firewalls).

   ICE [<a href="/doc/html/rfc8445" title="&quot;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&quot;">RFC8445</a>] MUST be supported.  The implementation MUST be a full
   ICE implementation, not ICE-Lite.  A full ICE implementation allows
   interworking with both ICE and ICE-Lite implementations when they are
   deployed appropriately.

   In order to deal with situations where both parties are behind NATs
   of the type that perform endpoint-dependent mapping (as defined in
   <a href="/doc/html/rfc5128#section-2.4">[RFC5128], Section&nbsp;2.4</a>), TURN [<a href="/doc/html/rfc8656" title="&quot;Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)&quot;">RFC8656</a>] MUST be supported.

   WebRTC browsers MUST support configuration of STUN and TURN servers,
   from both browser configuration and an application.

   Note that other work exists around STUN and TURN server discovery and
   management, including [<a href="/doc/html/rfc8155" title="&quot;Traversal Using Relays around NAT (TURN) Server Auto Discovery&quot;">RFC8155</a>] for server discovery, as well as
   [<a href="#ref-RETURN" title="&quot;Recursively Encapsulated TURN (RETURN) for Connectivity and Privacy in WebRTC&quot;">RETURN</a>].

   In order to deal with firewalls that block all UDP traffic, the mode
   of TURN that uses TCP between the WebRTC endpoint and the TURN server
   MUST be supported, and the mode of TURN that uses TLS over TCP
   between the WebRTC endpoint and the TURN server MUST be supported.
   See <a href="/doc/html/rfc8656#section-3.1">Section&nbsp;3.1 of [RFC8656]</a>, for details.

   In order to deal with situations where one party is on an IPv4
   network and the other party is on an IPv6 network, TURN extensions
   for IPv6 MUST be supported.

   TURN TCP candidates, where the connection from the WebRTC endpoint&#x27;s
   TURN server to the peer is a TCP connection, [<a href="/doc/html/rfc6062" title="&quot;Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations&quot;">RFC6062</a>] MAY be
   supported.

   However, such candidates are not seen as providing any significant
   benefit, for the following reasons.

   First, use of TURN TCP candidates would only be relevant in cases
   where both peers are required to use TCP to establish a connection.

   Second, that use case is supported in a different way by both sides
   establishing UDP relay candidates using TURN over TCP to connect to
   their respective relay servers.

   Third, using TCP between the WebRTC endpoint&#x27;s TURN server and the
   peer may result in more performance problems than using UDP, e.g.,
   due to head of line blocking.

   ICE-TCP candidates [<a href="/doc/html/rfc6544" title="&quot;TCP Candidates with Interactive Connectivity Establishment (ICE)&quot;">RFC6544</a>] MUST be supported; this may allow
   applications to communicate to peers with public IP addresses across
   UDP-blocking firewalls without using a TURN server.

   If TCP connections are used, RTP framing according to [<a href="/doc/html/rfc4571" title="&quot;Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection- Oriented Transport&quot;">RFC4571</a>] MUST
   be used for all packets.  This includes the RTP packets, DTLS packets
   used to carry data channels, and STUN connectivity check packets.

   The ALTERNATE-SERVER mechanism specified in <a href="/doc/html/rfc5389#section-11">Section&nbsp;11 of [RFC5389]</a>
   (300 Try Alternate) MUST be supported.

   The WebRTC endpoint MAY support accessing the Internet through an
   HTTP proxy.  If it does so, it MUST include the &quot;ALPN&quot; header as
   specified in [<a href="/doc/html/rfc7639" title="&quot;The ALPN HTTP Header Field&quot;">RFC7639</a>], and proxy authentication as described in
   <a href="/doc/html/rfc7231#section-4.3.6">Section&nbsp;4.3.6 of [RFC7231]</a> and [<a href="/doc/html/rfc7235" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Authentication&quot;">RFC7235</a>] MUST also be supported.

<span class="h3"><a class="selflink" id="section-3.5" href="#section-3.5">3.5</a>.  Transport Protocols Implemented</span>

   For transport of media, secure RTP is used.  The details of the RTP
   profile used are described in &quot;Media Transport and Use of RTP in
   WebRTC&quot; [<a href="/doc/html/rfc8834" title="&quot;Media Transport and Use of RTP in WebRTC&quot;">RFC8834</a>], which mandates the use of a circuit breaker
   [<a href="/doc/html/rfc8083" title="&quot;Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions&quot;">RFC8083</a>] and congestion control (see [<a href="/doc/html/rfc8836" title="&quot;Congestion Control Requirements for Interactive Real-Time Media&quot;">RFC8836</a>] for further
   guidance).

   Key exchange MUST be done using DTLS-SRTP, as described in [<a href="/doc/html/rfc8827" title="&quot;WebRTC Security Architecture&quot;">RFC8827</a>].

   For data transport over the WebRTC data channel [<a href="/doc/html/rfc8831" title="&quot;WebRTC Data Channels&quot;">RFC8831</a>], WebRTC
   endpoints MUST support SCTP over DTLS over ICE.  This encapsulation
   is specified in [<a href="/doc/html/rfc8261" title="&quot;Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets&quot;">RFC8261</a>].  Negotiation of this transport in the
   Session Description Protocol (SDP) is defined in [<a href="/doc/html/rfc8841" title="&quot;Session Description Protocol (SDP) Offer/Answer Procedures for Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport&quot;">RFC8841</a>].  The SCTP
   extension for I-DATA [<a href="/doc/html/rfc8260" title="&quot;Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol&quot;">RFC8260</a>] MUST be supported.

   The setup protocol for WebRTC data channels described in [<a href="/doc/html/rfc8832" title="&quot;WebRTC Data Channel Establishment Protocol&quot;">RFC8832</a>]
   MUST be supported.

      |  Note: The interaction between DTLS-SRTP as defined in [<a href="/doc/html/rfc5764" title="&quot;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)&quot;">RFC5764</a>]
      |  and ICE as defined in [<a href="/doc/html/rfc8445" title="&quot;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&quot;">RFC8445</a>] is described in <a href="#section-6">Section 6</a> of
      |  [<a href="/doc/html/rfc8842" title="&quot;Session Description Protocol (SDP) Offer/Answer Considerations for Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)&quot;">RFC8842</a>].  The effect of this specification is that all ICE
      |  candidate pairs associated with a single component are part of
      |  the same DTLS association.  Thus, there will only be one DTLS
      |  handshake, even if there are multiple valid candidate pairs.

   WebRTC endpoints MUST support multiplexing of DTLS and RTP over the
   same port pair, as described in the DTLS-SRTP specification
   <a href="/doc/html/rfc5764#section-5.1.2">[RFC5764], Section&nbsp;5.1.2</a>, with clarifications in [<a href="/doc/html/rfc7983" title="&quot;Multiplexing Scheme Updates for Secure Real-time Transport Protocol (SRTP) Extension for Datagram Transport Layer Security (DTLS)&quot;">RFC7983</a>].  All
   application-layer protocol payloads over this DTLS connection are
   SCTP packets.

   Protocol identification MUST be supplied as part of the DTLS
   handshake, as specified in [<a href="/doc/html/rfc8833" title="&quot;Application-Layer Protocol Negotiation (ALPN) for WebRTC&quot;">RFC8833</a>].

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Media Prioritization</span>

   In the WebRTC prioritization model, the application tells the WebRTC
   endpoint about the priority of media and data that is controlled from
   the API.

   In this context, a &quot;flow&quot; is used for the units that are given a
   specific priority through the WebRTC API.

   For media, a &quot;media flow&quot;, which can be an &quot;audio flow&quot; or a &quot;video
   flow&quot;, is what [<a href="/doc/html/rfc7656" title="&quot;A Taxonomy of Semantics and Mechanisms for Real-Time Transport Protocol (RTP) Sources&quot;">RFC7656</a>] calls a &quot;media source&quot;, which results in a
   &quot;source RTP stream&quot; and one or more &quot;redundancy RTP streams&quot;.  This
   specification does not describe prioritization between the RTP
   streams that come from a single media source.

   All media flows in WebRTC are assumed to be interactive, as defined
   in [<a href="/doc/html/rfc4594" title="&quot;Configuration Guidelines for DiffServ Service Classes&quot;">RFC4594</a>]; there is no browser API support for indicating whether
   media is interactive or noninteractive.

   A &quot;data flow&quot; is the outgoing data on a single WebRTC data channel.

   The priority associated with a media flow or data flow is classified
   as &quot;very-low&quot;, &quot;low&quot;, &quot;medium&quot;, or &quot;high&quot;.  There are only four
   priority levels in the API.

   The priority settings affect two pieces of behavior: packet send
   sequence decisions and packet markings.  Each is described in its own
   section below.

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>.  Local Prioritization</span>

   Local prioritization is applied at the local node, before the packet
   is sent.  This means that the prioritization has full access to the
   data about the individual packets and can choose differing treatment
   based on the stream a packet belongs to.

   When a WebRTC endpoint has packets to send on multiple streams that
   are congestion controlled under the same congestion control regime,
   the WebRTC endpoint SHOULD cause data to be emitted in such a way
   that each stream at each level of priority is being given
   approximately twice the transmission capacity (measured in payload
   bytes) of the level below.

   Thus, when congestion occurs, a high-priority flow will have the
   ability to send 8 times as much data as a very-low-priority flow if
   both have data to send.  This prioritization is independent of the
   media type.  The details of which packet to send first are
   implementation defined.

   For example, if there is a high-priority audio flow sending 100-byte
   packets and a low-priority video flow sending 1000-byte packets, and
   outgoing capacity exists for sending &gt; 5000 payload bytes, it would
   be appropriate to send 4000 bytes (40 packets) of audio and 1000
   bytes (one packet) of video as the result of a single pass of sending
   decisions.

   Conversely, if the audio flow is marked low priority and the video
   flow is marked high priority, the scheduler may decide to send 2
   video packets (2000 bytes) and 5 audio packets (500 bytes) when
   outgoing capacity exists for sending &gt; 2500 payload bytes.

   If there are two high-priority audio flows, each will be able to send
   4000 bytes in the same period where a low-priority video flow is able
   to send 1000 bytes.

   Two example implementation strategies are:

   *  When the available bandwidth is known from the congestion control
      algorithm, configure each codec and each data channel with a
      target send rate that is appropriate to its share of the available
      bandwidth.

   *  When congestion control indicates that a specified number of
      packets can be sent, send packets that are available to send using
      a weighted round-robin scheme across the connections.

   Any combination of these, or other schemes that have the same effect,
   is valid, as long as the distribution of transmission capacity is
   approximately correct.

   For media, it is usually inappropriate to use deep queues for
   sending; it is more useful to, for instance, skip intermediate frames
   that have no dependencies on them in order to achieve a lower
   bitrate.  For reliable data, queues are useful.

   Note that this specification doesn&#x27;t dictate when disparate streams
   are to be &quot;congestion controlled under the same congestion control
   regime&quot;.  The issue of coupling congestion controllers is explored
   further in [<a href="/doc/html/rfc8699" title="&quot;Coupled Congestion Control for RTP Media&quot;">RFC8699</a>].

<span class="h3"><a class="selflink" id="section-4.2" href="#section-4.2">4.2</a>.  Usage of Quality of Service -- DSCP and Multiplexing</span>

   When the packet is sent, the network will make decisions about
   queueing and/or discarding the packet that can affect the quality of
   the communication.  The sender can attempt to set the DSCP field of
   the packet to influence these decisions.

   Implementations SHOULD attempt to set QoS on the packets sent,
   according to the guidelines in [<a href="/doc/html/rfc8837" title="&quot;Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS&quot;">RFC8837</a>].  It is appropriate to
   depart from this recommendation when running on platforms where QoS
   marking is not implemented.

   The implementation MAY turn off use of DSCP markings if it detects
   symptoms of unexpected behavior such as priority inversion or
   blocking of packets with certain DSCP markings.  Some examples of
   such behaviors are described in [<a href="#ref-ANRW16" title="&quot;How to say that you&#x27;re special: Can we use bits in the IPv4 header?&quot;">ANRW16</a>].  The detection of these
   conditions is implementation dependent.

   A particularly hard problem is when one media transport uses multiple
   DSCPs, where one may be blocked and another may be allowed.  This is
   allowed even within a single media flow for video in [<a href="/doc/html/rfc8837" title="&quot;Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS&quot;">RFC8837</a>].
   Implementations need to diagnose this scenario; one possible
   implementation is to send initial ICE probes with DSCP 0, and send
   ICE probes on all the DSCPs that are intended to be used once a
   candidate pair has been selected.  If one or more of the DSCP-marked
   probes fail, the sender will switch the media type to using DSCP 0.
   This can be carried out simultaneously with the initial media
   traffic; on failure, the initial data may need to be resent.  This
   switch will, of course, invalidate any congestion information
   gathered up to that point.

   Failures can also start happening during the lifetime of the call;
   this case is expected to be rarer and can be handled by the normal
   mechanisms for transport failure, which may involve an ICE restart.

   Note that when a DSCP causes nondelivery, one has to switch the whole
   media flow to DSCP 0, since all traffic for a single media flow needs
   to be on the same queue for congestion control purposes.  Other flows
   on the same transport, using different DSCPs, don&#x27;t need to change.

   All packets carrying data from the SCTP association supporting the
   data channels MUST use a single DSCP.  The code point used SHOULD be
   that recommended by [<a href="/doc/html/rfc8837" title="&quot;Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS&quot;">RFC8837</a>] for the highest-priority data channel
   carried.  Note that this means that all data packets, no matter what
   their relative priority is, will be treated the same by the network.

   All packets on one TCP connection, no matter what it carries, MUST
   use a single DSCP.

   More advice on the use of DSCPs with RTP, as well as the relationship
   between DSCP and congestion control, is given in [<a href="/doc/html/rfc7657" title="&quot;Differentiated Services (Diffserv) and Real-Time Communication&quot;">RFC7657</a>].

   There exist a number of schemes for achieving quality of service that
   do not depend solely on DSCPs.  Some of these schemes depend on
   classifying the traffic into flows based on 5-tuple (source address,
   source port, protocol, destination address, destination port) or
   6-tuple (5-tuple + DSCP).  Under differing conditions, it may
   therefore make sense for a sending application to choose any of the
   following configurations:

   *  Each media stream carried on its own 5-tuple

   *  Media streams grouped by media type into 5-tuples (such as
      carrying all audio on one 5-tuple)

   *  All media sent over a single 5-tuple, with or without
      differentiation into 6-tuples based on DSCPs

   In each of the configurations mentioned, data channels may be carried
   in their own 5-tuple or multiplexed together with one of the media
   flows.

   More complex configurations, such as sending a high-priority video
   stream on one 5-tuple and sending all other video streams multiplexed
   together over another 5-tuple, can also be envisioned.  More
   information on mapping media flows to 5-tuples can be found in
   [<a href="/doc/html/rfc8834" title="&quot;Media Transport and Use of RTP in WebRTC&quot;">RFC8834</a>].

   A sending implementation MUST be able to support the following
   configurations:

   *  Multiplex all media and data on a single 5-tuple (fully bundled)

   *  Send each media stream on its own 5-tuple and data on its own
      5-tuple (fully unbundled)

   The sending implementation MAY choose to support other
   configurations, such as bundling each media type (audio, video, or
   data) into its own 5-tuple (bundling by media type).

   Sending data channel data over multiple 5-tuples is not supported.

   A receiving implementation MUST be able to receive media and data in
   all these configurations.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  IANA Considerations</span>

   This document has no IANA actions.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Security Considerations</span>

   WebRTC security considerations are enumerated in [<a href="/doc/html/rfc8826" title="&quot;Security Considerations for WebRTC&quot;">RFC8826</a>].

   Security considerations pertaining to the use of DSCP are enumerated
   in [<a href="/doc/html/rfc8837" title="&quot;Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS&quot;">RFC8837</a>].

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  References</span>

<span class="h3"><a class="selflink" id="section-7.1" href="#section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-RFC0768">RFC0768</a>]  Postel, J., &quot;User Datagram Protocol&quot;, STD 6, <a href="/doc/html/rfc768">RFC 768</a>,
              DOI 10.17487/RFC0768, August 1980,
              &lt;<a href="https://www.rfc-editor.org/info/rfc768">https://www.rfc-editor.org/info/rfc768</a>&gt;.

   [<a id="ref-RFC0793">RFC0793</a>]  Postel, J., &quot;Transmission Control Protocol&quot;, STD 7,
              <a href="/doc/html/rfc793">RFC 793</a>, DOI 10.17487/RFC0793, September 1981,
              &lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC4571">RFC4571</a>]  Lazzaro, J., &quot;Framing Real-time Transport Protocol (RTP)
              and RTP Control Protocol (RTCP) Packets over Connection-
              Oriented Transport&quot;, <a href="/doc/html/rfc4571">RFC 4571</a>, DOI 10.17487/RFC4571, July
              2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4571">https://www.rfc-editor.org/info/rfc4571</a>&gt;.

   [<a id="ref-RFC4594">RFC4594</a>]  Babiarz, J., Chan, K., and F. Baker, &quot;Configuration
              Guidelines for DiffServ Service Classes&quot;, <a href="/doc/html/rfc4594">RFC 4594</a>,
              DOI 10.17487/RFC4594, August 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4594">https://www.rfc-editor.org/info/rfc4594</a>&gt;.

   [<a id="ref-RFC4941">RFC4941</a>]  Narten, T., Draves, R., and S. Krishnan, &quot;Privacy
              Extensions for Stateless Address Autoconfiguration in
              IPv6&quot;, <a href="/doc/html/rfc4941">RFC 4941</a>, DOI 10.17487/RFC4941, September 2007,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4941">https://www.rfc-editor.org/info/rfc4941</a>&gt;.

   [<a id="ref-RFC5389">RFC5389</a>]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,
              &quot;Session Traversal Utilities for NAT (STUN)&quot;, <a href="/doc/html/rfc5389">RFC 5389</a>,
              DOI 10.17487/RFC5389, October 2008,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5389">https://www.rfc-editor.org/info/rfc5389</a>&gt;.

   [<a id="ref-RFC5764">RFC5764</a>]  McGrew, D. and E. Rescorla, &quot;Datagram Transport Layer
              Security (DTLS) Extension to Establish Keys for the Secure
              Real-time Transport Protocol (SRTP)&quot;, <a href="/doc/html/rfc5764">RFC 5764</a>,
              DOI 10.17487/RFC5764, May 2010,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5764">https://www.rfc-editor.org/info/rfc5764</a>&gt;.

   [<a id="ref-RFC6062">RFC6062</a>]  Perreault, S., Ed. and J. Rosenberg, &quot;Traversal Using
              Relays around NAT (TURN) Extensions for TCP Allocations&quot;,
              <a href="/doc/html/rfc6062">RFC 6062</a>, DOI 10.17487/RFC6062, November 2010,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6062">https://www.rfc-editor.org/info/rfc6062</a>&gt;.

   [<a id="ref-RFC6347">RFC6347</a>]  Rescorla, E. and N. Modadugu, &quot;Datagram Transport Layer
              Security Version 1.2&quot;, <a href="/doc/html/rfc6347">RFC 6347</a>, DOI 10.17487/RFC6347,
              January 2012, &lt;<a href="https://www.rfc-editor.org/info/rfc6347">https://www.rfc-editor.org/info/rfc6347</a>&gt;.

   [<a id="ref-RFC6544">RFC6544</a>]  Rosenberg, J., Keranen, A., Lowekamp, B. B., and A. B.
              Roach, &quot;TCP Candidates with Interactive Connectivity
              Establishment (ICE)&quot;, <a href="/doc/html/rfc6544">RFC 6544</a>, DOI 10.17487/RFC6544,
              March 2012, &lt;<a href="https://www.rfc-editor.org/info/rfc6544">https://www.rfc-editor.org/info/rfc6544</a>&gt;.

   [<a id="ref-RFC6724">RFC6724</a>]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,
              &quot;Default Address Selection for Internet Protocol Version 6
              (IPv6)&quot;, <a href="/doc/html/rfc6724">RFC 6724</a>, DOI 10.17487/RFC6724, September 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6724">https://www.rfc-editor.org/info/rfc6724</a>&gt;.

   [<a id="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, <a href="/doc/html/rfc7231">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a id="ref-RFC7235">RFC7235</a>]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Authentication&quot;, <a href="/doc/html/rfc7235">RFC 7235</a>,
              DOI 10.17487/RFC7235, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7235">https://www.rfc-editor.org/info/rfc7235</a>&gt;.

   [<a id="ref-RFC7639">RFC7639</a>]  Hutton, A., Uberti, J., and M. Thomson, &quot;The ALPN HTTP
              Header Field&quot;, <a href="/doc/html/rfc7639">RFC 7639</a>, DOI 10.17487/RFC7639, August
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7639">https://www.rfc-editor.org/info/rfc7639</a>&gt;.

   [<a id="ref-RFC7656">RFC7656</a>]  Lennox, J., Gross, K., Nandakumar, S., Salgueiro, G., and
              B. Burman, Ed., &quot;A Taxonomy of Semantics and Mechanisms
              for Real-Time Transport Protocol (RTP) Sources&quot;, <a href="/doc/html/rfc7656">RFC 7656</a>,
              DOI 10.17487/RFC7656, November 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7656">https://www.rfc-editor.org/info/rfc7656</a>&gt;.

   [<a id="ref-RFC7983">RFC7983</a>]  Petit-Huguenin, M. and G. Salgueiro, &quot;Multiplexing Scheme
              Updates for Secure Real-time Transport Protocol (SRTP)
              Extension for Datagram Transport Layer Security (DTLS)&quot;,
              <a href="/doc/html/rfc7983">RFC 7983</a>, DOI 10.17487/RFC7983, September 2016,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7983">https://www.rfc-editor.org/info/rfc7983</a>&gt;.

   [<a id="ref-RFC8083">RFC8083</a>]  Perkins, C. and V. Singh, &quot;Multimedia Congestion Control:
              Circuit Breakers for Unicast RTP Sessions&quot;, <a href="/doc/html/rfc8083">RFC 8083</a>,
              DOI 10.17487/RFC8083, March 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8083">https://www.rfc-editor.org/info/rfc8083</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in <a href="/doc/html/rfc2119">RFC</a>
              <a href="/doc/html/rfc2119">2119</a> Key Words&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-RFC8260">RFC8260</a>]  Stewart, R., Tuexen, M., Loreto, S., and R. Seggelmann,
              &quot;Stream Schedulers and User Message Interleaving for the
              Stream Control Transmission Protocol&quot;, <a href="/doc/html/rfc8260">RFC 8260</a>,
              DOI 10.17487/RFC8260, November 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8260">https://www.rfc-editor.org/info/rfc8260</a>&gt;.

   [<a id="ref-RFC8261">RFC8261</a>]  Tuexen, M., Stewart, R., Jesup, R., and S. Loreto,
              &quot;Datagram Transport Layer Security (DTLS) Encapsulation of
              SCTP Packets&quot;, <a href="/doc/html/rfc8261">RFC 8261</a>, DOI 10.17487/RFC8261, November
              2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8261">https://www.rfc-editor.org/info/rfc8261</a>&gt;.

   [<a id="ref-RFC8421">RFC8421</a>]  Martinsen, P., Reddy, T., and P. Patil, &quot;Guidelines for
              Multihomed and IPv4/IPv6 Dual-Stack Interactive
              Connectivity Establishment (ICE)&quot;, <a href="/doc/html/bcp217">BCP 217</a>, <a href="/doc/html/rfc8421">RFC 8421</a>,
              DOI 10.17487/RFC8421, July 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8421">https://www.rfc-editor.org/info/rfc8421</a>&gt;.

   [<a id="ref-RFC8445">RFC8445</a>]  Keranen, A., Holmberg, C., and J. Rosenberg, &quot;Interactive
              Connectivity Establishment (ICE): A Protocol for Network
              Address Translator (NAT) Traversal&quot;, <a href="/doc/html/rfc8445">RFC 8445</a>,
              DOI 10.17487/RFC8445, July 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8445">https://www.rfc-editor.org/info/rfc8445</a>&gt;.

   [<a id="ref-RFC8446">RFC8446</a>]  Rescorla, E., &quot;The Transport Layer Security (TLS) Protocol
              Version 1.3&quot;, <a href="/doc/html/rfc8446">RFC 8446</a>, DOI 10.17487/RFC8446, August 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;.

   [<a id="ref-RFC8656">RFC8656</a>]  Reddy, T., Ed., Johnston, A., Ed., Matthews, P., and J.
              Rosenberg, &quot;Traversal Using Relays around NAT (TURN):
              Relay Extensions to Session Traversal Utilities for NAT
              (STUN)&quot;, <a href="/doc/html/rfc8656">RFC 8656</a>, DOI 10.17487/RFC8656, February 2020,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8656">https://www.rfc-editor.org/info/rfc8656</a>&gt;.

   [<a id="ref-RFC8825">RFC8825</a>]  Alvestrand, H., &quot;Overview: Real-Time Protocols for
              Browser-Based Applications&quot;, <a href="/doc/html/rfc8825">RFC 8825</a>,
              DOI 10.17487/RFC8825, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8825">https://www.rfc-editor.org/info/rfc8825</a>&gt;.

   [<a id="ref-RFC8826">RFC8826</a>]  Rescorla, E., &quot;Security Considerations for WebRTC&quot;,
              <a href="/doc/html/rfc8826">RFC 8826</a>, DOI 10.17487/RFC8826, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8826">https://www.rfc-editor.org/info/rfc8826</a>&gt;.

   [<a id="ref-RFC8827">RFC8827</a>]  Rescorla, E., &quot;WebRTC Security Architecture&quot;, <a href="/doc/html/rfc8827">RFC 8827</a>,
              DOI 10.17487/RFC8827, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8827">https://www.rfc-editor.org/info/rfc8827</a>&gt;.

   [<a id="ref-RFC8831">RFC8831</a>]  Jesup, R., Loreto, S., and M. Tüxen, &quot;WebRTC Data
              Channels&quot;, <a href="/doc/html/rfc8831">RFC 8831</a>, DOI 10.17487/RFC8831, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8831">https://www.rfc-editor.org/info/rfc8831</a>&gt;.

   [<a id="ref-RFC8832">RFC8832</a>]  Jesup, R., Loreto, S., and M. Tüxen, &quot;WebRTC Data Channel
              Establishment Protocol&quot;, <a href="/doc/html/rfc8832">RFC 8832</a>, DOI 10.17487/RFC8832,
              January 2021, &lt;<a href="https://www.rfc-editor.org/info/rfc8832">https://www.rfc-editor.org/info/rfc8832</a>&gt;.

   [<a id="ref-RFC8833">RFC8833</a>]  Thomson, M., &quot;Application-Layer Protocol Negotiation
              (ALPN) for WebRTC&quot;, <a href="/doc/html/rfc8833">RFC 8833</a>, DOI 10.17487/RFC8833,
              January 2021, &lt;<a href="https://www.rfc-editor.org/info/rfc8833">https://www.rfc-editor.org/info/rfc8833</a>&gt;.

   [<a id="ref-RFC8834">RFC8834</a>]  Perkins, C., Westerlund, M., and J. Ott, &quot;Media Transport
              and Use of RTP in WebRTC&quot;, <a href="/doc/html/rfc8834">RFC 8834</a>, DOI 10.17487/RFC8834,
              January 2021, &lt;<a href="https://www.rfc-editor.org/info/rfc8834">https://www.rfc-editor.org/info/rfc8834</a>&gt;.

   [<a id="ref-RFC8836">RFC8836</a>]  Jesup, R. and Z. Sarker, Ed., &quot;Congestion Control
              Requirements for Interactive Real-Time Media&quot;, <a href="/doc/html/rfc8836">RFC 8836</a>,
              DOI 10.17487/RFC8836, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8836">https://www.rfc-editor.org/info/rfc8836</a>&gt;.

   [<a id="ref-RFC8837">RFC8837</a>]  Jones, P., Dhesikan, S., Jennings, C., and D. Druta,
              &quot;Differentiated Services Code Point (DSCP) Packet Markings
              for WebRTC QoS&quot;, <a href="/doc/html/rfc8837">RFC 8837</a>, DOI 10.17487/RFC8837, January
              2021, &lt;<a href="https://www.rfc-editor.org/info/rfc8837">https://www.rfc-editor.org/info/rfc8837</a>&gt;.

   [<a id="ref-RFC8841">RFC8841</a>]  Holmberg, C., Shpount, R., Loreto, S., and G. Camarillo,
              &quot;Session Description Protocol (SDP) Offer/Answer
              Procedures for Stream Control Transmission Protocol (SCTP)
              over Datagram Transport Layer Security (DTLS) Transport&quot;,
              <a href="/doc/html/rfc8841">RFC 8841</a>, DOI 10.17487/RFC8841, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8841">https://www.rfc-editor.org/info/rfc8841</a>&gt;.

   [<a id="ref-RFC8842">RFC8842</a>]  Holmberg, C. and R. Shpount, &quot;Session Description Protocol
              (SDP) Offer/Answer Considerations for Datagram Transport
              Layer Security (DTLS) and Transport Layer Security (TLS)&quot;,
              <a href="/doc/html/rfc8842">RFC 8842</a>, DOI 10.17487/RFC8842, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8842">https://www.rfc-editor.org/info/rfc8842</a>&gt;.

<span class="h3"><a class="selflink" id="section-7.2" href="#section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-ANRW16">ANRW16</a>]   Barik, R., Welzl, M., and A. Elmokashfi, &quot;How to say that
              you&#x27;re special: Can we use bits in the IPv4 header?&quot;, ANRW
              &#x27;16: Proceedings of the 2016 Applied Networking Research
              Workshop, pages 68-70, DOI 10.1145/2959424.2959442, July
              2016, &lt;<a href="https://irtf.org/anrw/2016/anrw16-final17.pdf">https://irtf.org/anrw/2016/anrw16-final17.pdf</a>&gt;.

   [<a id="ref-RETURN">RETURN</a>]   Schwartz, B. and J. Uberti, &quot;Recursively Encapsulated TURN
              (RETURN) for Connectivity and Privacy in WebRTC&quot;, Work in
              Progress, Internet-Draft, <a href="/doc/html/draft-ietf-rtcweb-return-02">draft-ietf-rtcweb-return-02</a>, 27
              March 2017,
              &lt;<a href="https://tools.ietf.org/html/draft-ietf-rtcweb-return-02">https://tools.ietf.org/html/draft-ietf-rtcweb-return-02</a>&gt;.

   [<a id="ref-RFC3484">RFC3484</a>]  Draves, R., &quot;Default Address Selection for Internet
              Protocol version 6 (IPv6)&quot;, <a href="/doc/html/rfc3484">RFC 3484</a>,
              DOI 10.17487/RFC3484, February 2003,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3484">https://www.rfc-editor.org/info/rfc3484</a>&gt;.

   [<a id="ref-RFC5014">RFC5014</a>]  Nordmark, E., Chakrabarti, S., and J. Laganier, &quot;IPv6
              Socket API for Source Address Selection&quot;, <a href="/doc/html/rfc5014">RFC 5014</a>,
              DOI 10.17487/RFC5014, September 2007,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5014">https://www.rfc-editor.org/info/rfc5014</a>&gt;.

   [<a id="ref-RFC5128">RFC5128</a>]  Srisuresh, P., Ford, B., and D. Kegel, &quot;State of Peer-to-
              Peer (P2P) Communication across Network Address
              Translators (NATs)&quot;, <a href="/doc/html/rfc5128">RFC 5128</a>, DOI 10.17487/RFC5128, March
              2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5128">https://www.rfc-editor.org/info/rfc5128</a>&gt;.

   [<a id="ref-RFC7657">RFC7657</a>]  Black, D., Ed. and P. Jones, &quot;Differentiated Services
              (Diffserv) and Real-Time Communication&quot;, <a href="/doc/html/rfc7657">RFC 7657</a>,
              DOI 10.17487/RFC7657, November 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7657">https://www.rfc-editor.org/info/rfc7657</a>&gt;.

   [<a id="ref-RFC8155">RFC8155</a>]  Patil, P., Reddy, T., and D. Wing, &quot;Traversal Using Relays
              around NAT (TURN) Server Auto Discovery&quot;, <a href="/doc/html/rfc8155">RFC 8155</a>,
              DOI 10.17487/RFC8155, April 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8155">https://www.rfc-editor.org/info/rfc8155</a>&gt;.

   [<a id="ref-RFC8699">RFC8699</a>]  Islam, S., Welzl, M., and S. Gjessing, &quot;Coupled Congestion
              Control for RTP Media&quot;, <a href="/doc/html/rfc8699">RFC 8699</a>, DOI 10.17487/RFC8699,
              January 2020, &lt;<a href="https://www.rfc-editor.org/info/rfc8699">https://www.rfc-editor.org/info/rfc8699</a>&gt;.

Acknowledgements

   This document is based on earlier draft versions embedded in
   [<a href="/doc/html/rfc8825" title="&quot;Overview: Real-Time Protocols for Browser-Based Applications&quot;">RFC8825</a>], which were the result of contributions from many RTCWEB
   Working Group members.

   Special thanks for reviews of earlier draft versions of this document
   go to Eduardo Gueiros, Magnus Westerlund, Markus Isomaki, and Dan
   Wing; the contributions from Andrew Hutton also deserve special
   mention.

Author&#x27;s Address

   Harald Alvestrand
   Google

   Email: harald@alvestrand.no
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

