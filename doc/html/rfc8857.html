<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc8857
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.34.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.34.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-bfcpbis-bfcp-websocket/">
  <meta name="description" content="The WebSocket Protocol as a Transport for the Binary Floor Control Protocol (BFCP) (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.34.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.34.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgblue"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc8857.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc8857.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/rfc8857.xml" title="XML source for this document">xml</a>|<a href="https://www.rfc-editor.org/rfc/rfc8857.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc8857/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc8857/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/bfcpbis/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-bfcpbis-bfcp-websocket@ietf.org?subject=draft-ietf-bfcpbis-bfcp-websocket" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-bfcpbis-bfcp-websocket-15.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-bfcpbis-bfcp-websocket-15.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-bfcpbis-bfcp-websocket-15.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-bfcpbis-bfcp-websocket-15">draft-ietf-bfcpbis-bfcp-websocket-15</a>             Proposed Standard</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                        V. Pascual
Request for Comments: 8857                                         Nokia
Category: Standards Track                                       A. Rom√°n
ISSN: 2070-1721                                                   Quobis
                                                              S. Cazeaux
                                                                  Orange
                                                            G. Salgueiro
                                                         R. Ravindranath
                                                                   Cisco
                                                            January 2021


   <span class="h1">The WebSocket Protocol as a Transport for the Binary Floor Control</span>
                            <span class="h1">Protocol (BFCP)</span>

Abstract

   The WebSocket protocol enables two-way real-time communication
   between clients and servers.  This document specifies the use of
   Binary Floor Control Protocol (BFCP) as a new WebSocket subprotocol
   enabling a reliable transport mechanism between BFCP entities in new
   scenarios.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="/doc/html/rfc7841#section-2">Section&nbsp;2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8857">https://www.rfc-editor.org/info/rfc8857</a>.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
     2.1.  Definitions
   3.  The WebSocket Protocol
   4.  The WebSocket BFCP Subprotocol
     4.1.  Handshake
     4.2.  BFCP Encoding
   5.  Transport Reliability
   6.  SDP Considerations
     6.1.  Transport Negotiation
     6.2.  SDP Media Attributes
   7.  SDP Offer/Answer Procedures
     7.1.  General
     7.2.  Example Usage of &#x27;websocket-uri&#x27; SDP Attribute
   8.  Authentication
   9.  Security Considerations
   10. IANA Considerations
     10.1.  Registration of the WebSocket BFCP Subprotocol
     10.2.  Registration of the &#x27;TCP/WS/BFCP&#x27; and &#x27;TCP/WSS/BFCP&#x27; SDP
            &quot;proto&quot; Values
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Acknowledgements
   Authors&#x27; Addresses

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   The WebSocket (WS) protocol [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>] enables two-way message
   exchange between clients and servers on top of a persistent TCP
   connection, optionally secured with Transport Layer Security (TLS)
   [<a href="/doc/html/rfc8446" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.3&quot;">RFC8446</a>].  The initial protocol handshake makes use of Hypertext
   Transfer Protocol (HTTP) [<a href="/doc/html/rfc7230" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>] semantics, allowing the WebSocket
   protocol to reuse existing HTTP infrastructure.

   The Binary Floor Control Protocol (BFCP) is a protocol to coordinate
   access to shared resources in a conference.  It is defined in
   [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>] and is used between floor participants and floor control
   servers, and between floor chairs (i.e., moderators) and floor
   control servers.

   Modern web browsers include a WebSocket client stack complying with
   the WebSocket API [<a href="#ref-WS-API" title="&quot;The WebSocket API&quot;">WS-API</a>] as specified by the W3C.  It is expected
   that other client applications (those running in personal computers
   and devices such as smartphones) will also make a WebSocket client
   stack available.  This document extends the applicability of
   [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>] and [<a href="/doc/html/rfc8856" title="&quot;Session Description Protocol (SDP) Format for Binary Floor Control Protocol (BFCP) Streams&quot;">RFC8856</a>] to enable the usage of BFCP in these
   scenarios.

   The transport over which BFCP entities exchange messages depends on
   how the clients obtain information to contact the floor control
   server (e.g., using a Session Description Protocol (SDP) offer/answer
   exchange per [<a href="/doc/html/rfc8856" title="&quot;Session Description Protocol (SDP) Format for Binary Floor Control Protocol (BFCP) Streams&quot;">RFC8856</a>] or the procedure described in <a href="/doc/html/rfc5018">RFC 5018</a>
   [<a href="/doc/html/rfc5018" title="&quot;Connection Establishment in the Binary Floor Control Protocol (BFCP)&quot;">RFC5018</a>]).  [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>] defines two transports for BFCP: TCP and UDP.
   This specification defines a new WebSocket subprotocol (as defined in
   <a href="/doc/html/rfc6455#section-1.9">Section&nbsp;1.9 of [RFC6455]</a>) for transporting BFCP messages between a
   WebSocket client and server.  This subprotocol provides a reliable
   and boundary-preserving transport for BFCP when run on top of TCP.
   Since WebSocket provides a reliable transport, the extensions defined
   in [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>] for sending BFCP over unreliable transports are not
   applicable.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Terminology</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="/doc/html/bcp14">BCP</a>
   <a href="/doc/html/bcp14">14</a> [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="/doc/html/rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h3"><a class="selflink" id="section-2.1" href="#section-2.1">2.1</a>.  Definitions</span>

   BFCP WebSocket Client:  Any BFCP entity capable of opening outbound
         connections to WebSocket servers and communicating using the
         WebSocket BFCP subprotocol as defined by this document.

   BFCP WebSocket Server:  Any BFCP entity capable of listening for
         inbound connections from WebSocket clients and communicating
         using the WebSocket BFCP subprotocol as defined by this
         document.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  The WebSocket Protocol</span>

   The WebSocket protocol [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>] is a transport layer on top of TCP
   (optionally secured with TLS [<a href="/doc/html/rfc8446" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.3&quot;">RFC8446</a>]) in which both client and
   server exchange message units in both directions.  The protocol
   defines a connection handshake, WebSocket subprotocol and extensions
   negotiation, a frame format for sending application and control data,
   a masking mechanism, and status codes for indicating disconnection
   causes.

   The WebSocket connection handshake is based on HTTP [<a href="/doc/html/rfc7230" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>] and
   utilizes the HTTP GET method with an Upgrade header field.  This is
   sent by the client and then answered by the server (if the
   negotiation succeeded) with an HTTP 101 status code.  Once the
   handshake is completed, the connection upgrades from HTTP to the
   WebSocket protocol.  This handshake procedure is designed to reuse
   the existing HTTP infrastructure.  During the connection handshake,
   the client and server agree on the application protocol to use on top
   of the WebSocket transport.  Such an application protocol (also known
   as a &quot;WebSocket subprotocol&quot;) defines the format and semantics of the
   messages exchanged by the endpoints.  This could be a custom protocol
   or a standardized one (as the WebSocket BFCP subprotocol defined in
   this document).  Once the HTTP 101 response is processed, both the
   client and server reuse the underlying TCP connection for sending
   WebSocket messages and control frames to each other.  Unlike plain
   HTTP, this connection is persistent and can be used for multiple
   message exchanges.

   The WebSocket protocol defines message units to be used by
   applications for the exchange of data, so it provides a message
   boundary-preserving transport layer.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  The WebSocket BFCP Subprotocol</span>

   The term WebSocket subprotocol refers to an application-level
   protocol layered on top of a WebSocket connection.  This document
   specifies the WebSocket BFCP subprotocol for carrying BFCP messages
   over a WebSocket connection.

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>.  Handshake</span>

   The BFCP WebSocket client and BFCP WebSocket server negotiate usage
   of the WebSocket BFCP subprotocol during the WebSocket handshake
   procedure as defined in <a href="/doc/html/rfc6455#section-1.3">Section&nbsp;1.3 of [RFC6455]</a>.  The client MUST
   include the value &quot;bfcp&quot; in the Sec-WebSocket-Protocol header field
   in its handshake request.  The 101 reply from the server MUST contain
   &quot;bfcp&quot; in its corresponding Sec-WebSocket-Protocol header field.

   Below is an example of a WebSocket handshake in which the client
   requests the WebSocket BFCP subprotocol support from the server:

     GET / HTTP/1.1
     Host: bfcp-ws.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Origin: http://www.example.com
     Sec-WebSocket-Protocol: bfcp
     Sec-WebSocket-Version: 13

   The handshake response from the server accepting the WebSocket BFCP
   subprotocol would look as follows:

     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
     Sec-WebSocket-Protocol: bfcp

   Once the negotiation has been completed, the WebSocket connection is
   established and can be used for the transport of BFCP messages.

<span class="h3"><a class="selflink" id="section-4.2" href="#section-4.2">4.2</a>.  BFCP Encoding</span>

   BFCP messages use a TLV (Type-Length-Value) binary encoding,
   therefore BFCP WebSocket clients and BFCP WebSocket servers MUST be
   transported in unfragmented binary WebSocket frames (FIN: 1, opcode:
   %x2) to exchange BFCP messages.  The WebSocket frame data MUST be a
   valid BFCP message, so the length of the payload of the WebSocket
   frame MUST be lower than the maximum size allowed (2^(16) +12 bytes)
   for a BFCP message as described in [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>].  In addition, the
   encoding rules for reliable protocols defined in [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>] MUST be
   followed.

   While this specification assumes that BFCP encoding is only TLV
   binary, future documents may define other mechanisms, like JSON
   serialization.  If encoding changes, a new subprotocol identifier
   would need to be selected.

   Each BFCP message MUST be carried within a single WebSocket message,
   and a WebSocket message MUST NOT contain more than one BFCP message.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Transport Reliability</span>

   The WebSocket protocol [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>] provides a reliable transport, and
   therefore the BFCP WebSocket subprotocol defined by this document
   also provides reliable BFCP transport.  Thus, client and server
   transactions using the WebSocket protocol for transport MUST follow
   the procedures for reliable transports as defined in [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>] and
   [<a href="/doc/html/rfc8856" title="&quot;Session Description Protocol (SDP) Format for Binary Floor Control Protocol (BFCP) Streams&quot;">RFC8856</a>].

   BFCP WebSocket clients cannot receive incoming WebSocket connections
   initiated by any other peer.  This means that a BFCP WebSocket client
   MUST actively initiate a connection towards a BFCP WebSocket server.
   The BFCP server will have a globally routable address and thus does
   not require ICE, as clients always initiate connections to it.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  SDP Considerations</span>

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Transport Negotiation</span>

   Rules to generate an &quot;m=&quot; line for a BFCP stream are described in
   <a href="/doc/html/rfc8856#section-4">[RFC8856], Section&nbsp;4</a>.

   New values are defined for the SDP &quot;proto&quot; field: &#x27;TCP/WS/BFCP&#x27; and
   &#x27;TCP/WSS/BFCP&#x27;.

      &#x27;TCP/WS/BFCP&#x27; is used when BFCP runs on top of WS, which in turn
      runs on top of TCP.

      &#x27;TCP/WSS/BFCP&#x27; is used when BFCP runs on top of secure WebSocket
      (WSS), which in turn runs on top of TLS and TCP.

   The &quot;port&quot; field is set following the rules in <a href="#section-4">Section 4</a> and
   <a href="/doc/html/rfc8856#section-7.1">Section&nbsp;7.1 of [RFC8856]</a>.  Depending on the value of the SDP &#x27;setup&#x27;
   attribute defined in [<a href="/doc/html/rfc4145" title="&quot;TCP-Based Media Transport in the Session Description Protocol (SDP)&quot;">RFC4145</a>], the &quot;port&quot; field contains the port to
   which the remote endpoint will direct BFCP messages, or it is
   irrelevant (i.e., the endpoint will initiate the connection towards
   the remote endpoint) and should be set to a value of &#x27;9&#x27;, which is
   the discard port.  The &#x27;connection&#x27; attribute and port MUST follow
   the rules of [<a href="/doc/html/rfc4145" title="&quot;TCP-Based Media Transport in the Session Description Protocol (SDP)&quot;">RFC4145</a>].

   While this document recommends the use of secure WebSocket (i.e.,
   TCP/WSS) for security reasons, TCP/WS is also permitted so as to
   achieve maximum compatibility among clients.

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  SDP Media Attributes</span>

   [<a id="ref-RFC8124">RFC8124</a>] defines a new SDP attribute to indicate the connection
   Uniform Resource Identifier (URI) for the WebSocket client.  The SDP
   attribute &#x27;websocket-uri&#x27; defined in <a href="/doc/html/rfc8124#section-3">Section&nbsp;3 of [RFC8124]</a> MUST be
   used when BFCP runs on top of WS or WSS.  When the &#x27;websocket-uri&#x27;
   attribute is present in the media section of the SDP, the procedures
   mentioned in <a href="/doc/html/rfc8124#section-4">Section&nbsp;4 of [RFC8124]</a> MUST be followed.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  SDP Offer/Answer Procedures</span>

<span class="h3"><a class="selflink" id="section-7.1" href="#section-7.1">7.1</a>.  General</span>

   An endpoint (i.e., both the offerer and the answerer) MUST create an
   SDP media description (&quot;m=&quot; line) for each BFCP-over-WebSocket media
   stream and MUST assign either a &#x27;TCP/WSS/BFCP&#x27; or &#x27;TCP/WS/BFCP&#x27; value
   to the &quot;proto&quot; field of the &quot;m=&quot; line depending on whether the
   endpoint wishes to use secure WebSocket or WebSocket.  Furthermore,
   the server side, which could be either the offerer or answerer, MUST
   add a &#x27;websocket-uri&#x27; attribute in the media section depending on
   whether it wishes to use WebSocket or secure WebSocket.  This new
   attribute MUST follow the syntax defined in [<a href="/doc/html/rfc8124" title="&quot;The Session Description Protocol (SDP) WebSocket Connection URI Attribute&quot;">RFC8124</a>].  Additionally,
   the SDP offer/answer procedures defined in <a href="/doc/html/rfc8124#section-4">Section&nbsp;4 of [RFC8124]</a>
   MUST be followed for the &quot;m=&quot; line associated with a BFCP-over-
   WebSocket media stream.

<span class="h3"><a class="selflink" id="section-7.2" href="#section-7.2">7.2</a>.  Example Usage of &#x27;websocket-uri&#x27; SDP Attribute</span>

   The following is an example of an &quot;m=&quot; line for a BFCP connection.
   In this example, the offerer sends the SDP with the &quot;proto&quot; field
   having a value of &#x27;TCP/WSS/BFCP&#x27;, indicating that the offerer wishes
   to use secure WebSocket as a transport for the media stream, and the
   &quot;fmt&quot; field having a value of &#x27;*&#x27; (for details on the &quot;fmt&quot; field,
   see <a href="/doc/html/rfc8856#section-4">Section&nbsp;4 of [RFC8856]</a>).

   Offer (browser):
   m=application 9 TCP/WSS/BFCP *
   a=setup:active
   a=connection:new
   a=floorctrl:c-only
   m=audio 55000 RTP/AVP 0
   m=video 55002 RTP/AVP 31

   Answer (server):
   m=application 50000 TCP/WSS/BFCP *
   a=setup:passive
   a=connection:new
   a=websocket-uri:wss://bfcp-ws.example.com?token=3170449312
   a=floorctrl:s-only
   a=confid:4321
   a=userid:1234
   a=floorid:1 m-stream:10
   a=floorid:2 m-stream:11
   m=audio 50002 RTP/AVP 0
   a=label:10
   m=video 50004 RTP/AVP 31
   a=label:11

   It is possible that an endpoint (e.g., a browser) sends an offerless
   INVITE to the server.  In such cases, the server will act as SDP
   offerer.  The server MUST assign the SDP &#x27;setup&#x27; attribute with a
   value of &#x27;passive&#x27;.  The server MUST have a &#x27;websocket-uri&#x27; attribute
   with a &#x27;ws-URI&#x27; or &#x27;wss-URI&#x27; value depending on whether the server
   wishes to use WebSocket or secure WebSocket.  This attribute MUST
   follow the syntax defined in <a href="/doc/html/rfc8124#section-3">Section&nbsp;3 of [RFC8124]</a>.  For BFCP
   application, the &quot;proto&quot; value in the &quot;m=&quot; line MUST be &#x27;TCP/WSS/
   BFCP&#x27; if WebSocket is over TLS, else it MUST be &#x27;TCP/WS/BFCP&#x27;.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  Authentication</span>

   <a href="/doc/html/rfc8855#section-9">Section&nbsp;9 of [RFC8855]</a> states that BFCP clients and floor control
   servers SHOULD authenticate each other prior to accepting messages,
   and RECOMMENDS that mutual TLS/DTLS authentication be used.  However,
   browser-based WebSocket clients have no control over the use of TLS
   in the WebSocket API [<a href="#ref-WS-API" title="&quot;The WebSocket API&quot;">WS-API</a>], so it is RECOMMENDED that standard
   web-based methods for client and server authentication are used, as
   follows.

   When a BFCP WebSocket client connects to a BFCP WebSocket server, it
   SHOULD use TCP/WSS as its transport.  If the signaling or control
   protocol traffic used to set up the conference is authenticated and
   confidentiality and integrity protected, secure WebSocket (WSS) MUST
   be used, and the floor control server MUST authenticate the client.
   The WebSocket client MUST follow the procedures in [<a href="/doc/html/rfc7525" title="&quot;Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&quot;">RFC7525</a>] while
   setting up TLS connection with the WebSocket server.  The BFCP client
   validates the server by means of verifying the server certificate.
   This means the &#x27;websocket-uri&#x27; value MUST contain a hostname.  The
   verification process does not use &quot;a=fingerprint&quot;.

   A floor control server that receives a message over TCP/WS can
   mandate the use of TCP/WSS by generating an Error message, as
   described in <a href="/doc/html/rfc8855#section-13.8">Section&nbsp;13.8 of [RFC8855]</a>, with an error code with a
   value of 9 (Use TLS).

   Prior to sending BFCP requests, a BFCP WebSocket client connects to a
   BFCP WebSocket server and performs the connection handshake.  As
   described in <a href="#section-4.1">Section 4.1</a>, the handshake procedure involves an HTTP
   GET method request from the client and a response from the server
   including an HTTP 101 status code.

   In order to authorize the WebSocket connection, the BFCP WebSocket
   server SHOULD inspect any cookie header fields [<a href="/doc/html/rfc6265" title="&quot;HTTP State Management Mechanism&quot;">RFC6265</a>] present in
   the HTTP GET request.  For many web applications, the value of such a
   cookie is provided by the web server once the user has authenticated
   themselves to the web server, which could be done by many existing
   mechanisms.  As an alternative method, the BFCP WebSocket server
   could request HTTP authentication by replying to the client&#x27;s GET
   method request with an HTTP 401 status code.  The WebSocket protocol
   [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>] covers this usage in <a href="#section-4.1">Section 4.1</a>:

      If the status code received from the server is not 101, the
      WebSocket client stack handles the response per HTTP [<a href="/doc/html/rfc7230" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>]
      procedures; in particular, the client might perform authentication
      if it receives an 401 status code.  The WebSocket clients are
      vulnerable to the attacks of basic authentication (mentioned in
      <a href="/doc/html/rfc7617#section-4">Section&nbsp;4 of [RFC7617]</a>) and digest authentication (mentioned in
      <a href="/doc/html/rfc7616#section-5">Section&nbsp;5 of [RFC7616]</a>).  To overcome some of these weaknesses,
      WebSocket clients can use the HTTP Origin-Bound Authentication
      (HOBA) mechanism mentioned in [<a href="/doc/html/rfc7486" title="&quot;HTTP Origin- Bound Authentication (HOBA)&quot;">RFC7486</a>], for example.

<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>.  Security Considerations</span>

   Considerations from [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>], [<a href="/doc/html/rfc8856" title="&quot;Session Description Protocol (SDP) Format for Binary Floor Control Protocol (BFCP) Streams&quot;">RFC8856</a>], and [<a href="/doc/html/rfc5018" title="&quot;Connection Establishment in the Binary Floor Control Protocol (BFCP)&quot;">RFC5018</a>] apply.

   BFCP relies on lower-layer security mechanisms to provide replay and
   integrity protection and confidentiality.  It is RECOMMENDED that the
   BFCP traffic transported over WebSocket be protected by using a
   Secure WebSocket connection (using TLS [<a href="/doc/html/rfc8446" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.3&quot;">RFC8446</a>] over TCP).  The
   security considerations in [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>] apply for BFCP over WebSocket as
   well.  The security model here is a typical webserver-client model
   where the client validates the server certificate and then connects
   to the server.  <a href="#section-8">Section 8</a> describes the authentication procedures
   between client and server.

   When using BFCP over WebSocket, the security mechanisms defined in
   [<a href="/doc/html/rfc8855" title="&quot;The Binary Floor Control Protocol (BFCP)&quot;">RFC8855</a>] are not used.  Instead, the application is required to
   build and rely on the security mechanisms in [<a href="/doc/html/rfc6455" title="&quot;The WebSocket Protocol&quot;">RFC6455</a>].

   The rest of this section analyses the threats described in <a href="/doc/html/rfc8855#section-14">Section&nbsp;14
   of [RFC8855]</a> when WebSocket is used as a transport protocol for BFCP.

   An attacker attempting to impersonate a floor control server is
   avoided by having servers accept BFCP messages over WSS only.  As
   with any other web connection, the clients will verify the server&#x27;s
   certificate.  The BFCP WebSocket client MUST follow the procedures in
   [<a href="/doc/html/rfc7525" title="&quot;Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&quot;">RFC7525</a>] (including hostname verification as per <a href="/doc/html/rfc7525#section-6.1">Section&nbsp;6.1 of
   [RFC7525]</a>) while setting up a TLS connection with floor control
   WebSocket server.

   An attacker attempting to impersonate a floor control client is
   avoided by having servers accept BFCP messages over WSS only.  As
   described in <a href="/doc/html/rfc6455#section-10.5">Section&nbsp;10.5 of [RFC6455]</a> the floor control server can
   use any client authentication mechanism and follow the steps in
   <a href="#section-8">Section 8</a> of this document.

   Attackers may attempt to modify messages exchanged by a client and a
   floor control server.  This can be prevented by having WSS between
   client and server.

   An attacker trying to replay the messages is prevented by having
   floor control servers check that messages arriving over a given WSS
   connection use an authorized user ID.

   Attackers may eavesdrop on the network to get access to confidential
   information between the floor control server and a client (e.g., why
   a floor request was denied).  In order to ensure that BFCP users are
   getting the level of protection that they would get using BFCP
   directly, applications need to have a way to control the WebSocket
   libraries to use encryption algorithms specified in <a href="/doc/html/rfc8855#section-7">Section&nbsp;7 of
   [RFC8855]</a>.  Since the WebSocket API [<a href="#ref-WS-API" title="&quot;The WebSocket API&quot;">WS-API</a>] does not have a way to
   allow an application to select the encryption algorithm to be used,
   the protection level provided when WSS is used is limited to the
   underlying TLS algorithm used by the WebSocket library.

<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>.  IANA Considerations</span>

<span class="h3"><a class="selflink" id="section-10.1" href="#section-10.1">10.1</a>.  Registration of the WebSocket BFCP Subprotocol</span>

   IANA has registered the WebSocket BFCP subprotocol under the
   &quot;WebSocket Subprotocol Name Registry&quot; as follows:

   Subprotocol Identifier:  bfcp

   Subprotocol Common Name:  WebSocket Transport for BFCP (Binary Floor
      Control Protocol)

   Subprotocol Definition:  <a href="/doc/html/rfc8857">RFC 8857</a>

<span class="h3"><a class="selflink" id="section-10.2" href="#section-10.2">10.2</a>.  Registration of the &#x27;TCP/WS/BFCP&#x27; and &#x27;TCP/WSS/BFCP&#x27; SDP &quot;proto&quot;</span>
<span class="h3">       Values</span>

   This document defines two new values for the SDP &quot;proto&quot; subregistry
   within the &quot;Session Description Protocol (SDP) Parameters&quot; registry.
   The resulting entries are shown in Table 1:

                       +==============+===========+
                       | Value        | Reference |
                       +==============+===========+
                       | TCP/WS/BFCP  | <a href="/doc/html/rfc8857">RFC 8857</a>  |
                       +--------------+-----------+
                       | TCP/WSS/BFCP | <a href="/doc/html/rfc8857">RFC 8857</a>  |
                       +--------------+-----------+

                         Table 1: Values for the
                            SDP &quot;proto&quot; Field

<span class="h2"><a class="selflink" id="section-11" href="#section-11">11</a>.  References</span>

<span class="h3"><a class="selflink" id="section-11.1" href="#section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC4145">RFC4145</a>]  Yon, D. and G. Camarillo, &quot;TCP-Based Media Transport in
              the Session Description Protocol (SDP)&quot;, <a href="/doc/html/rfc4145">RFC 4145</a>,
              DOI 10.17487/RFC4145, September 2005,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4145">https://www.rfc-editor.org/info/rfc4145</a>&gt;.

   [<a id="ref-RFC5018">RFC5018</a>]  Camarillo, G., &quot;Connection Establishment in the Binary
              Floor Control Protocol (BFCP)&quot;, <a href="/doc/html/rfc5018">RFC 5018</a>,
              DOI 10.17487/RFC5018, September 2007,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5018">https://www.rfc-editor.org/info/rfc5018</a>&gt;.

   [<a id="ref-RFC6455">RFC6455</a>]  Fette, I. and A. Melnikov, &quot;The WebSocket Protocol&quot;,
              <a href="/doc/html/rfc6455">RFC 6455</a>, DOI 10.17487/RFC6455, December 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6455">https://www.rfc-editor.org/info/rfc6455</a>&gt;.

   [<a id="ref-RFC7525">RFC7525</a>]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              &quot;Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)&quot;, <a href="/doc/html/bcp195">BCP 195</a>, <a href="/doc/html/rfc7525">RFC 7525</a>, DOI 10.17487/RFC7525, May
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7525">https://www.rfc-editor.org/info/rfc7525</a>&gt;.

   [<a id="ref-RFC8124">RFC8124</a>]  Ravindranath, R. and G. Salgueiro, &quot;The Session
              Description Protocol (SDP) WebSocket Connection URI
              Attribute&quot;, <a href="/doc/html/rfc8124">RFC 8124</a>, DOI 10.17487/RFC8124, March 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8124">https://www.rfc-editor.org/info/rfc8124</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in <a href="/doc/html/rfc2119">RFC</a>
              <a href="/doc/html/rfc2119">2119</a> Key Words&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-RFC8855">RFC8855</a>]  Camarillo, G., Drage, K., Kristensen, T., Ott, J., and C.
              Eckel, &quot;The Binary Floor Control Protocol (BFCP)&quot;,
              <a href="/doc/html/rfc8855">RFC 8855</a>, DOI 10.17487/RFC8855, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8855">https://www.rfc-editor.org/info/rfc8855</a>&gt;.

   [<a id="ref-RFC8856">RFC8856</a>]  Camarillo, G., Kristensen, T., and C. Holmberg, &quot;Session
              Description Protocol (SDP) Format for Binary Floor Control
              Protocol (BFCP) Streams&quot;, <a href="/doc/html/rfc8856">RFC 8856</a>, DOI 10.17487/RFC8856,
              January 2021, &lt;<a href="https://www.rfc-editor.org/info/rfc8856">https://www.rfc-editor.org/info/rfc8856</a>&gt;.

<span class="h3"><a class="selflink" id="section-11.2" href="#section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-RFC6265">RFC6265</a>]  Barth, A., &quot;HTTP State Management Mechanism&quot;, <a href="/doc/html/rfc6265">RFC 6265</a>,
              DOI 10.17487/RFC6265, April 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.

   [<a id="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              <a href="/doc/html/rfc7230">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.

   [<a id="ref-RFC7486">RFC7486</a>]  Farrell, S., Hoffman, P., and M. Thomas, &quot;HTTP Origin-
              Bound Authentication (HOBA)&quot;, <a href="/doc/html/rfc7486">RFC 7486</a>,
              DOI 10.17487/RFC7486, March 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7486">https://www.rfc-editor.org/info/rfc7486</a>&gt;.

   [<a id="ref-RFC7616">RFC7616</a>]  Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, &quot;HTTP
              Digest Access Authentication&quot;, <a href="/doc/html/rfc7616">RFC 7616</a>,
              DOI 10.17487/RFC7616, September 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7616">https://www.rfc-editor.org/info/rfc7616</a>&gt;.

   [<a id="ref-RFC7617">RFC7617</a>]  Reschke, J., &quot;The &#x27;Basic&#x27; HTTP Authentication Scheme&quot;,
              <a href="/doc/html/rfc7617">RFC 7617</a>, DOI 10.17487/RFC7617, September 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7617">https://www.rfc-editor.org/info/rfc7617</a>&gt;.

   [<a id="ref-RFC8446">RFC8446</a>]  Rescorla, E., &quot;The Transport Layer Security (TLS) Protocol
              Version 1.3&quot;, <a href="/doc/html/rfc8446">RFC 8446</a>, DOI 10.17487/RFC8446, August 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;.

   [<a id="ref-WS-API">WS-API</a>]   Hickson, I., Ed., &quot;The WebSocket API&quot;, W3C Candidate
              Recommendation, September 2012,
              &lt;<a href="https://www.w3.org/TR/2012/CR-websockets-20120920/">https://www.w3.org/TR/2012/CR-websockets-20120920/</a>&gt;.

Acknowledgements

   The authors want to thank Robert Welbourn from Acme Packet and Sergio
   Garcia Murillo, who made significant contributions to the first draft
   version of this document.  This work benefited from the thorough
   review and constructive comments of Charles Eckel, Christer Holmberg,
   Paul Kyzivat, Dan Wing, and Alissa Cooper.  Thanks to Bert Wijnen,
   Robert Sparks, and Mirja K√ºhlewind for their reviews and comments on
   this document.

   Thanks to Spencer Dawkins, Ben Campbell, Kathleen Moriarty, Alexey
   Melnikov, Jari Arkko, and Stephen Farrell for their feedback and
   comments during IESG reviews.

Authors&#x27; Addresses

   Victor Pascual
   Nokia
   Barcelona
   Spain

   Email: victor.pascual_avila@nokia.com


   Ant√≥n Rom√°n
   Quobis
   Pol. Ind. A Granxa, Casa de Pedra
   36475 O Porri√±o
   Spain

   Email: anton.roman@quobis.com


   St√©phane Cazeaux
   Orange
   42 rue des Coutures
   14000 Caen
   France

   Email: stephane.cazeaux@orange.com


   Gonzalo Salgueiro
   Cisco Systems, Inc.
   7200-12 Kit Creek Road
   Research Triangle Park, NC 27709
   United States of America

   Email: gsalguei@cisco.com


   Ram Mohan Ravindranath
   Cisco Systems, Inc.
   Cessna Business Park
   Kadabeesanahalli Village, Varthur Hobli,
   Sarjapur-Marathahalli Outer Ring Road
   Bangalore 560103
   Karnataka
   India

   Email: rmohanr@cisco.com
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

