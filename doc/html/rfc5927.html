<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc5927
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-tcpm-icmp-attacks/">
  <meta name="description" content="ICMP Attacks against TCP (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgorange"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc5927.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc5927.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc5927.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc5927/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc5927/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/tcpm/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-tcpm-icmp-attacks@ietf.org?subject=draft-ietf-tcpm-icmp-attacks" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-tcpm-icmp-attacks-12.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-tcpm-icmp-attacks-12.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-tcpm-icmp-attacks-12.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-tcpm-icmp-attacks-12">draft-ietf-tcpm-icmp-attacks-12</a>                      Informational</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                           F. Gont
Request for Comments: 5927                                       UTN/FRH
Category: Informational                                        July 2010
ISSN: 2070-1721


                        <span class="h1">ICMP Attacks against TCP</span>

Abstract

   This document discusses the use of the Internet Control Message
   Protocol (ICMP) to perform a variety of attacks against the
   Transmission Control Protocol (TCP).  Additionally, this document
   describes a number of widely implemented modifications to TCP&#x27;s
   handling of ICMP error messages that help to mitigate these issues.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="/doc/html/rfc5741#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc5927">http://www.rfc-editor.org/info/rfc5927</a>.




















<span class="grey">Gont                          Informational                     [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

























<span class="grey">Gont                          Informational                     [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Background . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-2.1">2.1</a>.  The Internet Control Message Protocol (ICMP) . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-2.1.1">2.1.1</a>.  ICMP for IP version 4 (ICMPv4) . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-2.1.2">2.1.2</a>.  ICMP for IP version 6 (ICMPv6) . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-2.2">2.2</a>.  Handling of ICMP Error Messages  . . . . . . . . . . . . .  <a href="#page-6">6</a>
     2.3.  Handling of ICMP Error Messages in the Context of IPsec  .  7
   <a href="#section-3">3</a>.  Constraints in the Possible Solutions  . . . . . . . . . . . .  <a href="#page-8">8</a>
   <a href="#section-4">4</a>.  General Counter-Measures against ICMP Attacks  . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-4.1">4.1</a>.  TCP Sequence Number Checking . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-4.2">4.2</a>.  Port Randomization . . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
     4.3.  Filtering ICMP Error Messages Based on the ICMP Payload  . 11
   <a href="#section-5">5</a>.  Blind Connection-Reset Attack  . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-5.1">5.1</a>.  Description  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-5.2">5.2</a>.  Attack-Specific Counter-Measures . . . . . . . . . . . . . <a href="#page-13">13</a>
   <a href="#section-6">6</a>.  Blind Throughput-Reduction Attack  . . . . . . . . . . . . . . <a href="#page-16">16</a>
     <a href="#section-6.1">6.1</a>.  Description  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
     <a href="#section-6.2">6.2</a>.  Attack-Specific Counter-Measures . . . . . . . . . . . . . <a href="#page-16">16</a>
   <a href="#section-7">7</a>.  Blind Performance-Degrading Attack . . . . . . . . . . . . . . <a href="#page-16">16</a>
     <a href="#section-7.1">7.1</a>.  Description  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
     <a href="#section-7.2">7.2</a>.  Attack-Specific Counter-Measures . . . . . . . . . . . . . <a href="#page-18">18</a>
     <a href="#section-7.3">7.3</a>.  The Counter-Measure for the PMTUD Attack in Action . . . . <a href="#page-22">22</a>
       <a href="#section-7.3.1">7.3.1</a>.  Normal Operation for Bulk Transfers  . . . . . . . . . <a href="#page-22">22</a>
       <a href="#section-7.3.2">7.3.2</a>.  Operation during Path-MTU Changes  . . . . . . . . . . <a href="#page-24">24</a>
       <a href="#section-7.3.3">7.3.3</a>.  Idle Connection Being Attacked . . . . . . . . . . . . <a href="#page-25">25</a>
       7.3.4.  Active Connection Being Attacked after Discovery
               of the Path-MTU  . . . . . . . . . . . . . . . . . . . <a href="#page-26">26</a>
       7.3.5.  TCP Peer Attacked when Sending Small Packets Just
               after the Three-Way Handshake  . . . . . . . . . . . . <a href="#page-26">26</a>
     7.4.  Pseudo-Code for the Counter-Measure for the Blind
           Performance-Degrading Attack . . . . . . . . . . . . . . . <a href="#page-27">27</a>
   <a href="#section-8">8</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-30">30</a>
   <a href="#section-9">9</a>.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-32">32</a>
   <a href="#section-10">10</a>. References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-32">32</a>
     <a href="#section-10.1">10.1</a>. Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-32">32</a>
     <a href="#section-10.2">10.2</a>. Informative References . . . . . . . . . . . . . . . . . . <a href="#page-33">33</a>













<span class="grey">Gont                          Informational                     [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   ICMP [<a href="/doc/html/rfc0792" title="&quot;Internet Control Message Protocol&quot;">RFC0792</a>] [<a href="/doc/html/rfc4443" title="&quot;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification&quot;">RFC4443</a>] is a fundamental part of the TCP/IP protocol
   suite, and is used mainly for reporting network error conditions.
   However, the current specifications do not recommend any kind of
   validation checks on the received ICMP error messages, thus allowing
   a variety of attacks against TCP [<a href="/doc/html/rfc0793" title="&quot;Transmission Control Protocol&quot;">RFC0793</a>] by means of ICMP, which
   include blind connection-reset, blind throughput-reduction, and blind
   performance-degrading attacks.  All of these attacks can be performed
   even when the attacker is off-path, without the need to sniff the
   packets that correspond to the attacked TCP connection.

   While the possible security implications of ICMP have been known in
   the research community for a long time, there has never been an
   official proposal on how to deal with these vulnerabilities.  In
   2005, a disclosure process was carried out by the UK&#x27;s National
   Infrastructure Security Co-ordination Centre (NISCC) (now CPNI,
   Centre for the Protection of National Infrastructure), with the
   collaboration of other computer emergency response teams.  A large
   number of implementations were found vulnerable to either all or a
   subset of the attacks discussed in this document [<a href="#ref-NISCC" title="&quot;NISCC Vulnerability Advisory 532967/NISCC/ ICMP: Vulnerability Issues in ICMP packets with TCP payloads&quot;">NISCC</a>][US-CERT].
   The affected systems ranged from TCP/IP implementations meant for
   desktop computers, to TCP/IP implementations meant for core Internet
   routers.

   It is clear that implementations should be more cautious when
   processing ICMP error messages, to eliminate or mitigate the use of
   ICMP to perform attacks against TCP [<a href="/doc/html/rfc4907" title="&quot;Architectural Implications of Link Indications&quot;">RFC4907</a>].

   This document aims to raise awareness of the use of ICMP to perform a
   variety of attacks against TCP, and discusses several counter-
   measures that eliminate or minimize the impact of these attacks.
   Most of the these counter-measures can be implemented while still
   remaining compliant with the current specifications, as they simply
   describe reasons for not taking the advice provided in the
   specifications in terms of &quot;SHOULDs&quot;, but still comply with the
   requirements stated as &quot;MUSTs&quot;.

   We note that the counter-measures discussed in this document are not
   part of standard TCP behavior, and this document does not change that
   state of affairs.  The consensus of the TCPM WG (TCP Maintenance and
   Minor Extensions Working Group) was to document this widespread
   implementation of nonstandard TCP behavior but to not change the TCP
   standard.

   <a href="#section-2">Section 2</a> provides background information on ICMP.  <a href="#section-3">Section 3</a>
   discusses the constraints in the general counter-measures that can be
   implemented against the attacks described in this document.



<span class="grey">Gont                          Informational                     [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   <a href="#section-4">Section 4</a> describes several general validation checks that can be
   implemented to mitigate any ICMP-based attack.  Finally, <a href="#section-5">Section 5</a>,
   <a href="#section-6">Section 6</a>, and <a href="#section-7">Section 7</a>, discuss a variety of ICMP attacks that can
   be performed against TCP, and describe attack-specific counter-
   measures that eliminate or greatly mitigate their impact.

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in <a href="/doc/html/rfc2119">RFC 2119</a> [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Background</span>

<span class="h3"><a class="selflink" id="section-2.1" href="#section-2.1">2.1</a>.  The Internet Control Message Protocol (ICMP)</span>

   The Internet Control Message Protocol (ICMP) is used in the Internet
   architecture mainly to perform the fault-isolation function, that is,
   the group of actions that hosts and routers take to determine that
   there is some network failure [<a href="/doc/html/rfc0816" title="&quot;Fault isolation and recovery&quot;">RFC0816</a>].

   When an intermediate router detects a network problem while trying to
   forward an IP packet, it will usually send an ICMP error message to
   the source system, to inform the source system of the network problem
   taking place.  In the same way, there are a number of scenarios in
   which an end-system may generate an ICMP error message if it finds a
   problem while processing a datagram.  The received ICMP errors are
   handed to the corresponding transport-protocol instance, which will
   usually perform a fault recovery function.

   It is important to note that ICMP error messages are transmitted
   unreliably and may be discarded due to data corruption, network
   congestion, or rate-limiting.  Thus, while they provide useful
   information, upper-layer protocols cannot depend on ICMP for correct
   operation.

   It should be noted that there are no timeliness requirements for ICMP
   error messages.  ICMP error messages could be delayed for various
   reasons, and at least in theory could be received with an arbitrarily
   long delay.  For example, there are no existing requirements that a
   router flush any queued ICMP error messages when it is rebooted.

<span class="h4"><a class="selflink" id="section-2.1.1" href="#section-2.1.1">2.1.1</a>.  ICMP for IP version 4 (ICMPv4)</span>

   [<a id="ref-RFC0792">RFC0792</a>] specifies the Internet Control Message Protocol (ICMP) to
   be used with the Internet Protocol version 4 (IPv4) -- henceforth
   &quot;ICMPv4&quot;.  It defines, among other things, a number of error messages
   that can be used by end-systems and intermediate systems to report
   errors to the sending system.  The Host Requirements RFC [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>]




<span class="grey">Gont                          Informational                     [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   classifies ICMPv4 error messages into those that indicate &quot;soft
   errors&quot;, and those that indicate &quot;hard errors&quot;, thus roughly defining
   the semantics of them.

   The ICMPv4 specification [<a href="/doc/html/rfc0792" title="&quot;Internet Control Message Protocol&quot;">RFC0792</a>] also defines the ICMPv4 Source
   Quench message (type 4, code 0), which is meant to provide a
   mechanism for flow control and congestion control.

   [<a id="ref-RFC1191">RFC1191</a>] defines a mechanism called &quot;Path MTU Discovery&quot; (PMTUD),
   which makes use of ICMPv4 error messages of type 3 (Destination
   Unreachable), code 4 (fragmentation needed and DF bit set) to allow
   systems to determine the MTU of an arbitrary internet path.

   Finally, [<a href="/doc/html/rfc4884" title="&quot;Extended ICMP to Support Multi-Part Messages&quot;">RFC4884</a>] redefines selected ICMPv4 messages to include an
   extension structure and a length attribute, such that those ICMPv4
   messages can carry additional information by encoding that
   information in the extension structure.

   <a href="/doc/html/rfc4301#appendix-D">Appendix&nbsp;D of [RFC4301]</a> provides information about which ICMPv4 error
   messages are produced by hosts, intermediate routers, or both.

<span class="h4"><a class="selflink" id="section-2.1.2" href="#section-2.1.2">2.1.2</a>.  ICMP for IP version 6 (ICMPv6)</span>

   [<a id="ref-RFC4443">RFC4443</a>] specifies the Internet Control Message Protocol (ICMPv6) to
   be used with the Internet Protocol version 6 (IPv6) [<a href="/doc/html/rfc2460" title="&quot;Internet Protocol, Version 6 (IPv6) Specification&quot;">RFC2460</a>].

   [<a id="ref-RFC4443">RFC4443</a>] defines the &quot;Packet Too Big&quot; (type 2, code 0) error
   message, which is analogous to the ICMPv4 &quot;fragmentation needed and
   DF bit set&quot; (type 3, code 4) error message.  [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>] defines the
   Path MTU Discovery mechanism for IP version 6, which makes use of
   these messages to determine the MTU of an arbitrary internet path.

   Finally, [<a href="/doc/html/rfc4884" title="&quot;Extended ICMP to Support Multi-Part Messages&quot;">RFC4884</a>] redefines selected ICMPv6 messages to include an
   extension structure and a length attribute, such that those ICMPv6
   messages can carry additional information by encoding that
   information in the extension structure.

   <a href="/doc/html/rfc4301#appendix-D">Appendix&nbsp;D of [RFC4301]</a> provides information about which ICMPv6 error
   messages are produced by hosts, intermediate routers, or both.

<span class="h3"><a class="selflink" id="section-2.2" href="#section-2.2">2.2</a>.  Handling of ICMP Error Messages</span>

   The Host Requirements RFC [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] states in <a href="#section-4.2.3.9">Section 4.2.3.9</a> that
   TCP MUST act on an ICMP error message passed up from the IP layer,
   directing it to the connection that triggered the error.






<span class="grey">Gont                          Informational                     [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   In order to allow ICMP messages to be demultiplexed by the receiving
   system, part of the original packet that triggered the message is
   included in the payload of the ICMP error message.  Thus, the
   receiving system can use that information to match the ICMP error to
   the transport protocol instance that triggered it.

   Neither the Host Requirements RFC [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] nor the original TCP
   specification [<a href="/doc/html/rfc0793" title="&quot;Transmission Control Protocol&quot;">RFC0793</a>] recommends any validation checks on the
   received ICMP messages.  Thus, as long as the ICMP payload contains
   the information that identifies an existing communication instance,
   it will be processed by the corresponding transport-protocol
   instance, and the corresponding action will be performed.

   Therefore, in the case of TCP, an attacker could send a crafted ICMP
   error message to the attacked system, and, as long as he is able to
   guess the four-tuple (i.e., Source IP Address, Source TCP port,
   Destination IP Address, and Destination TCP port) that identifies the
   communication instance to be attacked, he will be able to use ICMP to
   perform a variety of attacks.

   Generally, the four-tuple required to perform these attacks is not
   known.  However, as discussed in [<a href="#ref-Watson" title="&quot;Slipping in the Window: TCP Reset Attacks&quot;">Watson</a>] and [<a href="/doc/html/rfc4953" title="&quot;Defending TCP Against Spoofing Attacks&quot;">RFC4953</a>], there are a
   number of scenarios (notably that of TCP connections established
   between two BGP routers [<a href="/doc/html/rfc4271" title="&quot;A Border Gateway Protocol 4 (BGP-4)&quot;">RFC4271</a>]) in which an attacker may be able
   to know or guess the four-tuple that identifies a TCP connection.  In
   such a case, if we assume the attacker knows the two systems involved
   in the TCP connection to be attacked, both the client-side and the
   server-side IP addresses could be known or be within a reasonable
   number of possibilities.  Furthermore, as most Internet services use
   the so-called &quot;well-known&quot; ports, only the client port number might
   need to be guessed.  In such a scenario, an attacker would need to
   send, in principle, at most 65536 packets to perform any of the
   attacks described in this document.  These issues are exacerbated by
   the fact that most systems choose the port numbers they use for
   outgoing connections from a subset of the whole port number space,
   thus reducing the amount of work needed to successfully perform these
   attacks.

   The need to be more cautious when processing received ICMP error
   messages in order to mitigate or eliminate the impact of the attacks
   described in this RFC has been documented by the Internet
   Architecture Board (IAB) in [<a href="/doc/html/rfc4907" title="&quot;Architectural Implications of Link Indications&quot;">RFC4907</a>].

<span class="h3"><a class="selflink" id="section-2.3" href="#section-2.3">2.3</a>.  Handling of ICMP Error Messages in the Context of IPsec</span>

   <a href="/doc/html/rfc4301#section-5.2">Section&nbsp;5.2 of [RFC4301]</a> describes the processing of inbound IP
   traffic in the case of &quot;unprotected-to-protected&quot;.  In the case of
   ICMP, when an unprotected ICMP error message is received, it is



<span class="grey">Gont                          Informational                     [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   matched to the corresponding security association by means of the SPI
   (Security Parameters Index) included in the payload of the ICMP error
   message.  Then, local policy is applied to determine whether to
   accept or reject the message and, if accepted, what action to take as
   a result.  For example, if an ICMP Destination Unreachable message is
   received, the implementation must decide whether to act on it, reject
   it, or act on it with constraints.  <a href="#section-8">Section 8</a> (&quot;Path MTU/DF
   Processing&quot;) discusses the processing of unauthenticated ICMPv4
   &quot;fragmentation needed and DF bit set&quot; (type 3, code 4) and ICMPv6
   &quot;Packet Too Big&quot; (type 2, code 0) messages when an IPsec
   implementation is configured to process (vs. ignore) such messages.

   <a href="/doc/html/rfc4301#section-6.1.1">Section&nbsp;6.1.1 of [RFC4301]</a> notes that processing of unauthenticated
   ICMP error messages may result in denial or degradation of service,
   and therefore it would be desirable to ignore such messages.
   However, it also notes that in many cases, ignoring these ICMP
   messages can degrade service, e.g., because of a failure to process
   PMTUD and redirection messages, and therefore there is also a
   motivation for accepting and acting upon them.  It finally states
   that to accommodate both ends of this spectrum, a compliant IPsec
   implementation MUST permit a local administrator to configure an
   IPsec implementation to accept or reject unauthenticated ICMP
   traffic, and that this control MUST be at the granularity of ICMP
   type and MAY be at the granularity of ICMP type and code.
   Additionally, an implementation SHOULD incorporate mechanisms and
   parameters for dealing with such traffic.

   Thus, the policy to apply for the processing of unprotected ICMP
   error messages is left up to the implementation and administrator.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Constraints in the Possible Solutions</span>

   If a host wants to perform validation checks on the received ICMP
   error messages before acting on them, it is limited by the piece of
   the packet that triggered the error that the sender of the ICMP error
   message chose to include in the ICMP payload.  This constrains the
   possible validation checks, as the number of bytes of the packet that
   triggered the error message that is included in the ICMP payload is
   limited.

   For ICMPv4, [<a href="/doc/html/rfc0792" title="&quot;Internet Control Message Protocol&quot;">RFC0792</a>] states that the IP header plus the first
   64 bits of the packet that triggered the ICMPv4 message are to be
   included in the payload of the ICMPv4 error message.  Thus, it is
   assumed that all data needed to identify a transport protocol
   instance and process the ICMPv4 error message is contained in the
   first 64 bits of the transport protocol header.  <a href="/doc/html/rfc1122#section-3.2.2">Section&nbsp;3.2.2 of
   [RFC1122]</a> states that &quot;the Internet header and at least the first 8
   data octets of the datagram that triggered the error&quot; are to be



<span class="grey">Gont                          Informational                     [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   included in the payload of ICMPv4 error messages, and that &quot;more than
   8 octets MAY be sent&quot;, thus allowing implementations to include more
   data from the original packet than those required by the original
   ICMPv4 specification.  The &quot;Requirements for IP Version 4 Routers&quot;
   RFC [<a href="/doc/html/rfc1812" title="&quot;Requirements for IP Version 4 Routers&quot;">RFC1812</a>] states that ICMPv4 error messages &quot;SHOULD contain as
   much of the original datagram as possible without the length of the
   ICMP datagram exceeding 576 bytes&quot;.

   Thus, for ICMPv4 messages generated by hosts, we can only expect to
   get the entire IP header of the original packet, plus the first
   64 bits of its payload.  For TCP, this means that the only fields
   that will be included in the ICMPv4 payload are the source port
   number, the destination port number, and the 32-bit TCP sequence
   number.  This clearly imposes a constraint on the possible validation
   checks that can be performed, as there is not much information
   available on which to perform them.

   This means, for example, that even if TCP were signing its segments
   by means of the TCP MD5 signature option [<a href="/doc/html/rfc2385" title="&quot;Protection of BGP Sessions via the TCP MD5 Signature Option&quot;">RFC2385</a>], this mechanism
   could not be used as a counter-measure against ICMP-based attacks,
   because, as ICMP messages include only a piece of the TCP segment
   that triggered the error, the MD5 [<a href="/doc/html/rfc1321" title="&quot;The MD5 Message-Digest Algorithm&quot;">RFC1321</a>] signature could not be
   recalculated.  In the same way, even if the attacked peer were
   authenticating its packets at the IP layer [<a href="/doc/html/rfc4301" title="&quot;Security Architecture for the Internet Protocol&quot;">RFC4301</a>], because only a
   part of the original IP packet would be available, the signature used
   for authentication could not be recalculated, and thus the
   authentication header in the original packet could not be used as a
   counter-measure for ICMP-based attacks against TCP.

   [<a id="ref-RFC4884">RFC4884</a>] updated [<a href="/doc/html/rfc0792" title="&quot;Internet Control Message Protocol&quot;">RFC0792</a>] and specified that ICMPv4 Destination
   Unreachable (type 3), Time Exceeded (type 11), and Parameter Problem
   (type 12) messages that have an ICMP Extension Structure appended
   include at least 128 octets in the &quot;original datagram&quot; field.  This
   would improve the situation, but at the time of this writing,
   [<a href="/doc/html/rfc4884" title="&quot;Extended ICMP to Support Multi-Part Messages&quot;">RFC4884</a>] is not yet widely deployed for end-systems.

   For IPv6, the payload of ICMPv6 error messages includes as many
   octets from the IPv6 packet that triggered the ICMPv6 error message
   as will fit without making the resulting ICMPv6 error message exceed
   the minimum IPv6 MTU (1280 octets) [<a href="/doc/html/rfc4443" title="&quot;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification&quot;">RFC4443</a>].  Thus, more information
   is available than in the IPv4 case.

   Hosts could require ICMP error messages to be authenticated
   [<a href="/doc/html/rfc4301" title="&quot;Security Architecture for the Internet Protocol&quot;">RFC4301</a>], in order to act upon them.  However, while this
   requirement could make sense for those ICMP error messages sent by
   hosts, it would not be feasible for those ICMP error messages
   generated by routers, as this would imply either that the attacked
   system should have a security association [<a href="/doc/html/rfc4301" title="&quot;Security Architecture for the Internet Protocol&quot;">RFC4301</a>] with every



<span class="grey">Gont                          Informational                     [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   existing intermediate system, or that it should be able to establish
   one dynamically.  Current levels of deployment of protocols for
   dynamic establishment of security associations makes this unfeasible.
   Additionally, this would require routers to use certificates with
   paths compatible for all hosts on the network.  Finally, there may be
   some scenarios, such as embedded devices, in which the processing
   power requirements of authentication might not allow IPsec
   authentication to be implemented effectively.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  General Counter-Measures against ICMP Attacks</span>

   The following subsections describe a number of mitigation techniques
   that help to eliminate or mitigate the impact of the attacks
   discussed in this document.  Rather than being alternative counter-
   measures, they can be implemented together to increase the protection
   against these attacks.

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>.  TCP Sequence Number Checking</span>

   The current specifications do not impose any validity checks on the
   TCP segment that is contained in the ICMP payload.  For instance, no
   checks are performed to verify that a received ICMP error message has
   been triggered by a segment that was &quot;in flight&quot; to the destination.
   Thus, even stale ICMP error messages will be acted upon.

   Many TCP implementations have incorporated a validation check such
   that they react only to those ICMP error messages that appear to
   relate to segments currently &quot;in flight&quot; to the destination system.
   These implementations check that the TCP sequence number contained in
   the payload of the ICMP error message is within the range
   SND.UNA =&lt; SEG.SEQ &lt; SND.NXT.  This means that they require that the
   sequence number be within the range of the data already sent but not
   yet acknowledged.  If an ICMP error message does not pass this check,
   it is discarded.

   Even if an attacker were able to guess the four-tuple that identifies
   the TCP connection, this additional check would reduce the
   possibility of considering a spoofed ICMP packet as valid to
   Flight_Size/2^^32 (where Flight_Size is the number of data bytes
   already sent to the remote peer, but not yet acknowledged [<a href="/doc/html/rfc5681" title="&quot;TCP Congestion Control&quot;">RFC5681</a>]).
   For connections in the SYN-SENT or SYN-RECEIVED states, this would
   reduce the possibility of considering a spoofed ICMP packet as valid
   to 1/2^^32.  For a TCP endpoint with no data &quot;in flight&quot;, this would
   completely eliminate the possibility of success of these attacks.

   This validation check has been implemented in Linux [<a href="#ref-Linux" title="&quot;http://www.kernel.org&quot;">Linux</a>] for many
   years, in OpenBSD [<a href="#ref-OpenBSD" title="&quot;http://www.openbsd.org&quot;">OpenBSD</a>] since 2004, and in FreeBSD [<a href="#ref-FreeBSD">FreeBSD</a>] and
   NetBSD [<a href="#ref-NetBSD" title="&quot;http://www.netbsd.org&quot;">NetBSD</a>] since 2005.



<span class="grey">Gont                          Informational                    [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   It is important to note that while this check greatly increases the
   number of packets required to perform any of the attacks discussed in
   this document, this may not be enough in those scenarios in which
   bandwidth is easily available and/or large TCP windows [<a href="/doc/html/rfc1323" title="&quot;TCP Extensions for High Performance&quot;">RFC1323</a>] are
   in use.  Additionally, this validation check does not help to prevent
   on-path attacks, that is, attacks performed in scenarios in which the
   attacker can sniff the packets that correspond to the target TCP
   connection.

   It should be noted that, as there are no timeliness requirements for
   ICMP error messages, the TCP Sequence Number check described in this
   section might cause legitimate ICMP error messages to be discarded.
   Also, even if this check is enforced, TCP might end up responding to
   stale ICMP error messages (e.g., if the Sequence Number for the
   corresponding direction of the data transfer wraps around).

<span class="h3"><a class="selflink" id="section-4.2" href="#section-4.2">4.2</a>.  Port Randomization</span>

   As discussed in the previous sections, in order to perform any of the
   attacks described in this document, an attacker would need to guess
   (or know) the four-tuple that identifies the connection to be
   attacked.  Increasing the port number range used for outgoing TCP
   connections, and randomizing the port number chosen for each outgoing
   TCP connection, would make it harder for an attacker to perform any
   of the attacks discussed in this document.

   [<a id="ref-PORT-RANDOM">PORT-RANDOM</a>] recommends that transport protocols randomize the
   ephemeral ports used by clients, and proposes a number of
   randomization algorithms.

<span class="h3"><a class="selflink" id="section-4.3" href="#section-4.3">4.3</a>.  Filtering ICMP Error Messages Based on the ICMP Payload</span>

   The source address of ICMP error messages does not need to be spoofed
   to perform the attacks described in this document, as the ICMP error
   messages might legitimately come from an intermediate system.
   Therefore, simple filtering based on the source address of ICMP error
   messages does not serve as a counter-measure against these attacks.
   However, a more advanced packet filtering can be implemented in
   middlebox devices such as firewalls and NATs.  Middleboxes
   implementing such advanced filtering look at the payload of the ICMP
   error messages, and perform ingress and egress packet filtering based
   on the source address of the IP header contained in the payload of
   the ICMP error message.  As the source address contained in the
   payload of the ICMP error message does need to be spoofed to perform
   the attacks described in this document, this kind of advanced
   filtering serves as a counter-measure against these attacks.  As with
   traditional egress filtering [<a href="#ref-IP-filtering" title="&quot;NISCC Technical Note 01/2006: Egress and Ingress Filtering&quot;">IP-filtering</a>], egress filtering based
   on the ICMP payload can help to prevent users of the network being



<span class="grey">Gont                          Informational                    [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   protected by the firewall from successfully performing ICMP attacks
   against TCP connections established between external systems.
   Additionally, ingress filtering based on the ICMP payload can prevent
   TCP connections established between internal systems from being
   attacked by external systems.  [<a href="#ref-ICMP-Filtering" title="&quot;Filtering of ICMP error messages&quot;">ICMP-Filtering</a>] provides examples of
   ICMP filtering based on the ICMP payload.

   This filtering technique has been implemented in OpenBSD&#x27;s Packet
   Filter [<a href="#ref-OpenBSD-PF" title="&quot;http://www.openbsd.org/faq/pf/&quot;">OpenBSD-PF</a>], which has in turn been ported to a number of
   systems, including FreeBSD [<a href="#ref-FreeBSD">FreeBSD</a>].

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Blind Connection-Reset Attack</span>

<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a>.  Description</span>

   When TCP is handed an ICMP error message, it will perform its fault
   recovery function, as follows:

   o  If the network problem being reported is a &quot;hard error&quot;, TCP will
      abort the corresponding connection.

   o  If the network problem being reported is a &quot;soft error&quot;, TCP will
      just record this information, and repeatedly retransmit its data
      until they either get acknowledged, or the connection times out.

   The Host Requirements RFC [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] states (in <a href="#section-4.2.3.9">Section 4.2.3.9</a>) that
   a host SHOULD abort the corresponding connection when receiving an
   ICMPv4 error message that indicates a &quot;hard error&quot;, and states that
   ICMPv4 error messages of type 3 (Destination Unreachable), codes 2
   (protocol unreachable), 3 (port unreachable), and 4 (fragmentation
   needed and DF bit set) should be considered as indicating &quot;hard
   errors&quot;.  In the case of ICMPv4 port unreachables, the specifications
   are ambiguous, as <a href="/doc/html/rfc1122#section-4.2.3.9">Section&nbsp;4.2.3.9 of [RFC1122]</a> states that TCP SHOULD
   abort the corresponding connection in response to them, but
   <a href="#section-3.2.2.1">Section 3.2.2.1</a> of the same RFC ([<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>]) states that TCP MUST
   abort the connection in response to them.

   While [<a href="/doc/html/rfc4443" title="&quot;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification&quot;">RFC4443</a>] did not exist when [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] was published, one could
   extrapolate the concept of &quot;hard errors&quot; to ICMPv6 error messages of
   type 1 (Destination Unreachable), codes 1 (communication with
   destination administratively prohibited), and 4 (port unreachable).

   Thus, an attacker could use ICMP to perform a blind connection-reset
   attack by sending any ICMP error message that indicates a &quot;hard
   error&quot; to either of the two TCP endpoints of the connection.  Because
   of TCP&#x27;s fault recovery policy, the connection would be immediately
   aborted.




<span class="grey">Gont                          Informational                    [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   Some stacks are known to extrapolate ICMP &quot;hard errors&quot; across TCP
   connections, increasing the impact of this attack, as a single ICMP
   packet could bring down all the TCP connections between the
   corresponding peers.

   It is important to note that even if TCP itself were protected
   against the blind connection-reset attack described in [<a href="#ref-Watson" title="&quot;Slipping in the Window: TCP Reset Attacks&quot;">Watson</a>] and
   [<a href="#ref-TCPM-TCPSECURE" title="&quot;Improving TCP&#x27;s Robustness to Blind In-Window Attacks&quot;">TCPM-TCPSECURE</a>] by means of authentication at the network layer
   [<a href="/doc/html/rfc4301" title="&quot;Security Architecture for the Internet Protocol&quot;">RFC4301</a>], by means of the TCP MD5 signature option [<a href="/doc/html/rfc2385" title="&quot;Protection of BGP Sessions via the TCP MD5 Signature Option&quot;">RFC2385</a>], by
   means of the TCP-AO [<a href="/doc/html/rfc5925" title="&quot;The TCP Authentication Option&quot;">RFC5925</a>], or by means of the mechanism specified
   in [<a href="#ref-TCPM-TCPSECURE" title="&quot;Improving TCP&#x27;s Robustness to Blind In-Window Attacks&quot;">TCPM-TCPSECURE</a>], the blind connection-reset attack described in
   this document would still succeed.

<span class="h3"><a class="selflink" id="section-5.2" href="#section-5.2">5.2</a>.  Attack-Specific Counter-Measures</span>

   An analysis of the circumstances in which ICMP messages that indicate
   &quot;hard errors&quot; may be received can shed some light on opportunities to
   mitigate the impact of ICMP-based blind connection-reset attacks.

   ICMPv4 type 3 (Destination Unreachable), code 2 (protocol
      unreachable)

      This ICMP error message indicates that the host sending the ICMP
      error message received a packet meant for a transport protocol it
      does not support.  For connection-oriented protocols such as TCP,
      one could expect to receive such an error as the result of a
      connection-establishment attempt.  However, it would be strange to
      get such an error during the life of a connection, as this would
      indicate that support for that transport protocol has been removed
      from the system sending the error message during the life of the
      corresponding connection.

   ICMPv4 type 3 (Destination Unreachable), code 3 (port unreachable)

      This error message indicates that the system sending the ICMP
      error message received a packet meant for a socket (IP address,
      port number) on which there is no process listening.  Those
      transport protocols that have their own mechanisms for signaling
      this condition should not be receiving these error messages, as
      the protocol would signal the port unreachable condition by means
      of its own mechanisms.  Assuming that once a connection is
      established it is not usual for the transport protocol to change
      (or be reloaded), it should be unusual to get these error
      messages.

   ICMPv4 type 3 (Destination Unreachable), code 4 (fragmentation needed
      and DF bit set)




<span class="grey">Gont                          Informational                    [Page 13]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-14" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


      This error message indicates that an intermediate node needed to
      fragment a datagram, but the DF (Don&#x27;t Fragment) bit in the IP
      header was set.  It is considered a &quot;soft error&quot; when TCP
      implements PMTUD, and a &quot;hard error&quot; if TCP does not implement
      PMTUD.  Those TCP/IP stacks that do not implement PMTUD (or have
      disabled it) but support IP fragmentation/reassembly should not be
      sending their IP packets with the DF bit set, and thus should not
      be receiving these ICMP error messages.  Some TCP/IP stacks that
      do not implement PMTUD and that do not support IP fragmentation/
      reassembly are known to send their packets with the DF bit set,
      and thus could legitimately receive these ICMP error messages.

   ICMPv6 type 1 (Destination Unreachable), code 1 (communication with
      destination administratively prohibited)

      This error message indicates that the destination is unreachable
      because of an administrative policy.  For connection-oriented
      protocols such as TCP, one could expect to receive such an error
      as the result of a connection-establishment attempt.  Receiving
      such an error for a connection in any of the synchronized states
      would mean that the administrative policy changed during the life
      of the connection.  However, in the same way this error condition
      (which was not present when the connection was established)
      appeared, it could get solved in the near term.

   ICMPv6 type 1 (Destination Unreachable), code 4 (port unreachable)

      This error message is analogous to the ICMPv4 type 3 (Destination
      Unreachable), code 3 (port unreachable) error message discussed
      above.  Therefore, the same considerations apply.

   The Host Requirements RFC [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] states in <a href="#section-4.2.3.9">Section 4.2.3.9</a> that
   TCP SHOULD abort the corresponding connection in response to ICMPv4
   messages of type 3 (Destination Unreachable), codes 2 (protocol
   unreachable), 3 (port unreachable), and 4 (fragmentation needed and
   DF bit set).  However, <a href="#section-3.2.2.1">Section 3.2.2.1</a> states that TCP MUST accept an
   ICMPv4 port unreachable (type 3, code 3) for the same purpose as a
   RST.  Therefore, for ICMPv4 messages of type 3, codes 2 and 4, there
   is room to go against the advice provided in the existing
   specifications, while in the case of ICMPv4 messages of type 3,
   code 3, there is ambiguity in the specifications that may or may not
   provide some room to go against that advice.

   Based on this analysis, most popular TCP implementations treat all
   ICMP &quot;hard errors&quot; received for connections in any of the
   synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT,
   CLOSING, LAST-ACK, or TIME-WAIT) as &quot;soft errors&quot;.  That is, they do
   not abort the corresponding connection upon receipt of them.



<span class="grey">Gont                          Informational                    [Page 14]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-15" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   Additionally, they do not extrapolate ICMP errors across TCP
   connections.  This policy is based on the premise that TCP should be
   as robust as possible.  Aborting the connection would be to ignore
   the valuable feature of the Internet -- that for many internal
   failures, it reconstructs its function without any disruption of the
   endpoints [<a href="/doc/html/rfc0816" title="&quot;Fault isolation and recovery&quot;">RFC0816</a>].

   It should be noted that treating ICMP &quot;hard errors&quot; as &quot;soft errors&quot;
   for connections in any of the synchronized states may prevent TCP
   from responding quickly to a legitimate ICMP error message.

   It is interesting to note that, as ICMP error messages are
   transmitted unreliably, transport protocols should not depend on them
   for correct functioning.  In the event one of these messages were
   legitimate, the corresponding connection would eventually time out.
   Also, applications may still be notified asynchronously about the
   error condition, and thus may still abort their connections on their
   own if they consider it appropriate.

   In scenarios such as that in which an intermediate system sets the DF
   bit in the segments transmitted by a TCP that does not implement
   PMTUD, or the TCP at one of the endpoints of the connection is
   dynamically disabled, TCP would only abort the connection after a
   USER TIMEOUT [<a href="/doc/html/rfc0793" title="&quot;Transmission Control Protocol&quot;">RFC0793</a>], losing responsiveness.  However, these
   scenarios are very unlikely in production environments, and it is
   probably preferable to potentially lose responsiveness for the sake
   of robustness.  It should also be noted that applications may still
   be notified asynchronously about the error condition, and thus may
   still abort their connections on their own if they consider it
   appropriate.

   In scenarios of multipath routing or route changes, failures in some
   (but not all) of the paths may elicit ICMP error messages that would
   likely not cause a connection abort if any of the counter-measures
   described in this section were implemented.  However, aborting the
   connection would be to ignore the valuable feature of the Internet --
   that for many internal failures, it reconstructs its function without
   any disruption of the endpoints [<a href="/doc/html/rfc0816" title="&quot;Fault isolation and recovery&quot;">RFC0816</a>].  That is, communication
   should survive if there is still a working path to the destination
   system [<a href="#ref-DClark" title="&quot;The Design Philosophy of the DARPA Internet Protocols&quot;">DClark</a>].  Additionally, applications may still be notified
   asynchronously about the error condition, and thus may still abort
   their connections on their own if they consider it appropriate.

   This counter-measure has been implemented in BSD-derived TCP/IP
   implementations (e.g., [<a href="#ref-FreeBSD">FreeBSD</a>], [<a href="#ref-NetBSD" title="&quot;http://www.netbsd.org&quot;">NetBSD</a>], and [<a href="#ref-OpenBSD" title="&quot;http://www.openbsd.org&quot;">OpenBSD</a>]) for more
   than ten years [<a href="#ref-Wright" title="&quot;TCP/IP Illustrated, Volume 2: The Implementation&quot;">Wright</a>][McKusick].  The Linux kernel has also
   implemented this policy for more than ten years [<a href="#ref-Linux" title="&quot;http://www.kernel.org&quot;">Linux</a>].




<span class="grey">Gont                          Informational                    [Page 15]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-16" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Blind Throughput-Reduction Attack</span>

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Description</span>

   The Host Requirements RFC [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] states in <a href="#section-4.2.3.9">Section 4.2.3.9</a> that
   hosts MUST react to ICMPv4 Source Quench messages by slowing
   transmission on the connection.  Thus, an attacker could send ICMPv4
   Source Quench (type 4, code 0) messages to a TCP endpoint to make it
   reduce the rate at which it sends data to the other endpoint of the
   connection.  [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] further adds that the RECOMMENDED procedure is
   to put the corresponding connection in the slow-start phase of TCP&#x27;s
   congestion control algorithm [<a href="/doc/html/rfc5681" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].  In the case of those
   implementations that use an initial congestion window of one segment,
   a sustained attack would reduce the throughput of the attacked
   connection to about SMSS (Sender Maximum Segment Size) [<a href="/doc/html/rfc5681" title="&quot;TCP Congestion Control&quot;">RFC5681</a>]
   bytes per RTT (round-trip time).  The throughput achieved during an
   attack might be a little higher if a larger initial congestion window
   is in use [<a href="/doc/html/rfc3390" title="&quot;Increasing TCP&#x27;s Initial Window&quot;">RFC3390</a>].

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  Attack-Specific Counter-Measures</span>

   As discussed in the &quot;Requirements for IP Version 4 Routers&quot; RFC
   [<a href="/doc/html/rfc1812" title="&quot;Requirements for IP Version 4 Routers&quot;">RFC1812</a>], research seems to suggest that ICMPv4 Source Quench
   messages are an ineffective (and unfair) antidote for congestion.
   [<a href="/doc/html/rfc1812" title="&quot;Requirements for IP Version 4 Routers&quot;">RFC1812</a>] further states that routers SHOULD NOT send ICMPv4 Source
   Quench messages in response to congestion.  Furthermore, TCP
   implements its own congestion control mechanisms ([<a href="/doc/html/rfc5681" title="&quot;TCP Congestion Control&quot;">RFC5681</a>]
   [<a href="/doc/html/rfc3168" title="&quot;The Addition of Explicit Congestion Notification (ECN) to IP&quot;">RFC3168</a>]) that do not depend on ICMPv4 Source Quench messages.

   Based on this reasoning, a large number of implementations completely
   ignore ICMPv4 Source Quench messages meant for TCP connections.  This
   behavior has been implemented in, at least, Linux [<a href="#ref-Linux" title="&quot;http://www.kernel.org&quot;">Linux</a>] since 2004,
   and in FreeBSD [<a href="#ref-FreeBSD">FreeBSD</a>], NetBSD [<a href="#ref-NetBSD" title="&quot;http://www.netbsd.org&quot;">NetBSD</a>], and OpenBSD [<a href="#ref-OpenBSD" title="&quot;http://www.openbsd.org&quot;">OpenBSD</a>]
   since 2005.  However, it must be noted that this behavior violates
   the requirement in [<a href="/doc/html/rfc1122" title="&quot;Requirements for Internet Hosts - Communication Layers&quot;">RFC1122</a>] to react to ICMPv4 Source Quench
   messages by slowing transmission on the connection.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  Blind Performance-Degrading Attack</span>

<span class="h3"><a class="selflink" id="section-7.1" href="#section-7.1">7.1</a>.  Description</span>

   When one IP system has a large amount of data to send to another
   system, the data will be transmitted as a series of IP datagrams.  It
   is usually preferable that these datagrams be of the largest size
   that does not require fragmentation anywhere along the path from the
   source to the destination.  This datagram size is referred to as the
   Path MTU (PMTU) and is equal to the minimum of the MTUs of each hop
   in the path.  A technique called &quot;Path MTU Discovery&quot; (PMTUD) lets IP



<span class="grey">Gont                          Informational                    [Page 16]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-17" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   systems determine the Path MTU of an arbitrary internet path.
   [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>] specify the PMTUD mechanism for IPv4 and
   IPv6, respectively.

   The PMTUD mechanism for IPv4 uses the Don&#x27;t Fragment (DF) bit in the
   IP header to dynamically discover the Path MTU.  The basic idea
   behind the PMTUD mechanism is that a source system assumes that the
   MTU of the path is that of the first hop, and sends all its datagrams
   with the DF bit set.  If any of the datagrams is too large to be
   forwarded without fragmentation by some intermediate router, the
   router will discard the corresponding datagram and will return an
   ICMPv4 &quot;Destination Unreachable, fragmentation needed and DF set&quot;
   (type 3, code 4) error message to the sending system.  This message
   will report the MTU of the constricting hop, so that the sending
   system can reduce the assumed Path-MTU accordingly.

   For IPv6, intermediate systems do not fragment packets.  Thus,
   there&#x27;s an &quot;implicit&quot; DF bit set in every packet sent on a network.
   If any of the datagrams is too large to be forwarded without
   fragmentation by some intermediate router, the router will discard
   the corresponding datagram, and will return an ICMPv6 &quot;Packet Too
   Big&quot; (type 2, code 0) error message to the sending system.  This
   message will report the MTU of the constricting hop, so that the
   sending system can reduce the assumed Path-MTU accordingly.

   As discussed in both [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>], the Path-MTU Discovery
   mechanism can be used to attack TCP.  An attacker could send a
   crafted ICMPv4 &quot;Destination Unreachable, fragmentation needed and DF
   set&quot; packet (or their ICMPv6 counterpart) to the sending system,
   advertising a small Next-Hop MTU.  As a result, the attacked system
   would reduce the size of the packets it sends for the corresponding
   connection accordingly.

   The effect of this attack is two-fold.  On one hand, it will increase
   the headers/data ratio, thus increasing the overhead needed to send
   data to the remote TCP endpoint.  On the other hand, if the attacked
   system wanted to keep the same throughput it was achieving before
   being attacked, it would have to increase the packet rate.  On
   virtually all systems, this will lead to an increased processing
   overhead, thus degrading the overall system performance.

   A particular scenario that may take place is one in which an attacker
   reports a Next-Hop MTU smaller than or equal to the amount of bytes
   needed for headers (IP header, plus TCP header).  For example, if the
   attacker reports a Next-Hop MTU of 68 bytes, and the amount of bytes
   used for headers (IP header, plus TCP header) is larger than
   68 bytes, the assumed Path-MTU will not even allow the attacked
   system to send a single byte of application data without



<span class="grey">Gont                          Informational                    [Page 17]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-18" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   fragmentation.  This particular scenario might lead to unpredictable
   results.  Another possible scenario is one in which a TCP connection
   is being secured by means of IPsec.  If the Next-Hop MTU reported by
   the attacker is smaller than the amount of bytes needed for headers
   (IP and IPsec, in this case), the assumed Path-MTU will not even
   allow the attacked system to send a single byte of the TCP header
   without fragmentation.  This is another scenario that may lead to
   unpredictable results.

   For IPv4, the reported Next-Hop MTU could be as small as 68 octets,
   as [<a href="/doc/html/rfc0791" title="&quot;Internet Protocol&quot;">RFC0791</a>] requires every internet module to be able to forward a
   datagram of 68 octets without further fragmentation.  For IPv6, while
   the required minimum IPv6 MTU is 1280, the reported Next-Hop MTU can
   be smaller than 1280 octets [<a href="/doc/html/rfc2460" title="&quot;Internet Protocol, Version 6 (IPv6) Specification&quot;">RFC2460</a>].  If the reported Next-Hop MTU
   is smaller than the minimum IPv6 MTU, the receiving host is not
   required to reduce the Path-MTU to a value smaller than 1280, but is
   required to include a fragmentation header in the outgoing packets to
   that destination from that moment on.

<span class="h3"><a class="selflink" id="section-7.2" href="#section-7.2">7.2</a>.  Attack-Specific Counter-Measures</span>

   The IETF has standardized a Path-MTU Discovery mechanism called
   &quot;Packetization Layer Path MTU Discovery&quot; (PLPMTUD) that does not
   depend on ICMP error messages.  Implementation of the aforementioned
   mechanism in replacement of the traditional PMTUD (specified in
   [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>]) eliminates this vulnerability.  However, it
   can also lead to an increase in PMTUD convergence time.

   This section describes a modification to the PMTUD mechanism
   specified in [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>] that has been incorporated in
   OpenBSD and NetBSD (since 2005) to improve TCP&#x27;s resistance to the
   blind performance-degrading attack described in <a href="#section-7.1">Section 7.1</a>.  The
   described counter-measure basically disregards ICMP messages when a
   connection makes progress, without violating any of the requirements
   stated in [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>].

   Henceforth, we will refer to both ICMPv4 &quot;fragmentation needed and DF
   bit set&quot; and ICMPv6 &quot;Packet Too Big&quot; messages as &quot;ICMP Packet Too
   Big&quot; messages.

   In addition to the general validation check described in <a href="#section-4.1">Section 4.1</a>,
   these implementations include a modification to TCP&#x27;s reaction to
   ICMP &quot;Packet Too Big&quot; error messages that disregards them when a
   connection makes progress, and honors them only after the
   corresponding data have been retransmitted a specified number of
   times.  This means that upon receipt of an ICMP &quot;Packet Too Big&quot;





<span class="grey">Gont                          Informational                    [Page 18]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-19" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   error message, TCP just records this information, and honors it only
   when the corresponding data have already been retransmitted a
   specified number of times.

   While this basic policy would greatly mitigate the impact of the
   attack against the PMTUD mechanism, it would also mean that it might
   take TCP more time to discover the Path-MTU for a TCP connection.
   This would be particularly annoying for connections that have just
   been established, as it might take TCP several transmission attempts
   (and the corresponding timeouts) before it discovers the PMTU for the
   corresponding connection.  Thus, this policy would increase the time
   it takes for data to begin to be received at the destination host.

   In order to protect TCP from the attack against the PMTUD mechanism,
   while still allowing TCP to quickly determine the initial Path-MTU
   for a connection, the aforementioned implementations have divided the
   traditional PMTUD mechanism into two stages: Initial Path-MTU
   Discovery and Path-MTU Update.

   The Initial Path-MTU Discovery stage is when TCP tries to send
   segments that are larger than the ones that have so far been sent and
   acknowledged for this connection.  That is, in the Initial Path-MTU
   Discovery stage, TCP has no record of these large segments getting to
   the destination host, and thus these implementations believe the
   network when it reports that these packets are too large to reach the
   destination host without being fragmented.

   The Path-MTU Update stage is when TCP tries to send segments that are
   equal to or smaller than the ones that have already been sent and
   acknowledged for this connection.  During the Path-MTU Update stage,
   TCP already has knowledge of the estimated Path-MTU for the given
   connection.  Thus, in this case, these implementations are more
   cautious with the errors being reported by the network.

   In order to allow TCP to distinguish segments between those
   performing Initial Path-MTU Discovery and those performing Path-MTU
   Update, two new variables are introduced to TCP: maxsizesent and
   maxsizeacked.

   The maxsizesent variable holds the size (in octets) of the largest
   packet that has so far been sent for this connection.  It is
   initialized to 68 (the minimum IPv4 MTU) when the underlying Internet
   Protocol is IPv4, and is initialized to 1280 (the minimum IPv6 MTU)
   when the underlying Internet Protocol is IPv6.  Whenever a packet
   larger than maxsizesent octets is sent, maxsizesent is set to that
   value.





<span class="grey">Gont                          Informational                    [Page 19]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-20" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   On the other hand, maxsizeacked holds the size (in octets) of the
   largest packet (data, plus headers) that has so far been acknowledged
   for this connection.  It is initialized to 68 (the minimum IPv4 MTU)
   when the underlying Internet Protocol is IPv4, and is initialized to
   1280 (the minimum IPv6 MTU) when the underlying Internet Protocol is
   IPv6.  Whenever an acknowledgement for a packet larger than
   maxsizeacked octets is received, maxsizeacked is set to the size of
   that acknowledged packet.  Note that because of TCP&#x27;s cumulative
   acknowledgement, a single ACK may acknowledge the receipt of more
   than one packet.  When that happens, the algorithm may &quot;incorrectly&quot;
   assume it is in the &quot;Path-MTU Update&quot; stage, rather than the &quot;Initial
   Path-MTU Discovery&quot; stage (as described below).

   Upon receipt of an ICMP &quot;Packet Too Big&quot; error message, the Next-Hop
   MTU claimed by the ICMP message (henceforth &quot;claimedmtu&quot;) is compared
   with maxsizesent.  If claimedmtu is larger than maxsizesent, then the
   ICMP error message is silently discarded.  The rationale for this is
   that the ICMP error message cannot be legitimate if it claims to have
   been triggered by a packet larger than the largest packet we have so
   far sent for this connection.

   If this check is passed, claimedmtu is compared with maxsizeacked.
   If claimedmtu is equal to or larger than maxsizeacked, TCP is
   supposed to be at the Initial Path-MTU Discovery stage, and thus the
   ICMP &quot;Packet Too Big&quot; error message is honored immediately.  That is,
   the assumed Path-MTU is updated according to the Next-Hop MTU claimed
   in the ICMP error message.  Also, maxsizesent is reset to the minimum
   MTU of the Internet Protocol in use (68 for IPv4, and 1280 for IPv6).

   On the other hand, if claimedmtu is smaller than maxsizeacked, TCP is
   supposed to be in the Path-MTU Update stage.  At this stage, these
   implementations are more cautious with the errors being reported by
   the network, and therefore just record the received error message,
   and delay the update of the assumed Path-MTU.

   To perform this delay, one new variable and one new parameter are
   introduced to TCP: nsegrto and MAXSEGRTO.  The nsegrto variable holds
   the number of times a specified segment has timed out.  It is
   initialized to zero, and is incremented by one every time the
   corresponding segment times out.  MAXSEGRTO specifies the number of
   times a given segment must time out before an ICMP &quot;Packet Too Big&quot;
   error message can be honored, and can be set, in principle, to any
   value greater than or equal to 0.








<span class="grey">Gont                          Informational                    [Page 20]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-21" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   Thus, if nsegrto is greater than or equal to MAXSEGRTO, and there&#x27;s a
   pending ICMP &quot;Packet Too Big&quot; error message, the corresponding error
   message is processed.  At that point, maxsizeacked is set to
   claimedmtu, and maxsizesent is set to 68 (for IPv4) or 1280 (for
   IPv6).

   If, while there is a pending ICMP &quot;Packet Too Big&quot; error message, the
   TCP SEQ claimed by the pending message is acknowledged (i.e., an ACK
   that acknowledges that sequence number is received), then the
   &quot;pending error&quot; condition is cleared.

   The rationale behind performing this delayed processing of ICMP
   &quot;Packet Too Big&quot; messages is that if there is progress on the
   connection, the ICMP &quot;Packet Too Big&quot; errors must be a false claim.
   By checking for progress on the connection, rather than just for
   staleness of the received ICMP messages, TCP is protected from attack
   even if the offending ICMP messages are &quot;in window&quot;, and as a
   corollary, is made more robust to spurious ICMP messages triggered
   by, for example, corrupted TCP segments.

   MAXSEGRTO can be set, in principle, to any value greater than or
   equal to 0.  Setting MAXSEGRTO to 0 would make TCP perform the
   traditional PMTUD mechanism defined in [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>].  A
   MAXSEGRTO of 1 provides enough protection for most cases.  In any
   case, implementations are free to choose higher values for this
   constant.  MAXSEGRTO could be a function of the Next-Hop MTU claimed
   in the received ICMP &quot;Packet Too Big&quot; message.  That is, higher
   values for MAXSEGRTO could be imposed when the received ICMP &quot;Packet
   Too Big&quot; message claims a Next-Hop MTU that is smaller than some
   specified value.  Both OpenBSD and NetBSD set MAXSEGRTO to 1.

   In the event a higher level of protection is desired at the expense
   of a higher delay in the discovery of the Path-MTU, an implementation
   could consider TCP to always be in the Path-MTU Update stage, thus
   always delaying the update of the assumed Path-MTU.

   <a href="#section-7.3">Section 7.3</a> shows this counter-measure in action.  <a href="#section-7.4">Section 7.4</a> shows
   this counter-measure in pseudo-code.

   It is important to note that the mechanism described in this section
   is an improvement to the current Path-MTU discovery mechanism, to
   mitigate its security implications.  The current PMTUD mechanism, as
   specified by [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>], still suffers from some
   functionality problems [<a href="/doc/html/rfc2923" title="&quot;TCP Problems with Path MTU Discovery&quot;">RFC2923</a>] that this document does not aim to
   address.  A mechanism that addresses those issues is described in
   [<a href="/doc/html/rfc4821" title="&quot;Packetization Layer Path MTU Discovery&quot;">RFC4821</a>].





<span class="grey">Gont                          Informational                    [Page 21]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-22" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


<span class="h3"><a class="selflink" id="section-7.3" href="#section-7.3">7.3</a>.  The Counter-Measure for the PMTUD Attack in Action</span>

   This section illustrates the operation of the counter-measure for the
   ICMP attack against the PMTUD mechanism that has been implemented in
   OpenBSD and NetBSD.  It shows both how the fix protects TCP from
   being attacked and how the counter-measure works in normal scenarios.
   As discussed in <a href="#section-7.2">Section 7.2</a>, this section assumes the PMTUD-specific
   counter-measure is implemented in addition to the TCP sequence number
   checking described in <a href="#section-4.1">Section 4.1</a>.

   Figure 1 illustrates a hypothetical scenario in which two hosts are
   connected by means of three intermediate routers.  It also shows the
   MTU of each hypothetical hop.  All the following subsections assume
   the network setup of this figure.

   Also, for simplicity&#x27;s sake, all subsections assume an IP header of
   20 octets and a TCP header of 20 octets.  Thus, for example, when the
   PMTU is assumed to be 1500 octets, TCP will send segments that
   contain, at most, 1460 octets of data.

   For simplicity&#x27;s sake, all the following subsections assume the TCP
   implementation at Host 1 (H1) has chosen a MAXSEGRTO of 1.

   +----+        +----+        +----+        +----+        +----+
   | H1 |--------| R1 |--------| R2 |--------| R3 |--------| H2 |
   +----+        +----+        +----+        +----+        +----+
         MTU=4464      MTU=2048      MTU=1500      MTU=4464

                      Figure 1: Hypothetical Scenario

<span class="h4"><a class="selflink" id="section-7.3.1" href="#section-7.3.1">7.3.1</a>.  Normal Operation for Bulk Transfers</span>

   This subsection shows the counter-measure in normal operation, when a
   TCP connection is used for bulk transfers.  That is, it shows how the
   counter-measure works when there is no attack taking place and a TCP
   connection is used for transferring large amounts of data.  This
   section assumes that just after the connection is established, one of
   the TCP endpoints begins to transfer data in packets that are as
   large as possible.












<span class="grey">Gont                          Informational                    [Page 22]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-23" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


       Host 1                                       Host 2

   1.    --&gt;            &lt;SEQ=100&gt;&lt;CTL=SYN&gt;           --&gt;
   2.    &lt;--      &lt;SEQ=X&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;      &lt;--
   3.    --&gt;       &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;       --&gt;
   4.    --&gt; &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=4424&gt;  --&gt;
   5.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=2048, TCPseq#=101 &lt;--- R1
   6.    --&gt; &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=2008&gt;  --&gt;
   7.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=1500, TCPseq#=101 &lt;--- R2
   8.    --&gt; &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
   9.    &lt;--      &lt;SEQ=X+1&gt;&lt;ACK=1561&gt;&lt;CTL=ACK&gt;       &lt;--

               Figure 2: Normal Operation for Bulk Transfers

   The nsegrto variable is initialized to zero.  Both maxsizeacked and
   maxsizesent are initialized to the minimum MTU for the Internet
   Protocol being used (68 for IPv4, and 1280 for IPv6).

   In lines 1 to 3, the three-way handshake takes place, and the
   connection is established.  In line 4, H1 tries to send a full-sized
   TCP segment.  As described by [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>], in this case,
   TCP will try to send a segment with 4424 bytes of data, which will
   result in an IP packet of 4464 octets.  Therefore, maxsizesent is set
   to 4464.  When the packet reaches R1, it elicits an ICMP &quot;Packet Too
   Big&quot; error message.

   In line 5, H1 receives the ICMP error message, which reports a Next-
   Hop MTU of 2048 octets.  After performing the TCP sequence number
   check described in <a href="#section-4.1">Section 4.1</a>, the Next-Hop MTU reported by the ICMP
   error message (claimedmtu) is compared with maxsizesent.  As it is
   smaller than maxsizesent, it passes the check, and thus is then
   compared with maxsizeacked.  As claimedmtu is larger than
   maxsizeacked, TCP assumes that the corresponding TCP segment was
   performing the Initial PMTU Discovery.  Therefore, the TCP at H1
   honors the ICMP message by updating the assumed Path-MTU.  The
   maxsizesent variable is reset to the minimum MTU of the Internet
   Protocol in use (68 for IPv4, and 1280 for IPv6).

   In line 6, the TCP at H1 sends a segment with 2008 bytes of data,
   which results in an IP packet of 2048 octets.  The maxsizesent
   variable is thus set to 2008 bytes.  When the packet reaches R2, it
   elicits an ICMP &quot;Packet Too Big&quot; error message.

   In line 7, H1 receives the ICMP error message, which reports a Next-
   Hop MTU of 1500 octets.  After performing the TCP sequence number
   check, the Next-Hop MTU reported by the ICMP error message
   (claimedmtu) is compared with maxsizesent.  As it is smaller than
   maxsizesent, it passes the check, and thus is then compared with



<span class="grey">Gont                          Informational                    [Page 23]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-24" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   maxsizeacked.  As claimedmtu is larger than maxsizeacked, TCP assumes
   that the corresponding TCP segment was performing the Initial PMTU
   Discovery.  Therefore, the TCP at H1 honors the ICMP message by
   updating the assumed Path-MTU.  The maxsizesent variable is reset to
   the minimum MTU of the Internet Protocol in use.

   In line 8, the TCP at H1 sends a segment with 1460 bytes of data,
   which results in an IP packet of 1500 octets.  Thus, maxsizesent is
   set to 1500.  This packet reaches H2, where it elicits an
   acknowledgement (ACK) segment.

   In line 9, H1 finally gets the acknowledgement for the data segment.
   As the corresponding packet was larger than maxsizeacked, TCP updates
   maxsizeacked, setting it to 1500.  At this point, TCP has discovered
   the Path-MTU for this TCP connection.

<span class="h4"><a class="selflink" id="section-7.3.2" href="#section-7.3.2">7.3.2</a>.  Operation during Path-MTU Changes</span>

   Let us suppose a TCP connection between H1 and H2 has already been
   established, and that the PMTU for the connection has already been
   discovered to be 1500.  At this point, both maxsizesent and
   maxsizeacked are equal to 1500, and nsegrto is equal to 0.  Suppose
   some time later the PMTU decreases to 1492.  For simplicity, let us
   suppose that the Path-MTU has decreased because the MTU of the link
   between R2 and R3 has decreased from 1500 to 1492.  Figure 3
   illustrates how the counter-measure would work in this scenario.

       Host 1                                       Host 2

   1.                   (Path-MTU decreases)
   2.    --&gt;  &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;   --&gt;
   3.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=1492, TCPseq#=100 &lt;--- R2
   4.                   (Segment times out)
   5.    --&gt;  &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1452&gt;   --&gt;
   6.    &lt;--        &lt;SEQ=X&gt;&lt;ACK=1552&gt;&lt;CTL=ACK&gt;       &lt;--

                Figure 3: Operation during Path-MTU Changes

   In line 1, the Path-MTU for this connection decreases from 1500 to
   1492.  In line 2, the TCP at H1, without being aware of the Path-MTU
   change, sends a 1500-byte packet to H2.  When the packet reaches R2,
   it elicits an ICMP &quot;Packet Too Big&quot; error message.

   In line 3, H1 receives the ICMP error message, which reports a Next-
   Hop MTU of 1492 octets.  After performing the TCP sequence number
   check, the Next-Hop MTU reported by the ICMP error message
   (claimedmtu) is compared with maxsizesent.  As claimedmtu is smaller
   than maxsizesent, it is then compared with maxsizeacked.  As



<span class="grey">Gont                          Informational                    [Page 24]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-25" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   claimedmtu is smaller than maxsizeacked (full-sized packets were
   getting to the remote endpoint), this packet is assumed to be
   performing Path-MTU Update, and a &quot;pending error&quot; condition is
   recorded.

   In line 4, the segment times out.  Thus, nsegrto is incremented by 1.
   As nsegrto is greater than or equal to MAXSEGRTO, the assumed Path-
   MTU is updated.  The nsegrto variable is reset to 0, maxsizeacked is
   set to claimedmtu, and maxsizesent is set to the minimum MTU of the
   Internet Protocol in use.

   In line 5, H1 retransmits the data using the updated PMTU, and thus
   maxsizesent is set to 1492.  The resulting packet reaches H2, where
   it elicits an acknowledgement (ACK) segment.

   In line 6, H1 finally gets the acknowledgement for the data segment.
   At this point, TCP has discovered the new Path-MTU for this TCP
   connection.

<span class="h4"><a class="selflink" id="section-7.3.3" href="#section-7.3.3">7.3.3</a>.  Idle Connection Being Attacked</span>

   Let us suppose a TCP connection between H1 and H2 has already been
   established, and the PMTU for the connection has already been
   discovered to be 1500.  Figure 4 shows a sample time-line diagram
   that illustrates an idle connection being attacked.

       Host 1                                       Host 2

   1.    --&gt;   &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=50&gt;    --&gt;
   2.    &lt;--        &lt;SEQ=X&gt;&lt;ACK=150&gt;&lt;CTL=ACK&gt;        &lt;--
   3.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=68, TCPseq#=100 &lt;---
   4.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=68, TCPseq#=100 &lt;---
   5.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=68, TCPseq#=100 &lt;---

                 Figure 4: Idle Connection Being Attacked

   In line 1, H1 sends its last bunch of data.  In line 2, H2
   acknowledges the receipt of these data.  Then the connection becomes
   idle.  In lines 3, 4, and 5, an attacker sends forged ICMP &quot;Packet
   Too Big&quot; error messages to H1.  Regardless of how many packets it
   sends and of the TCP sequence number each ICMP packet includes, none
   of these ICMP error messages will pass the TCP sequence number check
   described in <a href="#section-4.1">Section 4.1</a>, as H1 has no unacknowledged data &quot;in
   flight&quot; to H2.  Therefore, the attack does not succeed.







<span class="grey">Gont                          Informational                    [Page 25]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-26" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


<span class="h4"><a class="selflink" id="section-7.3.4" href="#section-7.3.4">7.3.4</a>.  Active Connection Being Attacked after Discovery of the Path-MTU</span>

   Let us suppose an attacker attacks a TCP connection for which the
   PMTU has already been discovered.  In this case, as illustrated in
   Figure 1, the PMTU would be found to be 1500 bytes.  Figure 5 shows a
   possible packet exchange.

       Host 1                                       Host 2

   1.    --&gt;  &lt;SEQ=100&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;   --&gt;
   2.    --&gt;  &lt;SEQ=1560&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
   3.    --&gt;  &lt;SEQ=3020&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
   4.    --&gt;  &lt;SEQ=4480&gt;&lt;ACK=X&gt;&lt;CTL=ACK&gt;&lt;DATA=1460&gt;  --&gt;
   5.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=68, TCPseq#=100 &lt;---
   6.    &lt;--       &lt;SEQ=X&gt;&lt;CTL=ACK&gt;&lt;ACK=1560&gt;        &lt;--

    Figure 5: Active Connection Being Attacked after Discovery of PMTU

   As we assume the PMTU has already been discovered, we also assume
   both maxsizesent and maxsizeacked are equal to 1500.  We assume
   nsegrto is equal to zero, as there have been no segment timeouts.

   In lines 1, 2, 3, and 4, H1 sends four data segments to H2.  In
   line 5, an attacker sends a forged ICMP error message to H1.  We
   assume the attacker is lucky enough to guess both the four-tuple that
   identifies the connection and a valid TCP sequence number.  As the
   Next-Hop MTU claimed in the ICMP &quot;Packet Too Big&quot; message
   (claimedmtu) is smaller than maxsizeacked, this packet is assumed to
   be performing Path-MTU Update.  Thus, the error message is recorded.

   In line 6, H1 receives an acknowledgement for the segment sent in
   line 1, before it times out.  At this point, the &quot;pending error&quot;
   condition is cleared, and the recorded ICMP &quot;Packet Too Big&quot; error
   message is ignored.  Therefore, the attack does not succeed.

<span class="h4"><a class="selflink" id="section-7.3.5" href="#section-7.3.5">7.3.5</a>.  TCP Peer Attacked when Sending Small Packets Just after the</span>
<span class="h4">        Three-Way Handshake</span>

   This section analyzes a scenario in which a TCP peer that is sending
   small segments just after the connection has been established is
   attacked.  The connection could be in use by protocols such as SMTP
   [<a href="/doc/html/rfc5321" title="&quot;Simple Mail Transfer Protocol&quot;">RFC5321</a>] and HTTP [<a href="/doc/html/rfc2616" title="&quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;">RFC2616</a>], for example, which usually behave like
   this.

   Figure 6 shows a possible packet exchange for such a scenario.






<span class="grey">Gont                          Informational                    [Page 26]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-27" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


       Host 1                                       Host 2

   1.    --&gt;           &lt;SEQ=100&gt;&lt;CTL=SYN&gt;            --&gt;
   2.    &lt;--      &lt;SEQ=X&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;      &lt;--
   3.    --&gt;       &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;       --&gt;
   4.    --&gt;  &lt;SEQ=101&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=100&gt;  --&gt;
   5.    &lt;--       &lt;SEQ=X+1&gt;&lt;ACK=201&gt;&lt;CTL=ACK&gt;       &lt;--
   6.    --&gt;  &lt;SEQ=201&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=100&gt;  --&gt;
   7.    --&gt;  &lt;SEQ=301&gt;&lt;ACK=X+1&gt;&lt;CTL=ACK&gt;&lt;DATA=100&gt;  --&gt;
   8.       &lt;--- ICMP &quot;Packet Too Big&quot; MTU=150, TCPseq#=201 &lt;---

          Figure 6: TCP Peer Attacked when Sending Small Packets
                    Just after the Three-Way Handshake

   The nsegrto variable is initialized to zero.  Both maxsizesent and
   maxsizeacked are initialized to the minimum MTU for the Internet
   Protocol being used (68 for IPv4, and 1280 for IPv6).

   In lines 1 to 3, the three-way handshake takes place, and the
   connection is established.  At this point, the assumed Path-MTU for
   this connection is 4464.  In line 4, H1 sends a small segment (which
   results in a 140-byte packet) to H2.  Therefore, maxsizesent is set
   to 140.  In line 5, this segment is acknowledged, and thus
   maxsizeacked is set to 140.

   In lines 6 and 7, H1 sends two small segments to H2.  In line 8,
   while the segments from lines 6 and 7 are still &quot;in flight&quot; to H2, an
   attacker sends a forged ICMP &quot;Packet Too Big&quot; error message to H1.
   Assuming the attacker is lucky enough to guess a valid TCP sequence
   number, this ICMP message will pass the TCP sequence number check.
   The Next-Hop MTU reported by the ICMP error message (claimedmtu) is
   then compared with maxsizesent.  As claimedmtu is larger than
   maxsizesent, the ICMP error message is silently discarded.
   Therefore, the attack does not succeed.

<span class="h3"><a class="selflink" id="section-7.4" href="#section-7.4">7.4</a>.  Pseudo-Code for the Counter-Measure for the Blind Performance-</span>
<span class="h3">      Degrading Attack</span>

   This section contains a pseudo-code version of the counter-measure
   described in <a href="#section-7.2">Section 7.2</a> for the blind performance-degrading attack
   described in <a href="#section-7">Section 7</a>.  It is meant as guidance for developers on
   how to implement this counter-measure.

   The pseudo-code makes use of the following variables, constants, and
   functions:






<span class="grey">Gont                          Informational                    [Page 27]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-28" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   ack
      Variable holding the acknowledgement number contained in the TCP
      segment that has just been received.

   acked_packet_size
      Variable holding the packet size (data, plus headers) that the ACK
      that has just been received is acknowledging.

   adjust_mtu()
      Function that adjusts the MTU for this connection, according to
      the ICMP &quot;Packet Too Big&quot; that was last received.

   claimedmtu
      Variable holding the Next-Hop MTU advertised by the ICMP &quot;Packet
      Too Big&quot; error message.

   claimedtcpseq
      Variable holding the TCP sequence number contained in the payload
      of the ICMP &quot;Packet Too Big&quot; message that has just been received
      or was last recorded.

   current_mtu
      Variable holding the assumed Path-MTU for this connection.

   drop_message()
      Function that performs the necessary actions to drop the ICMP
      message being processed.

   initial_mtu
      Variable holding the MTU for new connections, as explained in
      [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>].

   maxsizeacked
      Variable holding the largest packet size (data, plus headers) that
      has so far been acked for this connection, as explained in
      <a href="#section-7.2">Section 7.2</a>.

   maxsizesent
      Variable holding the largest packet size (data, plus headers) that
      has so far been sent for this connection, as explained in
      <a href="#section-7.2">Section 7.2</a>.

   nsegrto
      Variable holding the number of times this segment has timed out,
      as explained in <a href="#section-7.2">Section 7.2</a>.

   packet_size
      Variable holding the size of the IP datagram being sent.



<span class="grey">Gont                          Informational                    [Page 28]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-29" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   pending_message
      Variable (flag) that indicates whether there is a pending ICMP
      &quot;Packet Too Big&quot; message to be processed.

   save_message()
      Function that records the ICMP &quot;Packet Too Big&quot; message that has
      just been received.

   MINIMUM_MTU
      Constant holding the minimum MTU for the Internet Protocol in use
      (68 for IPv4, and 1280 for IPv6).

   MAXSEGRTO
      Constant holding the number of times a given segment must time out
      before an ICMP &quot;Packet Too Big&quot; error message can be honored.


   EVENT: New TCP connection

    current_mtu = initial_mtu;
    maxsizesent = MINIMUM_MTU;
    maxsizeacked = MINIMUM_MTU;
    nsegrto = 0;
    pending_message = 0;

   EVENT: Segment is sent

    if (packet_size &gt; maxsizesent)
         maxsizesent = packet_size;

   EVENT: Segment is received

    if (acked_packet_size &gt; maxsizeacked)
         maxsizeacked = acked_packet_size;

    if (pending_message)
         if (ack &gt; claimedtcpseq){
              pending_message = 0;
              nsegrto = 0;
         }

   EVENT: ICMP &quot;Packet Too Big&quot; message is received

    if (claimedmtu &lt;= MINIMUM_MTU)
         drop_message();

    if (claimedtcpseq &lt; SND.UNA || claimedtcpseq &gt;= SND.NXT)
         drop_message();



<span class="grey">Gont                          Informational                    [Page 29]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-30" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


    else {
         if (claimedmtu &gt; maxsizesent || claimedmtu &gt;= current_mtu)
              drop_message();

         else {
              if (claimedmtu &gt; maxsizeacked){
                   adjust_mtu();
                   current_mtu = claimedmtu;
                   maxsizesent = MINIMUM_MTU;
              }

              else {
                   pending_message = 1;
                   save_message();
              }
         }
    }

   EVENT: Segment times out

    nsegrto++;

    if (pending_message &amp;&amp; nsegrto &gt;= MAXSEGRTO){
         adjust_mtu();
         nsegrto = 0;
         pending_message = 0;
         maxsizeacked = claimedmtu;
         maxsizesent = MINIMUM_MTU;
         current_mtu = claimedmtu;
    }

   Notes:
      All comparisons between sequence numbers must be performed using
      sequence number arithmetic.

      The pseudo-code implements the mechanism described in <a href="#section-7.2">Section 7.2</a>,
      the TCP sequence number checking described in <a href="#section-4.1">Section 4.1</a>, and the
      validation check on the advertised Next-Hop MTU described in
      [<a href="/doc/html/rfc1191" title="&quot;Path MTU discovery&quot;">RFC1191</a>] and [<a href="/doc/html/rfc1981" title="&quot;Path MTU Discovery for IP version 6&quot;">RFC1981</a>].

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  Security Considerations</span>

   This document describes the use of ICMP error messages to perform a
   number of attacks against TCP, and describes a number of widely
   implemented counter-measures that either eliminate or reduce the
   impact of these attacks when they are performed by off-path
   attackers.




<span class="grey">Gont                          Informational                    [Page 30]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-31" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   <a href="#section-4.1">Section 4.1</a> describes a validation check that could be enforced on
   ICMP error messages, such that TCP reacts only to those ICMP error
   messages that appear to relate to segments currently &quot;in flight&quot; to
   the destination system.  This requires more effort on the side of an
   off-path attacker at the expense of possible reduced responsiveness
   to network errors.

   <a href="#section-4.2">Section 4.2</a> describes how randomization of TCP ephemeral ports
   requires more effort on the side of the attacker to successfully
   exploit any of the attacks described in this document.

   <a href="#section-4.3">Section 4.3</a> describes how ICMP error messages could possibly be
   filtered based on their payload, to prevent users of the local
   network from successfully performing attacks against third-party
   connections.  This is analogous to ingress filtering and egress
   filtering of IP packets [<a href="#ref-IP-filtering" title="&quot;NISCC Technical Note 01/2006: Egress and Ingress Filtering&quot;">IP-filtering</a>].

   <a href="#section-5.2">Section 5.2</a> describes an attack-specific counter-measure for the
   blind connection-reset attack.  It describes the processing of ICMP
   &quot;hard errors&quot; as &quot;soft errors&quot; when they are received for connections
   in any of the synchronized states.  This counter-measure eliminates
   the aforementioned vulnerability in synchronized connections at the
   expense of possible reduced responsiveness in some network scenarios.

   <a href="#section-6.2">Section 6.2</a> describes an attack-specific counter-measure for the
   blind throughput-reduction attack.  It suggests that the
   aforementioned vulnerability can be eliminated by ignoring ICMPv4
   Source Quench messages meant for TCP connections.  This is in
   accordance with research results that indicate that ICMPv4 Source
   Quench messages are ineffective and are an unfair antidote for
   congestion.

   Finally, <a href="#section-7.2">Section 7.2</a> describes an attack-specific counter-measure for
   the blind performance-degrading attack.  It consists of the
   validation check described in <a href="#section-4.1">Section 4.1</a>, with a modification that
   makes TCP react to ICMP &quot;Packet Too Big&quot; error messages such that
   they are processed when an outstanding TCP segment times out.  This
   counter-measure parallels the Packetization Layer Path MTU Discovery
   (PLPMTUD) mechanism [<a href="/doc/html/rfc4821" title="&quot;Packetization Layer Path MTU Discovery&quot;">RFC4821</a>].  It should be noted that if this
   counter-measure is implemented, in some scenarios TCP may respond
   more slowly to valid ICMP &quot;Packet Too Big&quot; error messages.

   A discussion of these and other attack vectors for performing similar
   attacks against TCP (along with possible counter-measures) can be
   found in [<a href="#ref-CPNI-TCP" title="&quot;Security Assessment of the Transmission Control Protocol (TCP)&quot;">CPNI-TCP</a>] and [<a href="#ref-TCP-SECURITY" title="&quot;Security Assessment of the Transmission Control Protocol (TCP)&quot;">TCP-SECURITY</a>].






<span class="grey">Gont                          Informational                    [Page 31]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-32" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>.  Acknowledgements</span>

   This document was inspired by Mika Liljeberg, while discussing some
   issues related to [<a href="/doc/html/rfc5461" title="&quot;TCP&#x27;s Reaction to Soft Errors&quot;">RFC5461</a>] by private e-mail.  The author would like
   to thank (in alphabetical order): Bora Akyol, Mark Allman, Ran
   Atkinson, James Carlson, Alan Cox, Theo de Raadt, Wesley Eddy, Lars
   Eggert, Ted Faber, Juan Fraschini, Markus Friedl, Guillermo Gont,
   John Heffner, Alfred Hoenes, Vivek Kakkar, Michael Kerrisk, Mika
   Liljeberg, Matt Mathis, David Miller, Toby Moncaster, Miles Nordin,
   Eloy Paris, Kacheong Poon, Andrew Powell, Pekka Savola, Donald Smith,
   Pyda Srisuresh, Fred Templin, and Joe Touch for contributing many
   valuable comments.

   Juan Fraschini and the author of this document implemented freely
   available audit tools to help vendors audit their systems by
   reproducing the attacks discussed in this document.  These tools are
   available at <a href="http://www.gont.com.ar/tools/index.html">http://www.gont.com.ar/tools/index.html</a>.

   Markus Friedl, Chad Loder, and the author of this document produced
   and tested in OpenBSD [<a href="#ref-OpenBSD" title="&quot;http://www.openbsd.org&quot;">OpenBSD</a>] the first implementation of the
   counter-measure described in <a href="#section-7.2">Section 7.2</a>.  This first implementation
   helped to test the effectiveness of the ideas introduced in this
   document, and has served as a reference implementation for other
   operating systems.

   The author would like to thank the UK&#x27;s Centre for the Protection of
   National Infrastructure (CPNI) -- formerly the National
   Infrastructure Security Co-ordination Centre (NISCC) -- for
   coordinating the disclosure of these issues with a large number of
   vendors and CSIRTs (Computer Security Incident Response Teams).

   The author wishes to express deep and heartfelt gratitude to Jorge
   Oscar Gont and Nelida Garcia, for their precious motivation and
   guidance.

<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>.  References</span>

<span class="h3"><a class="selflink" id="section-10.1" href="#section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC0791">RFC0791</a>]         Postel, J., &quot;Internet Protocol&quot;, STD 5, <a href="/doc/html/rfc791">RFC 791</a>,
                     September 1981.

   [<a id="ref-RFC0792">RFC0792</a>]         Postel, J., &quot;Internet Control Message Protocol&quot;,
                     STD 5, <a href="/doc/html/rfc792">RFC 792</a>, September 1981.

   [<a id="ref-RFC0793">RFC0793</a>]         Postel, J., &quot;Transmission Control Protocol&quot;, STD 7,
                     <a href="/doc/html/rfc793">RFC 793</a>, September 1981.




<span class="grey">Gont                          Informational                    [Page 32]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-33" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   [<a id="ref-RFC1122">RFC1122</a>]         Braden, R., &quot;Requirements for Internet Hosts -
                     Communication Layers&quot;, STD 3, <a href="/doc/html/rfc1122">RFC 1122</a>,
                     October 1989.

   [<a id="ref-RFC1191">RFC1191</a>]         Mogul, J. and S. Deering, &quot;Path MTU discovery&quot;,
                     <a href="/doc/html/rfc1191">RFC 1191</a>, November 1990.

   [<a id="ref-RFC1812">RFC1812</a>]         Baker, F., &quot;Requirements for IP Version 4 Routers&quot;,
                     <a href="/doc/html/rfc1812">RFC 1812</a>, June 1995.

   [<a id="ref-RFC1981">RFC1981</a>]         McCann, J., Deering, S., and J. Mogul, &quot;Path MTU
                     Discovery for IP version 6&quot;, <a href="/doc/html/rfc1981">RFC 1981</a>, August 1996.

   [<a id="ref-RFC2119">RFC2119</a>]         Bradner, S., &quot;Key words for use in RFCs to Indicate
                     Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2460">RFC2460</a>]         Deering, S. and R. Hinden, &quot;Internet Protocol,
                     Version 6 (IPv6) Specification&quot;, <a href="/doc/html/rfc2460">RFC 2460</a>,
                     December 1998.

   [<a id="ref-RFC4301">RFC4301</a>]         Kent, S. and K. Seo, &quot;Security Architecture for the
                     Internet Protocol&quot;, <a href="/doc/html/rfc4301">RFC 4301</a>, December 2005.

   [<a id="ref-RFC4443">RFC4443</a>]         Conta, A., Deering, S., and M. Gupta, &quot;Internet
                     Control Message Protocol (ICMPv6) for the Internet
                     Protocol Version 6 (IPv6) Specification&quot;, <a href="/doc/html/rfc4443">RFC 4443</a>,
                     March 2006.

   [<a id="ref-RFC4884">RFC4884</a>]         Bonica, R., Gan, D., Tappan, D., and C. Pignataro,
                     &quot;Extended ICMP to Support Multi-Part Messages&quot;,
                     <a href="/doc/html/rfc4884">RFC 4884</a>, April 2007.

<span class="h3"><a class="selflink" id="section-10.2" href="#section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-CPNI-TCP">CPNI-TCP</a>]        CPNI, &quot;Security Assessment of the Transmission
                     Control Protocol (TCP)&quot;, <a href="http://www.cpni.gov.uk/Docs/tn-03-09-security-assessment-TCP.pdf">http://www.cpni.gov.uk/</a>
                     <a href="http://www.cpni.gov.uk/Docs/tn-03-09-security-assessment-TCP.pdf">Docs/tn-03-09-security-assessment-TCP.pdf</a>, 2009.

   [<a id="ref-DClark">DClark</a>]          Clark, D., &quot;The Design Philosophy of the DARPA
                     Internet Protocols&quot;, Computer Communication
                     Review Vol. 18, No. 4, 1988.

   [<a id="ref-FreeBSD">FreeBSD</a>]         The FreeBSD Project, <a href="http://www.freebsd.org">http://www.freebsd.org</a>.

   [<a id="ref-ICMP-Filtering">ICMP-Filtering</a>]  Gont, F., &quot;Filtering of ICMP error messages&quot;,  http
                     ://www.gont.com.ar/papers/
                     filtering-of-icmp-error-messages.pdf.




<span class="grey">Gont                          Informational                    [Page 33]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-34" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   [<a id="ref-IP-filtering">IP-filtering</a>]    NISCC, &quot;NISCC Technical Note 01/2006: Egress and
                     Ingress Filtering&quot;,
                      <a href="http://www.cpni.gov.uk/Docs/re-20060420-00294.pdf">http://www.cpni.gov.uk/Docs/re-20060420-00294.pdf</a>,
                     2006.

   [<a id="ref-Linux">Linux</a>]           The Linux Project, &quot;http://www.kernel.org&quot;.

   [<a id="ref-McKusick">McKusick</a>]        McKusick, M., Bostic, K., Karels, M., and J.
                     Quarterman, &quot;The Design and Implementation of the
                     4.4 BSD Operating System&quot;, Addison-Wesley, 1996.

   [<a id="ref-NISCC">NISCC</a>]           NISCC, &quot;NISCC Vulnerability Advisory 532967/NISCC/
                     ICMP: Vulnerability Issues in ICMP packets with TCP
                     payloads&quot;,  <a href="http://www.cpni.gov.uk/docs/re-20050412-00303.pdf?lang=en">http://www.cpni.gov.uk/docs/</a>
                     <a href="http://www.cpni.gov.uk/docs/re-20050412-00303.pdf?lang=en">re-20050412-00303.pdf?lang=en</a>, 2005.

   [<a id="ref-NetBSD">NetBSD</a>]          The NetBSD Project, &quot;http://www.netbsd.org&quot;.

   [<a id="ref-OpenBSD">OpenBSD</a>]         The OpenBSD Project, &quot;http://www.openbsd.org&quot;.

   [<a id="ref-OpenBSD-PF">OpenBSD-PF</a>]      The OpenBSD Packet Filter,
                     &quot;http://www.openbsd.org/faq/pf/&quot;.

   [<a id="ref-PORT-RANDOM">PORT-RANDOM</a>]     Larsen, M. and F. Gont, &quot;Transport Protocol Port
                     Randomization Recommendations&quot;, Work in Progress,
                     April 2010.

   [<a id="ref-RFC0816">RFC0816</a>]         Clark, D., &quot;Fault isolation and recovery&quot;, <a href="/doc/html/rfc816">RFC 816</a>,
                     July 1982.

   [<a id="ref-RFC1321">RFC1321</a>]         Rivest, R., &quot;The MD5 Message-Digest Algorithm&quot;,
                     <a href="/doc/html/rfc1321">RFC 1321</a>, April 1992.

   [<a id="ref-RFC1323">RFC1323</a>]         Jacobson, V., Braden, B., and D. Borman, &quot;TCP
                     Extensions for High Performance&quot;, <a href="/doc/html/rfc1323">RFC 1323</a>,
                     May 1992.

   [<a id="ref-RFC2385">RFC2385</a>]         Heffernan, A., &quot;Protection of BGP Sessions via the
                     TCP MD5 Signature Option&quot;, <a href="/doc/html/rfc2385">RFC 2385</a>, August 1998.

   [<a id="ref-RFC2616">RFC2616</a>]         Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                     Masinter, L., Leach, P., and T. Berners-Lee,
                     &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
                     <a href="/doc/html/rfc2616">RFC 2616</a>, June 1999.

   [<a id="ref-RFC2923">RFC2923</a>]         Lahey, K., &quot;TCP Problems with Path MTU Discovery&quot;,
                     <a href="/doc/html/rfc2923">RFC 2923</a>, September 2000.




<span class="grey">Gont                          Informational                    [Page 34]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-35" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   [<a id="ref-RFC3168">RFC3168</a>]         Ramakrishnan, K., Floyd, S., and D. Black, &quot;The
                     Addition of Explicit Congestion Notification (ECN)
                     to IP&quot;, <a href="/doc/html/rfc3168">RFC 3168</a>, September 2001.

   [<a id="ref-RFC3390">RFC3390</a>]         Allman, M., Floyd, S., and C. Partridge,
                     &quot;Increasing TCP&#x27;s Initial Window&quot;, <a href="/doc/html/rfc3390">RFC 3390</a>,
                     October 2002.

   [<a id="ref-RFC4271">RFC4271</a>]         Rekhter, Y., Li, T., and S. Hares, &quot;A Border
                     Gateway Protocol 4 (BGP-4)&quot;, <a href="/doc/html/rfc4271">RFC 4271</a>,
                     January 2006.

   [<a id="ref-RFC4821">RFC4821</a>]         Mathis, M. and J. Heffner, &quot;Packetization Layer
                     Path MTU Discovery&quot;, <a href="/doc/html/rfc4821">RFC 4821</a>, March 2007.

   [<a id="ref-RFC4907">RFC4907</a>]         Aboba, B., &quot;Architectural Implications of Link
                     Indications&quot;, <a href="/doc/html/rfc4907">RFC 4907</a>, June 2007.

   [<a id="ref-RFC4953">RFC4953</a>]         Touch, J., &quot;Defending TCP Against Spoofing
                     Attacks&quot;, <a href="/doc/html/rfc4953">RFC 4953</a>, July 2007.

   [<a id="ref-RFC5321">RFC5321</a>]         Klensin, J., &quot;Simple Mail Transfer Protocol&quot;,
                     <a href="/doc/html/rfc5321">RFC 5321</a>, October 2008.

   [<a id="ref-RFC5461">RFC5461</a>]         Gont, F., &quot;TCP&#x27;s Reaction to Soft Errors&quot;,
                     <a href="/doc/html/rfc5461">RFC 5461</a>, February 2009.

   [<a id="ref-RFC5681">RFC5681</a>]         Allman, M., Paxson, V., and E. Blanton, &quot;TCP
                     Congestion Control&quot;, <a href="/doc/html/rfc5681">RFC 5681</a>, September 2009.

   [<a id="ref-RFC5925">RFC5925</a>]         Touch, J., Mankin, A., and R. Bonica, &quot;The TCP
                     Authentication Option&quot;, <a href="/doc/html/rfc5925">RFC 5925</a>, June 2010.

   [<a id="ref-TCP-SECURITY">TCP-SECURITY</a>]    Gont, F., &quot;Security Assessment of the Transmission
                     Control Protocol (TCP)&quot;, Work in Progress,
                     February 2010.

   [<a id="ref-TCPM-TCPSECURE">TCPM-TCPSECURE</a>]  Ramaiah, A., Stewart, R., and M. Dalal, &quot;Improving
                     TCP&#x27;s Robustness to Blind In-Window Attacks&quot;, Work
                     in Progress, May 2010.

   [<a id="ref-US-CERT">US-CERT</a>]         US-CERT, &quot;US-CERT Vulnerability Note VU#222750:
                     TCP/IP Implementations do not adequately validate
                     ICMP error messages&quot;,
                     <a href="http://www.kb.cert.org/vuls/id/222750">http://www.kb.cert.org/vuls/id/222750</a>, 2005.

   [<a id="ref-Watson">Watson</a>]          Watson, P., &quot;Slipping in the Window: TCP Reset
                     Attacks&quot;, CanSecWest Conference, 2004.



<span class="grey">Gont                          Informational                    [Page 35]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-36" ></span>
<span class="grey"><a href="/doc/html/rfc5927">RFC 5927</a>                ICMP Attacks against TCP               July 2010</span>


   [<a id="ref-Wright">Wright</a>]          Wright, G. and W. Stevens, &quot;TCP/IP Illustrated,
                     Volume 2: The Implementation&quot;, Addison-
                     Wesley, 1994.

Author&#x27;s Address

   Fernando Gont
   Universidad Tecnologica Nacional / Facultad Regional Haedo
   Evaristo Carriego 2644
   Haedo, Provincia de Buenos Aires  1706
   Argentina

   Phone: +54 11 4650 8472
   EMail: fernando@gont.com.ar
   URI:   <a href="http://www.gont.com.ar">http://www.gont.com.ar</a>




































Gont                          Informational                    [Page 36]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

