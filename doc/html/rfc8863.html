<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc8863
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-ice-pac/">
  <meta name="description" content="Interactive Connectivity Establishment Patiently Awaiting Connectivity (ICE PAC) (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgblue"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc8863.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc8863.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/rfc8863.xml" title="XML source for this document">xml</a>|<a href="https://www.rfc-editor.org/rfc/rfc8863.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc8863/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc8863/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/ice/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-ice-pac@ietf.org?subject=draft-ietf-ice-pac" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-ice-pac-06.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-ice-pac-06.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-ice-pac-06.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-ice-pac-06">draft-ietf-ice-pac-06</a>                            Proposed Standard</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                       C. Holmberg
Request for Comments: 8863                                      Ericsson
Updates: <a href="/doc/html/rfc8445">8445</a>, <a href="/doc/html/rfc8838">8838</a>                                            J. Uberti
Category: Standards Track                                         Google
ISSN: 2070-1721                                             January 2021


 <span class="h1">Interactive Connectivity Establishment Patiently Awaiting Connectivity</span>
                               <span class="h1">(ICE PAC)</span>

Abstract

   During the process of establishing peer-to-peer connectivity,
   Interactive Connectivity Establishment (ICE) agents can encounter
   situations where they have no candidate pairs to check, and, as a
   result, conclude that ICE processing has failed.  However, because
   additional candidate pairs can be discovered during ICE processing,
   declaring failure at this point may be premature.  This document
   discusses when these situations can occur.

   This document updates RFCs 8445 and 8838 by requiring that an ICE
   agent wait a minimum amount of time before declaring ICE failure,
   even if there are no candidate pairs left to check.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="/doc/html/rfc7841#section-2">Section&nbsp;2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8863">https://www.rfc-editor.org/info/rfc8863</a>.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions
   3.  Relevant Scenarios
     3.1.  No Candidates from Peer
     3.2.  All Candidates Discarded
     3.3.  Immediate Candidate Pair Failure
   4.  Update to <a href="/doc/html/rfc8445">RFC 8445</a>
   5.  Update to <a href="/doc/html/rfc8838">RFC 8838</a>
   6.  Security Considerations
   7.  IANA Considerations
   8.  Normative References
   Acknowledgements
   Authors&#x27; Addresses

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   [<a id="ref-RFC8445">RFC8445</a>] describes a protocol, Interactive Connectivity
   Establishment (ICE), for Network Address Translator (NAT) traversal
   for UDP-based communication.

   When using ICE, endpoints will typically exchange ICE candidates,
   form a list of candidate pairs, and then test each candidate pair to
   see if connectivity can be established.  If the test for a given pair
   fails, it is marked accordingly, and if all pairs have failed, the
   overall ICE process typically is considered to have failed.

   During the process of connectivity checks, additional candidates may
   be created as a result of successful inbound checks from the remote
   peer.  Such candidates are referred to as peer-reflexive candidates;
   once discovered, these candidates will be used to form new candidate
   pairs, which will be tested like any other.  However, there is an
   inherent problem here; if, before learning about any peer-reflexive
   candidates, an endpoint runs out of candidate pairs to check, either
   because it has none or it considers them all to have failed, it will
   prematurely declare failure and terminate ICE processing.  This
   problem can occur in many common situations.

   This specification updates [<a href="/doc/html/rfc8445" title="&quot;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&quot;">RFC8445</a>] and [<a href="/doc/html/rfc8838" title="&quot;Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol&quot;">RFC8838</a>] by simply
   requiring that an ICE agent wait a minimum amount of time before
   declaring ICE failure, even if there are no candidate pairs to check
   or all candidate pairs have failed.  This delay provides enough time
   for the discovery of peer-reflexive candidates, which may eventually
   lead to ICE processing completing successfully.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Conventions</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in
   <a href="/doc/html/bcp14">BCP 14</a> [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="/doc/html/rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Relevant Scenarios</span>

   As noted above, the core problem this specification attempts to
   address is the situation where even after local gathering and remote
   candidate signaling have completed, the ICE agent immediately ends up
   with no valid pairs and no candidate pairs left to check, resulting
   in a premature ICE failure.  This failure is premature because not
   enough time has elapsed to allow for discovery of peer-reflexive
   candidates from inbound connectivity checks; if discovered, these
   candidates are very likely to result in a valid pair.

   In most ICE scenarios, the lengthy timeouts for connectivity check
   transactions, typically tens of seconds, will prevent this problem
   from occurring.  However, there are certain specific cases where this
   problem will frequently occur.

<span class="h3"><a class="selflink" id="section-3.1" href="#section-3.1">3.1</a>.  No Candidates from Peer</span>

   Per [<a href="/doc/html/rfc8838" title="&quot;Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol&quot;">RFC8838</a>], an ICE agent can provide zero candidates of its own.
   If the agent somehow knows that the remote endpoint is directly
   reachable, gathering local candidates is unnecessary and will only
   cause delays; the peer agent can discover the appropriate local
   candidate via connectivity checks.

   However, following the procedures from [<a href="/doc/html/rfc8445" title="&quot;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&quot;">RFC8445</a>] strictly will result
   in immediate ICE failure, since the checklist at the peer agent will
   be empty.

<span class="h3"><a class="selflink" id="section-3.2" href="#section-3.2">3.2</a>.  All Candidates Discarded</span>

   Even if the ICE agent provides candidates, they may be discarded by
   the peer agent if it does not know what to do with them.  For
   example, candidates may use an address family that the peer agent
   does not support (e.g., a host candidate with an IPv6 address in a
   NAT64 scenario) or that may not be usable for some other reason.

   In these scenarios, when the candidates are discarded, the checklist
   at the peer agent will once again be empty, leading to immediate ICE
   failure.

<span class="h3"><a class="selflink" id="section-3.3" href="#section-3.3">3.3</a>.  Immediate Candidate Pair Failure</span>

   <a href="/doc/html/rfc8445#section-7.2.5.2">Section&nbsp;7.2.5.2 of [RFC8445]</a> describes several situations in which a
   candidate pair will be considered to have failed, well before the
   connectivity check transaction timeout.

   As a result, even if the ICE agent provides usable candidates, the
   pairs created by the peer agent may fail immediately when checked,
   e.g., a check to a non-routable address that receives an immediate
   ICMP error.

   In this situation, the checklist at the peer agent may contain only
   failed pairs, resulting in immediate ICE failure.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Update to <a href="/doc/html/rfc8445">RFC 8445</a></span>

   In order to avoid the problem raised by this document, the ICE agent
   needs to wait enough time to allow peer-reflexive candidates to be
   discovered.  Accordingly, when a full ICE implementation begins its
   ICE processing, as described in <a href="/doc/html/rfc8445#section-6.1">[RFC8445], Section&nbsp;6.1</a>, it MUST set a
   timer, henceforth known as the &quot;PAC timer&quot; (Patiently Awaiting
   Connectivity), to ensure that ICE will run for a minimum amount of
   time before determining failure.

   Specifically, the ICE agent will start its timer once it believes ICE
   connectivity checks are starting.  This occurs when the agent has
   sent the values needed to perform connectivity checks (e.g., the
   Username Fragment and Password denoted in <a href="/doc/html/rfc8445#section-5.3">[RFC8445], Section&nbsp;5.3</a>) and
   has received some indication that the remote side is ready to start
   connectivity checks, typically via receipt of the values mentioned
   above.  Note that the agent will start the timer even if it has not
   sent or received any ICE candidates.

   The RECOMMENDED duration for the PAC timer is equal to the agent&#x27;s
   connectivity check transaction timeout, including all
   retransmissions.  When using default values for retransmission
   timeout (RTO) and Rc, this amounts to 39.5 seconds, as explained in
   <a href="/doc/html/rfc5389#section-7.2.1">[RFC5389], Section&nbsp;7.2.1</a>.  This timeout value is chosen to roughly
   coincide with the maximum possible duration of ICE connectivity
   checks from the remote peer, which, if successful, could create peer-
   reflexive candidates.  Because the ICE agent doesn&#x27;t know the exact
   number of candidate pairs and pacing interval in use by the remote
   side, this timeout value is simply a guess, albeit an educated one.
   Regardless, for this particular problem, the desired benefits will be
   realized as long as the agent waits some reasonable amount of time,
   and, as usual, the application is in the best position to determine
   what is reasonable for its scenario.

   While the timer is still running, the ICE agent MUST NOT update a
   checklist state from Running to Failed, even if there are no pairs
   left in the checklist to check.  As a result, the ICE agent will not
   remove any data streams or set the state of the ICE session to Failed
   as long as the timer is running.

   When the timer period eventually elapses, the ICE agent MUST resume
   typical ICE processing, including setting the state of any checklists
   to Failed if they have no pairs left to check and handling any
   consequences as indicated in <a href="/doc/html/rfc8445#section-8.1.2">[RFC8445], Section&nbsp;8.1.2</a>.  Naturally, if
   there are no such checklists, no action is necessary.

   One consequence of this behavior is that in cases where ICE should
   fail, e.g., where both sides provide candidates with unsupported
   address families, ICE will no longer fail immediately -- it will only
   fail when the PAC timer expires.  However, because most ICE scenarios
   require an extended period of time to determine failure, the fact
   that some specific scenarios no longer fail quickly should have
   minimal application impact, if any.

   Note also that the PAC timer is potentially relevant to the ICE
   nomination procedure described in <a href="/doc/html/rfc8445#section-8.1.1">[RFC8445], Section&nbsp;8.1.1</a>.  That
   specification does not define a minimum duration for ICE processing
   prior to nomination of a candidate pair, but in order to select the
   best candidate pair, ICE needs to run for enough time in order to
   allow peer-reflexive candidates to be discovered and checked, as
   noted above.  Accordingly, the controlling ICE agent SHOULD wait a
   sufficient amount of time before nominating candidate pairs, and it
   MAY use the PAC timer to do so.  As always, the controlling ICE agent
   retains full discretion and MAY decide, based on its own criteria, to
   nominate pairs prior to the PAC timer period elapsing.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Update to <a href="/doc/html/rfc8838">RFC 8838</a></span>

   Trickle ICE [<a href="/doc/html/rfc8838" title="&quot;Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol&quot;">RFC8838</a>] considers a similar problem, namely whether an
   ICE agent should allow a checklist to enter the Failed state if more
   candidates might still be provided by the remote peer.  The solution,
   specified in <a href="/doc/html/rfc8838#section-8">[RFC8838], Section&nbsp;8</a>, is to wait until an end-of-
   candidates indication has been received before determining ICE
   failure.

   However, for the same reasons described above, the ICE agent may
   discover peer-reflexive candidates after it has received the end-of-
   candidates indication, and so the solution proposed by this document
   MUST still be used even when the ICE agent is using Trickle ICE.

   Note also that sending an end-of-candidates indication is only a
   SHOULD-strength requirement, which means that ICE agents will need to
   implement a backup mechanism to decide when all candidates have been
   received, typically a timer.  Accordingly, ICE agents MAY use the PAC
   timer to also serve as an end-of-candidates fallback.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Security Considerations</span>

   The security considerations for ICE are defined in [<a href="/doc/html/rfc8445" title="&quot;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal&quot;">RFC8445</a>].  This
   specification only recommends that ICE agents wait for a certain
   period of time before they declare ICE failure; it does not introduce
   new security considerations.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  IANA Considerations</span>

   This document has no IANA actions.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC5389">RFC5389</a>]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,
              &quot;Session Traversal Utilities for NAT (STUN)&quot;, <a href="/doc/html/rfc5389">RFC 5389</a>,
              DOI 10.17487/RFC5389, October 2008,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5389">https://www.rfc-editor.org/info/rfc5389</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in <a href="/doc/html/rfc2119">RFC</a>
              <a href="/doc/html/rfc2119">2119</a> Key Words&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-RFC8445">RFC8445</a>]  Keranen, A., Holmberg, C., and J. Rosenberg, &quot;Interactive
              Connectivity Establishment (ICE): A Protocol for Network
              Address Translator (NAT) Traversal&quot;, <a href="/doc/html/rfc8445">RFC 8445</a>,
              DOI 10.17487/RFC8445, July 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8445">https://www.rfc-editor.org/info/rfc8445</a>&gt;.

   [<a id="ref-RFC8838">RFC8838</a>]  Ivov, E., Uberti, J., and P. Saint-Andre, &quot;Trickle ICE:
              Incremental Provisioning of Candidates for the Interactive
              Connectivity Establishment (ICE) Protocol&quot;, <a href="/doc/html/rfc8838">RFC 8838</a>,
              DOI 10.17487/RFC8838, January 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8838">https://www.rfc-editor.org/info/rfc8838</a>&gt;.

Acknowledgements

   Roman Shpount, Nils Ohlmeier, and Peter Thatcher provided lots of
   useful input and comments.

Authors&#x27; Addresses

   Christer Holmberg
   Ericsson
   Hirsalantie 11
   FI-02420 Jorvas
   Finland

   Email: christer.holmberg@ericsson.com


   Justin Uberti
   Google
   747 6th St W
   Kirkland, WA 98033
   United States of America

   Email: justin@uberti.name
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

