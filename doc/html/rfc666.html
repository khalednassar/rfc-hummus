<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc666
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/rfc666/">
  <meta name="description" content="Specification of the Unified User-Level Protocol (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgwhite"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc666.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc666.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc666.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc666/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc666/" title="Datatracker information for this document">Tracker</a>] [<a href="mailto:rfc666@ietf.org?subject=rfc666" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=rfc666-.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=rfc666-.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/rfc666-.txt" title="Run an idnits check of this document">Nits</a>]

                                                                 Unknown</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Network Working Group                                       M. Padlipsky
Request for Comment: 666                                26 November 1974
NIC: 31396

            <span class="h1">Specification of the Unified User-Level Protocol</span>


   After many discussions of my <a href="/doc/html/rfc451">RFC 451</a>, I discovered that the &quot;Unified
   User-Level Protocol&quot; proposed therein had evolved into what had
   always been its underlying motivation, a common command language.
   There are several reasons why this latter approach satisfies the
   original goals of the UULP and goes beyond them into even more useful
   areas:

   1. User convenience.  As evidenced by the good response to the common
   editor &quot;neted&quot;, the Network Working Group has come to acknowledge the
   fact that the convenience of non-system programmer users of the
   Network must be served.  Allowing users to invoke the same generic
   functions -- including &quot;batch&quot; jobs -- irrespective of which Server
   Host they happen to be using is surely a compelling initial
   justification for a common command language.  Note that the concern
   with generic functions -- which &quot;all&quot; Servers do, one way or another
   -- is intended to emphasize the common command subset aspects of the
   language, rather than the &quot;linguistic&quot; elegance of it all.  The
   attempt is to specify an easy way of getting many things done, not a
   complicated way of getting &quot;everything&quot; done.

   2. &quot;Resource sharing&quot;.  Another area which is receiving attention in
   the NWG of late is that of &quot;automatic&quot; or program-driven invocation
   of resources on foreign systems.  A common intermediate
   representation of some sort is clearly necessary to perform such
   functions if we are to avoid the old &quot;n by m problem&quot; of the Telnet
   Protocol -- in this case, n Hosts would otherwise have to keep track
   of m command languages.  For the common intermediate representation
   to be human-usable seems to kill two birds with one stone, as
   expanded upon in the next point.

   3. Economy of mechanism.  In <a href="/doc/html/rfc451">RFC 451</a>, I advanced the claim that a
   single user-level protocol which connected via socket 1 and Telnet
   would offer economy of mechanism in that new responders would not be
   required to service Initial Connection Protocols on socket after
   socket as protocol after protocol evolved.  This consideration still
   applies, but an even greater economy is visible when we consider the
   context of resource sharing.  For if the common command language is
   designed for direct employment by users, as the present proposal is,
   there is no need for users on terminal support &quot;mini-Hosts&quot; (e.g.,
   ANTS and TIPs) to require an intermediary server when all they
   actually want is to work on a particular Server in the common



<span class="grey">Padlipsky                                                       [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   language.  (This is especially true in light of the fact that many
   such users are not professional programmers -- and are familiar with
   no command language.)  That is, if resource sharing is achieved by an
   intermediate language which is only suitable for programs, you would
   have to learn the native command language of Server B if you didn&#x27;t
   want to incur the expense of using Server A only to get at generic
   functions on Server B.  (And you might still have to learn the native
   language of Server A, even if the expense of using two Servers where
   one would do isn&#x27;t a factor.)

   4. Front-ending.  Another benefit of the common command language
   proposed here is that it is by and large intended to lend itself to
   implementation by front-ending onto existing commands.  Thus, the
   unpleasant necessity of throwing out existing implementations is
   minimized.  Indeed, the approach taken is a conscious effort to come
   up with a common command language by addition to &quot;native&quot; command
   languages rather than by replacement, for the compelling reason that
   it would be unworkable as well as ill-advised to attempt to legislate
   the richness represented by existing command languages out of
   existence.  Further, as it is a closed environment, no naming
   conflicts with native commands would arise.

   5. Accounting and authentication.  As evidenced by the spate of RFCs
   about the implications of the FTP in regard to both accounting for
   use of Network services and authenticating users&#x27; identifications
   (Bressler&#x27;s <a href="/doc/html/rfc487">RFC 487</a>, Pogran&#x27;s <a href="/doc/html/rfc501">RFC 501</a>, and my <a href="/doc/html/rfc505">RFC 505</a> -- and even
   491), this area is still up in the air.  The generic login command
   proposed here should help matters, as it allows the Server to
   associate an appropriate process with the connection while actuating
   appropriate accounting and access control as well, if it chooses.

   6. Process-process functions.  By enabling the invocation of foreign
   object programs, the present proposal offers a rubric in which such
   process-to-process functions as &quot;parallelism&quot; can be performed.  (See
   the discussion of the &quot;call&quot; command, below.)  Note that the UULP is
   not being advanced as a panacea: It is assumed that the actual
   transactions carried out are most likely not going to be in the
   common command language (although some certainly could be); however,
   what is furnished is a known way of getting the presumably special-
   cased programs executing elsewhere.  Also, it offers a convenient
   environment into which can be placed such new functions, which we
   would like to have become generic, as Day&#x27;s File Access Protocol.

   All of which seems to be a fair amount of mileage to get out of a
   distaste for remembering whether you find out who&#x27;s logged in by
   saying &quot;systat&quot;, &quot;users&quot;, &quot;s.who:c&quot;, &quot;listf tty&quot;, or &quot;who&quot;....





<span class="grey">Padlipsky                                                       [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


Context

   Although ultimately intended to become the general responder to the
   Initial Connection Protocol, the UULP is initially to be a Telnet
   Protocol &quot;negotiated option&quot;.  When the option is enabled, the Server
   Host will furnish a command environment which supports the common
   conventions and commands discussed herein.

   In a sense, the UULP is a &quot;selector&quot;.  That is, the common command
   subset includes commands to exit from the common command environment
   and enter various other environments, along the lines of CCN&#x27;s
   current Telnet Server.  To exit from the UULP environment to the
   &quot;native&quot; command processor, the UULP command is &quot;local&quot; (see also the
   discussion of Case, below).  Note that all commands terminate in
   Telnet &quot;Newline&quot; (currently cr-lf), unless altered by the &quot;eol&quot;
   command (below); internal separator is space (blank).  (Entrance into
   other environments -- such as the FTP Server -- is discussed below.)
   There are two reasons for introducing a mechanism other than the
   apparently natural one of simply de-negotiating the option: First, it
   is bound to be more convenient for the user to type a command than to
   escape to his User Telnet program to cause the option disabling.
   Second, it is hoped that eventually the UULP will be legislated to be
   the default environment encountered by any Network login, in which
   case the natural way to enter the Server&#x27;s &quot;native&quot; command
   environment would be by UULP command.

      Note: all UULP commands discussed herein are listed in Appendix 1,
      categorized as to optionality, with brief descriptions given.  The
      appendix may be taken as a first-pass UULP Users&#x27; Manual.

Responses

   Any optional commands which are not supported by a particular Server
   are to be responded to by a message of the form &quot;Not implemented:
   commandname.&quot;, where the variable is the name of the command which
   was requested.  Note that throughout this document, all literals must
   be sent exactly as specified, so as to allow for the possibility of
   Servers&#x27; being driven by programs (including &quot;automata&quot; or &quot;command
   macros&quot;) in addition to &quot;live&quot; users.

   In general, the view has been taken here that a small number of
   literal, constrained responses is superior to a vast variety of
   numerically coded responses in which text may vary.  Again, the
   motivation is to achieve an economy of mechanism.  For on the coded
   model, there must be a coordinator of code assignments, which is just
   as well avoided.  Further, as has been experienced in the use of the
   FTP, when there are many codes there are many ambiguities.  (The
   sender may have a perfectly valid case for choosing, say, 452, while



<span class="grey">Padlipsky                                                       [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   the receiver may have an equally good interpretation of the codes&#x27;
   definitions for expecting, say, 453.)  Experience with a related
   &quot;error table&quot; mechanism on Multics also bears out the assertion that
   coded responses create both managerial and technical problems.  A
   final objection to numeric codes might be considered irrelevant by
   live some, but I think that the aesthetics of the situation do merit
   some attention.  And when the common command language is being
   employed by live users, it seems to me that they would only be
   distracted by all those numbers flying around.  (Nor can we assume
   that the numbers could be stripped by their &quot;User UULP&quot;, for one of
   the basic goals here is to make it straightforward enough for a user
   at a TIP to deal with.)


Arguments

   During the review process, it became evident that some global
   comments on arguments were in order.  Two areas in particular appear
   to have led to some confusion: the strategy of specification of
   arguments on the command line, and the question of &quot;control
   arguments&quot;.  On the first score, the goal of &quot;front-endability&quot; must
   be recalled.  Consider two native implementations of a particular
   command, one of which (A) expects to collect its arguments by
   interrogation of the user, and the other of which (B) expects to
   receive them on invocation (being invoked as a closed subroutine).
   Now, it is easy to imagine that a &quot;Server UULP&quot; could feed the
   arguments to A as needed without requiring A to be rewritten, but it
   is quite difficult to see how B could be made to interrogate for
   arguments without extensive rewriting.  Therefore, a &quot;least common
   denominator&quot; approach of specifying arguments in advance incurs the
   minimum cost in terms of reworking existing implementations.

   On the second score, I have borrowed a notion from the Multics
   command language&#x27;s convention called &quot;control arguments&quot; because it
   seems to be quite convenient in actual practice.  The key is that
   some arguments are meant as literals, usually specifying a mode or
   control function to the command, while others are variables,
   specifying something like a particular file name or user identifier.
   A common example is a &quot;mail&quot; command, where the variables are the
   user identifiers and the Host identifiers, and the &quot;control argument&quot;
   is the designator that user identifiers have ceased and Host
   identifiers have begun.  The convention used here is to begin the
   control argument with a hyphen, as this character never seems to be
   used to begin variable arguments.  Thus, we use &quot;-at&quot; in the mail
   example.  Although it is not a deep philosophical point, this
   approach does relieve argument lists of order-dependency, and feels
   right to me.




<span class="grey">Padlipsky                                                       [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


Case

   Although it appears to have been legislated out of existence by the
   specification of the Network Virtual Terminal&#x27;s keyboard in the
   Telnet Protocol, the question of what to do about users at upper-
   case-only terminals remains a thorny one in practice.  There are two
   aspects to consider: the alphabetic case of commands, and the ability
   to cause &quot;case-mapping&quot; in order to allow lower-case input.  Some
   Servers have no local problems with the first aspect, as they operate
   internally in all upper-case or all lower-case and merely map all
   input appropriately.  (Problems do arise, though, when one is using
   the User FTP on such a system to deal with a mixed-case system, for
   example.) Other Servers, however, attach the normal linguistic
   significance to case.  (E.g., Smith&#x27;s name is &quot;Smith&quot; -- not &quot;SMITH&quot;,
   and not &quot;smith&quot;.)  To minimise superfluous processing for those
   Servers which are indifferent to case, all UULP commands are to be
   recognized as such whether they arrive as all upper-case or all
   lower-case.  (They will be shown here as all lower merely for typing
   convenience.) Note that arbitrarily mixed case is not recognized, as
   it is an unwarranted assumption about local implementation to suppose
   that input will necessarily be case-mapped.

   On the second aspect, any Server which does distinguish between
   upper- and lower-case in commands&#x27; arguments (a.k.a. parameters) must
   furnish a UULP &quot;map&quot; command as specified in Appendix 2 in order to
   support logins from upper-case-only terminals attached to User Hosts
   which either do not support the Telnet Protocol&#x27;s dictum that all 128
   ASCII codes must be generable, or support it awkwardly.  This seems a
   simpler and preferable solution than the alternative of legislating
   that upper-case Network-wide personal identifiers (and perhaps even
   Network Virtual Path Names) be pre-conditions to a usable common
   command subset.  (As noted below, these latter concepts will fit in
   smoothly when they are agreed upon.  The point here, though, is that
   we need not deprive ourselves of the benefits of a UULP until they
   are agreed upon.)


User Names

   As implied above, the various Servers have their various ways of
   expressing users&#x27; names.  Clearly, the principle of economy of memory
   dictates that there should be a common intermediate representation of
   names in and for the Network.  It is probably also clear that this
   representation will be based upon the Network Information Center&#x27;s
   &quot;NIC ID&#x27;s&quot;.  However, it is unfortunately amply clear than an
   acceptable mechanism for securing up-to-date information cannot be
   legislated here - much less a mechanism for securely updating the
   implied data base.  Therefore, at this stage it seems to be the



<span class="grey">Padlipsky                                                       [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   sensible thing to specify only the UULP syntax for conveying to the
   Server the fact that it is to treat a user name as a Network-wide
   name rather than as a local name, and let the supporting mechanisms
   evolve as they may.

   The prefacing of a name with an asterisk (&quot;*&quot;) denotes a Network-wide
   name.  (Such names may be either all upper-case or all lower-case, as
   with UULP commands&#x27; names.) The name &quot;*free&quot; is explicitly reserved
   to mean that (in the context of logging in) a login is desired on a
   supported or sampling account, if such an account is available.  The
   response if no such account is available is to be &quot;Invalid ident:
   *free.&quot;  When Network-wide names are generally available Servers will
   either map them into local names or cause them to be registered as
   local names as they prefer.  The point is that a Network-wide name
   will be &quot;made to work&quot; by the Server in the context of the UULP.


Special Characters and Signals

   Another area in which the facts of life must outweigh the letter of
   the Telnet Protocol if the user&#x27;s convenience is to be served is that
   of &quot;erase&quot; and &quot;kill&quot; characters.  It is possible that User Telnets
   will uniformly facilitate the transmission of the Telnet control
   codes for generic character erase and generic line kill.  It is
   certain, however, that User Telnets will differ -- and users will, if
   they use more than one User Telnet, be again placed in the
   uncomfortable position of having to develop too many sets of
   reflexes.  Therefore, the UULP will optionally support the following
   commands: &quot;erase char&quot; and &quot;kill char&quot;, where char is a printable
   ASCII character (to avoid possible conflicts with &quot;control
   characters&quot; which are recognized in the innermost areas of particular
   operating systems).  Presumably, unwary users can be instructed not
   to choose an alphabetic, so as to avoid being placed in a position
   where they cannot invoke certain commands (erase and kill themselves,
   for example, in which case they couldn&#x27;t be changed).

   These commands are supplements to the related Telnet control codes,
   and have the same meanings.  The point here is that it may be far
   more convenient for a user to be able to say &quot;erase #&quot; and get the
   &quot;#&quot; to be recognized as the erase character by the Server than for
   the user to get his User Telnet to send the Telnet equivalent.  The
   commands are designated as optional because they may lead to severe
   implementation problems on some Servers, and because the equivalent
   functions do, after all, exist in Telnet.

      Note: the erasing is assumed to be performed &quot;as early as
      possible&quot;.  That is, the sequence &quot;erase x&quot; &quot;erase x&quot; should come
      out equivalent to &quot;erase x&quot; &quot;erase&quot; -- the second appearance of



<span class="grey">Padlipsky                                                       [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


      &quot;x&quot; resulting in the erasing of the space in the command line.
      Presumably, this is a sufficiently uncommon path that anomalous
      results would be tolerated by the user community, but the intent
      ought to be clear.

   The Telnet &quot;synch&quot; and &quot;break&quot; mechanisms are, by their very nature,
   best left to Telnet.  End of line, however, might well be a different
   story.  Therefore, as a potential convenience, the UULP optionally
   supports &quot;eol char&quot; to ask the Server to treat char as the end of
   line character thenceforth.  To revert to Telnet Newline, &quot;eol&quot;
   (i.e., no argument, current terminator).


Prompts

   Another aspect in which Servers vary while being the same is how they
   indicate &quot;being at command level&quot;.  Some output &quot;ready messages&quot;;
   others, &quot;prompt characters&quot;.  For the UULP, where some functions will
   be performed by means of a command&#x27;s logging in to another system,
   the ability to specify a known prompt character is extremely
   desirable.  The UULP command is &quot;prompt char&quot; where char is the
   character which is to be sent when the user&#x27;s process (on the Server)
   is at command level.  It is explicitly permitted to prefix char to a
   line consisting of a &quot;native&quot; prompt or ready message.  Also, this
   command is explicitly acknowledged to be permissible prior to login.
   (Again, warning must be made of the bad results which can ensue if an
   alphabetic character is chosen.)

      Note: &quot;prompt&quot;, &quot;eol&quot;, &quot;erase&quot;, and &quot;kill&quot; may all be re-invoked
      with a new value of char in order to change the relevant setting;
      all may be turned off by invocation with no argument.


Login

   Perhaps the stickiest wicket of them all is the attempt to specify a
   generic login, but here we go.  The UULP login command is &quot;login
   userident&quot;, where userident is either a locally-acceptable user
   identifier or a Network-wide identifier as discussed above.  Note
   that for utility in contexts to be discussed later, the locally-
   acceptable form must not contain spaces.  Servers may respond to the
   login attempt with arbitrary text (such as a &quot;message of the day&quot;),
   but some line of the response must be one of the following: a prompt
   (as discussed above; indicating, in the present context, successful
   login); &quot;Password:&quot;; or &quot;Invalid ident: userident.&quot;  When passwords
   are required, it is the Server&#x27;s responsibility either to send a mask
   or to successfully negotiate the Hide Your Input option.




<span class="grey">Padlipsky                                                       [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   Note that &quot;login *free&quot; is specifically defined to require no
   password.  (If a &quot;freeloader&quot; has access to a User Telnet and has
   learned of the &quot;*free&quot; syntax, it is fruitless to assume that he
   couldn&#x27;t have also read the common password.) If a password must be
   given, acceptable responses are arbitrary text containing a line
   beginning either with a prompt or with &quot;Login unsuccessful.&quot; or with
   &quot;Account:&quot;.  If an account is requested, the responses must be either
   the &quot;Login unsuccessful&quot; message or the text containing a prompt
   already described.  If any errors occur during the login sequence,
   users are to re-try by starting from the login command.  (I.e., it is
   not required that the Server &quot;remember&quot; idents or passwords.)

   It is explicitly acknowledged that an acceptable response to &quot;login
   *free&quot; is &quot;Limited access only.&quot; (followed by a prompt).  This is
   intended to warn (human) users that the free account on the Server in
   question exists only to allow such functions as accepting mail and
   telling if a particular user happens to be logged in.  (For
   objections to &quot;loginless&quot; performance of such tasks, see <a href="/doc/html/rfc491">RFC 491</a>.
   Note also that nothing here says that a Server must do anything other
   than return a prompt in response to &quot;login *free&quot; in the event that
   loginless operation is natural to it.)  Given the UULP login
   discipline and the &quot;prompt&quot; command, it is reasonably straightforward
   for a program to login on a free account and perform one of these
   functions, for if the login command succeeded, the program will &quot;see&quot;
   a guaranteed prompt character.

   To make life simpler for those Hosts which normally have some sort of
   &quot;daemon&quot; process service mail and the like, a further expansion to
   login is in order.  The point here is that some Hosts may not know
   what sort of process to pass an unqualified &quot;login *free&quot; to, whereas
   they&#x27;d be sure what to do with an explicit request to process mail,
   do a who command, or set up console to console communications.
   Therefore, UULP &quot;login&quot; will allow a &quot;control argument&quot; (as discussed
   above) of either &quot;-mail&quot;, &quot;-who&quot;, or &quot;-concom&quot;, and the respective
   UULP commands involved must use the respective strings in any login
   line they transmit.  Again, nothing is being said about what a Server
   has to do with the information, but some Servers need/want it.


Usage Information

   Most Servers offer some sort of on-line documentation, from calling
   sequences of commands to entire users&#x27; manuals.  There are two sorts
   of information of interest in the UULP environment: &quot;normal&quot; system
   information, and information about the particular Server&#x27;s UULP
   implementation.  To learn how to get descriptions of &quot;native&quot;
   commands, the UULP command is &quot;help -sys&quot; (abbreviation: &quot;?&quot;).  Note
   that &quot;-sys&quot; is viewed as a &quot;control argument&quot; and as such prefaced by



<span class="grey">Padlipsky                                                       [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   a hyphen (&quot;-&quot;) to facilitate distinction from other sorts of name
   (e.g., command names).  To get a description of the Server&#x27;s UULP
   implementation, &quot;help -uulp&quot;.  To get a description of a particular
   UULP command&#x27;s implementation, &quot;help comname&quot;.  To be reminded of how
   to use the help command, &quot;help&quot;.

      Note: as with command names and Network-wide user names, control
      arguments may be either all upper-case or all lower-case.

   It is specifically acknowledged that &quot;No peculiarities.&quot; is an
   appropriate response to &quot;help comname&quot; if nothing of interest need be
   said about the Server&#x27;s implementation of the UULP command in
   question.  (After all, we&#x27;re sparing users the necessity of studying
   a dozen or so users&#x27; manuals; the least they can do is to read the
   UULP command list.)  Appropriate information for less taciturn Hosts
   to furnish would be such data as local command invoked (if such be
   the case), argument syntax (e.g., pathname description, or name of
   help file about pathnames), &quot;To be implemented.&quot;, or even &quot;Not to be
   implemented.&quot;


&quot;Mail&quot;

   Even though a separate mail protocol is being evolved for general
   purposes, the UULP needs to address this topic as, by virtue of being
   login based, it allows systems which do access control and sender
   authentication on mail to make these abilities available to users
   within its framework of generic functions.  Therefore, to read one&#x27;s
   mailbox, the UULP command is &quot;readmail&quot;.  To have &quot;live&quot; input
   collected and sent to a local user, &quot;mail userident&quot;; to a remote
   user, &quot;mail userident -at hostname&quot;, where the arguments have the
   &quot;obvious&quot; meanings.  To send a previously-created file, &quot;mail -f
   filename userident -at hostname&quot;.  Several useridents may be
   furnished; the delimiter is space (blank).  Similar considerations
   apply to hostnames.  If both are lists, they sould be treated
   pairwise.  (A more elaborate syntax could be invented to deal with
   the desire to send to several users at a given host and then to other
   users at other hosts, but it seems unnecessary to do so at this
   point, for multiple invocations would get the job done.)

   The mail command prefaces the message with a line identifying the
   sender (Host and time desirable, but not mandatory).  For &quot;live&quot;
   collection, the end of message is indicated by a line consisting of
   only a period (&quot;.&quot;) followed by the regnant line terminator (usually
   the Telnet Newline, but see also the discussion of the eol command).
   If remote mail is not successfully transmitted, it is to be saved in
   a local file and that file&#x27;s name is to be output as part of the
   failure message.  (&quot;Queueing&quot; for later transmission is admired, but



<span class="grey">Padlipsky                                                       [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   not required.) The transmission mechanism will follow the general
   mail protocol.  Note that when invoked with a &quot;-at&quot; clause, the mail
   command will send &quot;login *free -mail&quot; to the remote Host(s), followed
   by a mail command with no &quot;-at&quot; clause.

   A desirable, but not required, embellishment to &quot;readmail&quot; would be
   the accepting of a Host name (&quot;-at hostname&quot;) to cause the local Host
   to go off to the named Host (via &quot;login *free -mail&quot;) and check for
   mail there.  Several hostnames could, of course, be specified.  A
   further embellishment, which would probably be quite expensive, would
   be to accept &quot;-all&quot; as a request to check all Hosts (or, perhaps, all
   Hosts known to have a free account for the purpose) for mail.


Direct Communication

   The ability to exchange messages directly with other logged in users
   is apparently greatly prized by many users.  Therefore, despite the
   fact that there is a sense in which this function is not within the
   purview of the UULP, we will address it, after a digression.

      Digression: The UULP assumes that there can be straightforward
      &quot;front ends&quot; at the various Servers which translate generic
      function calls in a common spelling to calls for specific, pre-
      existing &quot;native&quot; functions.  In the area of console to console
      communications, however, this premise does not really hold.  The
      problem is that both major &quot;native&quot; implementations known to the
      author are seriously flawed.  The TENEX &quot;link&quot; mechanism is both
      insecure (you&#x27;ve got no business seeing everything I type even if
      I&#x27;m careless enough to let you) and inconvenient (why should I be
      forced to remember that pesky semi-colon?  how do I get back into
      phase after I&#x27;ve forgotten one?).  It is also likely to be
      extremely difficult to simulate on systems which do not force
      Network I/O through local TTY buffers, even if the user interface
      were not subject to criticism.  The Multics &quot;send_message&quot;
      mechanism, on the other hand, has a more sophisticated design, but
      is absurdly expensive.  Therefore, the UULP mechanism to be
      described assumes that, for this function, new local
      implementations will be developed to support it.

   To permit console to console communications: &quot;concom -on&quot;; to refuse,
   &quot;concom -off&quot;.  Default is off.  To enter message-sending mode:
   &quot;concom userident -at hostname&quot; (&quot;-at&quot; clause is optional).  To exit
   from message-sending mode, type a line consisting of only a period
   (cf.  Mail, above).  While in message-sending mode, each line will be
   transmitted as a unit.  The first message sent by concom must be
   prefaced by an identifying line, beginning &quot;From:&quot; and containing an
   appropriate address to which to reply.  The closing period-only line



<span class="grey">Padlipsky                                                      [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   should be transmitted, so as to allow the other concom to close as
   well.  Acceptable error response is &quot;Not available: userident.&quot;
   (which neither confirms nor denies the existence of the particular
   user -- a matter of concern on the security front).  The command
   must, of course, do whatever is necessary to transmit the messages;
   i.e., if locally invoked, access the local mechanism, and if invoked
   for remote communications, access the remote Host&#x27;s concom command
   (via &quot;login *free -concom&quot;).  Thus, a user at a TIP would use the
   local form of concom on the Host of the other party if this is
   convenient, or would use the remote form on his &quot;usual&quot; Server if the
   direct use is inconvenient for some reason (such as having no account
   there, say).

   The prerequisites for establishing communications are to find out if
   the user is logged in, and what &quot;address&quot; to use if so.  The
   mechanism for gathering this information is an expanded &quot;who&quot;
   command.  (Note that &quot;who&quot; is the UULP command to invoke the generic
   who&#x27;s logged in function, with no constraints on format of reply.)
   The syntax is &quot;who userident -at hostname&quot;, where both arguments may
   be multiple.  If no &quot;-at&quot; clause, then check local Host only.
   Response must begin &quot;From hostname: userident:&quot; followed by either an
   appropriate address (e.g., &quot;ll&quot; if local &quot;concom&quot; uses TTY numbers
   and userident is logged in on TTY ll), or &quot;Not available.&quot;

   As with mail, a &quot;-all&quot; embellishment might be pleasant.  Note that
   the search for the specified user(s) -- whether or not &quot;-all&quot; is used
   -- still assumes that a &quot;login *free -who&quot; login will be used on the
   appropriate remote Host(s), followed by &quot;who userident&quot;.  This is why
   responses to the expanded who command must be so rigidly specified.
   Note also that regardless of whether the inquiry is made in terms of
   Network-wide or local user name, the response must be appropriate for
   use in &quot;concom&quot;.

   &quot;Good&quot; concom implementations will presumably do an expanded who
   command automatically, so as to spare the user the necessity of
   having to do it separately.  Indeed, the -concom control argument to
   login is defined to imply the ability to do a who as well as a concom
   to cater to this possibility.  It is tempting to legislate that such
   an approach be the rule, but the implementation implications are not
   quite clear enough to do so.  The implicit who should be viewed as a
   strong hint to implementers, though.

File Creation and Manipulation

   The common command subset must furnish the ability to create and
   manipulate files.  Creation is necessary in order to send mail on the
   one hand, and to produce source files for subsequent compilation on
   the other hand.  Manipulation (such as copying, renaming, typing out,



<span class="grey">Padlipsky                                                      [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   and the like) is necessary both as a convenience aspect for users who
   seek to operate only in the common command language and as a means of
   performing desired batch functions (see below).  For file
   manipulation commands, the user could enter the File Transfer
   Protocol environment.  However, the FTP user interface is constrained
   by a very high degree of program-drivability.  It is also lacks
   abbreviations and suffers from the lack of mnemonicity dictated by
   limiting command names to four characters.  Further, some valuable
   functions (such as causing a file to be typed out) are not dealt
   with.  Therefore, various UULP file manipulation commands are given
   in Appendix 1.  They need not be addressed in detail here.  However,
   some context would be useful:

   The file manipulation commands assume that all Servers have some
   notion roughly corresponding to &quot;the user&#x27;s working directory&quot;.  All
   file names, whether the yet to be invented Network Virtual Pathname
   or the &quot;local&quot; variety, are taken to refer to files in this directory
   unless otherwise indicated.  That is, the user should not have to
   furnish &quot;dsk:&quot; or the like; it is taken as given that when he refers
   to file &quot;x&quot; he means &quot;the file named &#x27;x&#x27; in my current working
   directory&quot; and the Server &quot;knows&quot; what that means.

   At the present stage of development of the UULP, it does not seem
   fruitful to go into a reasoned explication of the following
   statement.  For now, suffice it to say that those file manipulation
   commands (a copy of a foreign file, for example) which need to employ
   the FTP do employ the FTP and let it go at that.  As the context and
   implications of the protocol become more widely understood, the
   detailed implementation notes will be added to the file commands --
   and refined for the other commands, doubtless.  In a way, the common
   file commands may be viewed as a kind of &quot;User FTP&quot; of known human
   interface when they deal with foreign files.  (And, of course, until
   there&#x27;s a Network virtual pathname, the issue doesn&#x27;t really arise.)
   I expect that an &quot;identify&quot; command might be desirable, so that UULP
   commands which have to access other Servers in turn on behalf of the
   specific current user can have the necessary login information
   available to them.  Such a command is included in Appendix 1, but
   should rank as speculation for now.

   On the topic of file creation, matters are rather complicated.  It is
   clear that the ability to create files in the UULP environment is
   extremely desirable.  It is also clear that using mail to a fake
   address to get the file created, then renaming the &quot;unsent mail&quot; file
   is too byzantine to expect users to do.  Unfortunately, it is not
   clear exactly what the alternative is.  That is, it&#x27;s fairly clear
   that we need a common editor, but it&#x27;s not at all clear which editor
   it should be.




<span class="grey">Padlipsky                                                      [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   Two widely-known editors come to mind: TECO and QED.  However, not
   everybody has them.  Even if everybody did, the &quot;dialects&quot; problem is
   bound to be a large one.  Even if all the relevant system programmers
   could agree, there remains the question of whether the intended user
   population would be willing to bother learning a language as complex
   as TECO or QED.  Therefore an optional UULP command to be called
   &quot;neted&quot; is proposed.  (See also <a href="/doc/html/rfc569">RFC 569</a>.) This editor is a line-
   oriented context editor (no &quot;regular expressions&quot;, but also no line
   numbers).  It is copiously documented in Chapter 4 or the Multics
   Programmers&#x27; Manual, including an annotated listing of the (PL/I)
   source code.  A simple user&#x27;s guide has been prepared (see Appendix
   3).  Several implementations already exist, and commitments have been
   made for more.  It may also be repugnant to some of the system
   programmers who would be called upon to implement it -- which is why
   it is optional, until and unless higher authority makes it mandatory.


Other Protocols

   The nominal initial impetus for proposing a UULP was to allow new
   Network user protocols to be invokable through a common mechanism,
   rather than requiring a new responding mechanism to be built for a
   new contact socket for each new protocol.  Although this goal has
   been shunted into the background by the admission of the true goal of
   the UULP, it has not been dropped completely.  Therefore, to enter
   the FTP Server environment, the UULP command is &quot;ftp&quot;; to enter the
   RJE Server environment, the UULP command is &quot;rje&quot;.  Exit is as per
   the respective protocols.  (Where possible, exit should be back to
   the UULP environment.)


Invoking Foreign Programs

   There are two broad contexts in which it is desirable to cause a
   specific local program to be invoked from the common command
   environment: The User side of the connection may itself be a program,
   and the desired Server side program a specifically cooperating one;
   this is the more sophisticated context, of course.  The less
   sophisticated context assumes that the User side is a &quot;live&quot; user,
   and the desire is to invoke a compiler or an object program the user
   has already compiled in the common language -- again as a convenience
   to the user so that he may operate in a sort of &quot;Server-transparent&quot;
   mode.  (The latter case also covers &quot;batch&quot; use of the Server; see
   below.)  In both contexts, the important role of the UULP is to
   specify the mechanisms through which the particular programs may be
   invoked, irrespective of the idiosyncrasies of the Servers&#x27; command
   languages.




<span class="grey">Padlipsky                                                      [Page 13]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-14" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   Programming languages are much too big a problem to tackle here.
   However, assuming that a user somehow manages to create a source
   program, he still wants some commonality of spelling in invoking the
   appropriate compiler, or even the object program.  As an optional but
   strongly recommended UULP command, then, &quot;call name&quot; should invoke
   object program name (where the named program may be a &quot;native&quot;
   command with arguments specified as appropriate).  The values &quot;pl1&quot;,
   &quot;-basic&quot;, &quot;-fortran&quot;, &quot;-lisp&quot;, etc., should be recognized as
   requesting the invocation of the appropriate language processor (to
   operate on a named source file or interpretively/interactively if no
   source file was named), with &quot;reasonable&quot; defaults in effect.  Note
   that this all is meant to imply that &quot;native&quot; commands are not
   directly invokable from the UULP environment (other than by &quot;call&quot;),
   to avoid potential naming conflicts between system commands and new
   UULP commands.

      Note that the &quot;call&quot; command in the UULP environment constitutes a
      rubric for &quot;parallel&quot; computation, given any ad hoc convention for
      the return of completion information.  (Writing on the Telnet
      write socket plus 2 would seem appropriate, provided the initiator
      has the ability to &quot;listen&quot; for the rfc; but even a response in
      the data stream as a special-cased program is assumed on the
      &quot;user&quot;side anyway.)


Other Matters

   The topic of &quot;batch&quot; mode merits some attention.  As with the file
   manipulation commands, more consultation is necessary for a firm
   spec.  However, I suspect that a &quot;-batch&quot; control argument to login
   should initiate batch mode processing by the Server, and given the
   call and identify commands all we might then require is a convention
   for designating the output file in order to return it via a copy
   command in the &quot;job&quot; itself (if output is to be returned rather than
   stored at the Server).  Of course, -batch will probably need some
   substructure as to password and timing matters.  More details will
   emerge in this area in future iterations.

   An admittedly fictionalized scenario might look like this:

   login Me -batch -pw xxx -shift 3
   copy *452&lt;me&gt;source.text source.pl2
   call -pl2 source
   call source input output
   identify Me2 yyy
   copy output *555&gt;root&gt;Me&gt;output452
   logout




<span class="grey">Padlipsky                                                      [Page 14]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-15" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   where user &quot;Me&quot; wants the Server receiving the commands (either
   directly from him at a TIP or perhaps from some other Server on which
   he has created a file containing them) to set up a batch job for him,
   with password &quot;xxx&quot;, to be run on Shift 3 (whenever that is).  The
   job first copies file &quot;source.text&quot; from directory &quot;&lt;me&gt;&quot; on Host 452
   into local file &quot;source.pl2&quot;, then compiles it with the local PL2
   compiler, executes it (assuming a &quot;Not found&quot; response would go into
   a known file if compilation had failed) with specified arguments
   (presumably the names of files for input and output), then copies the
   &quot;output&quot; file to Host 555&#x27;s file hierarchy at the indicated place,
   using the user identifier &quot;Me2&quot; and the password &quot;yyy&quot;.  It&#x27;s not
   elegant, but it ought to work.

   Finally, on the topic of logging out, the UULP command is &quot;logout&quot;.
   The Server must close the Telnet connection after doing whatever is
   appropriate to effect a logout.  To retain the Telnet connection,
   &quot;logout -save&quot;.  Having the Server close is viewed as a convenience
   for the user, in that it spares him the necessity of causing his User
   Telnet to close.  It is also desirable for program-driven
   applications, so as not to leave the connections &quot;dangling&quot; and not
   to require possibly complex negotiations with the User side to break
   the connection.


APPENDIX 1.  THE COMMON COMMAND SUBSET

   Syntax                                                   Opt

   I. &quot;Set-up&quot; Commands


   login id arg
   The id may be Network-wide or Host-specific.
   &quot;*free&quot; is reserved.
   The arg may be &quot;-mail&quot;, &quot;-who&quot;, &quot;-concom&quot;,
   &quot;-batch&quot;, or may be absent.
   Result is to be either logged in or passed off to appropriate daemon.

   prompt char
   Specifies that char is to become or
   precede the normal prompt message.
   Acceptable prior to login.

   erase char                                                X
   Specifies that char is the erase character.
   Invocation with no argument reverts to default.

   kill char                                                 X



<span class="grey">Padlipsky                                                      [Page 15]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-16" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   Specifies that char is the kill character.
   Invocation with no argument reverts to default.

   eol char                                                  X
   Specifies that char is the newline character.
   Invocation with no argument reverts to default.

   local
   Enter the local command environment.

   ftp
   Enter the FTP environment.

   rje
   Enter the RJE environment.
   logout
   Logout and sever the Telnet connection.

   logout -save
   Logout but keep the Telnet connection.

   map
   Apply the case-mapping conventions of Appendix 2.
   Required on Hosts to which case is significant.

   identify id arg                                            X
   Specifies that id is to be used as the user
   identifier in any &quot;fanout&quot; logins required.
   If arg is specified, it is to be either the
   password to be used in such logins or &quot;-pw&quot;, in
   which case the Server will furnish a mask or negotiate the Hide Your
   Input Telnet option; if no arg, then no password is to be furnished
   on fanout logins.
   Default id is &quot;*free&quot;.



   II.  Communications Commands


   readmail
   Type out &quot;mailbox&quot;.


   readmail (id) -at host                                     X
   Type out &quot;mailbox&quot; on remote Host host.
   Multiple Hosts may be specified,
   separated by spaces (blanks).



<span class="grey">Padlipsky                                                      [Page 16]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-17" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   Implies ability to change working directory
   at host to directory implied by known
   user identifier, or (optionally) by id.

   readmail -all                                              XX

   Search for mail.
   Extremely optional.

   mail id
   Collect input until line consisting of
   only a period (&quot;.&quot;) for mailing to local
   user specified by id.

   mail -f file id
   Send contents of specified file to specified
   local user.

   mail id -at host
   Collect input until line consisting of
   only a period (&quot;.&quot;) for mailing to remote
   user(s) at specified Host(s). Both id and
   host may be multiple, separated by spaces.
   (If multiple, they should be taken pairwise.)

   mail -f file id -at host
   Send contents of specified file to specified
   remote user(s).

   who
   The generic who&#x27;s logged in command.

   who id
   Is id logged in? Constrained responses.

   who id -at host
   Is the specified user logged in at the
   specified host. Constrained responses.

   concom -on
   Enable console to console communications.

   concom -off
   Disable console to console communications.

   concom id
   Send messages to specified local user
   until line consisting of only a period (&quot;.&quot;).



<span class="grey">Padlipsky                                                      [Page 17]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-18" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   concom id -at host
   Send messages to specified remote user.

   III.  File Commands


   type path
   Type out the contents of the specified file.
   Pathname may be local or Network-wide.
   Default to current working directory.

   listdir
   List the contents of the current working directory.  (Local format
   acceptable.)

   listdir path
   List the contents of the specified directory.

   rename old new
   Change the specified file&#x27;s name as indicated.

   addname old new                                             X
   Give the specified file the specified extra name.

   delete path
   Get rid of the specified file.
   (&quot;Expunge&quot; if necessary.)

   copy from to
   Make a copy of the file specified by the first pathname at the second
   pathname.

   link from to                                                X
   If your file system has such a concept, make a &quot;link&quot; between the two
   pathnames.  If no second argument,
   use same entry name in working directory.

   status path st                                              X
   If your file system has such a concept, give status information about
   the specified file or directory.

   changewd path                                               X
   If no argument, return to the &quot;home&quot; directory.

   typewd
   Type out the pathname of the current working directory.

   neted path



<span class="grey">Padlipsky                                                      [Page 18]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-19" ></span>
<span class="grey"><a href="/doc/html/rfc666">RFC 666</a>               Unified User-Level Protocol          November 1974</span>


   See Appendix 3.

   IV.  Invoking &quot;Native&quot; Programs

   call name (args)
   Invoke the specified program with the
   specified arguments (if any).
   The following names are reserved to indicate the
   invocation of the corresponding language processor: &quot;-pl1&quot;, &quot;-basic&quot;,
   &quot;-fortran&quot;, &quot;-lisp&quot;.
   (If no source file indicated, invoke &quot;interpretively&quot; if possible.)

   V. On-line Documentation


   help name
   Type out information about the specified UULP command.  If name is
   &quot;-sys&quot;, type out information about how to use the local system&#x27;s help
   mechanism; if
   &quot;uulp&quot;, about the local system&#x27;s UULP implementation.  If no name
   given,  describe the command itself.


APPENDIX 2.  MAP COMMAND CONVENTIONS

   This appendix will eventually contain the case-mapping conventions
   detailed in <a href="/doc/html/rfc411">RFC 411</a>.


APPENDIX 3.  EDIT COMMAND REQUESTS

   This appendix will eventually contain descriptions of the neted
   command requests (a draft of which now exists), or a reference to the
   Resource Notebook version, if that gets published first.  For now, it
   should be sufficient to point out that the requests are basically
   locate, next, top, change, save, and quit -- i.e., it&#x27;s the &quot;old-
   fashioned&quot; flavor of context editor.


   [Optical character recognition and initial proofreading performed
   11/20-21/04 by The Author.  A few original typos were corrected; some
   may remain.]









Padlipsky                                                      [Page 19]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

