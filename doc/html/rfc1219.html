<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc1219
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.34.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.34.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-tsuchiya-subnetnos/">
  <meta name="description" content="On the assignment of subnet numbers (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.34.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.34.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgorange"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc1219.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc1219.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc1219.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc1219/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc1219/" title="Datatracker information for this document">Tracker</a>] [<a href="mailto:draft-tsuchiya-subnetnos@ietf.org?subject=draft-tsuchiya-subnetnos" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-tsuchiya-subnetnos-00.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-tsuchiya-subnetnos-00">draft-tsuchiya-subnetnos-00</a>                          Informational</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Network Working Group                                        P. Tsuchiya
Request for Comments: 1219                                      Bellcore
                                                              April 1991


                  <span class="h1">On the Assignment of Subnet Numbers</span>

Status Of This Memo

   This memo suggests a new procedure for assigning subnet numbers.  Use
   of this assignment technique within a network would be a purely local
   matter, and would not effect other networks.  Therefore, the use of
   these procedures is entirely discretionary.

   This memo provides information for the Internet community.  It does
   not specify an Internet standard.  Distribution of this memo is
   unlimited.

Overview

   <a href="/doc/html/rfc950">RFC-950</a> [<a href="#ref-2">2</a>] specifies a procedure for subnetting Internet addresses
   using a bit-mask.  While <a href="/doc/html/rfc950">RFC-950</a> allows the &quot;ones&quot; in the subnet mask
   to be non-contiguous, <a href="/doc/html/rfc950">RFC-950</a> recommends that 1) they be contiguous,
   and 2) that they occupy the most significant bits of the &quot;host&quot; part
   of the internet address.

   <a href="/doc/html/rfc950">RFC-950</a> did not specify whether different subnets of the same network
   may have different masks.  This ambiguity was unfortunate, as it
   resulted in development of routing protocols that do not support
   different masks; see e.g., RIP [<a href="#ref-6">6</a>].  The Gateway Requirements RFC [<a href="#ref-7">7</a>]
   settled the issue in favor of allowing different masks, and therefore
   future routing protocols may be expected to support this feature;
   OSPF [<a href="#ref-3">3</a>] is an example.

   The network administrator must of course determine the mask for each
   subnet.  This involves making an estimate of how many hosts each
   subnet is expected to have.  As it is often impossible to predict how
   large each subnet will grow, inefficient choices are often made, with
   some subnets under-utilized, and others possibly requiring
   renumbering because of exceeded capacity.

   This memo specifies a procedure for assigning subnet numbers that
   eliminates the need to estimate subnet size.  Essentially, host bits
   (mask = 0) are assigned from the least significant bit working
   towards the most, and subnet bits (mask = 1) are assigned from the
   most significant bit working towards the least.  As subnets grow,
   more host bits are assigned.  As the number of subnets grows, more
   subnet bits are assigned.  While this process does sometimes result



<span class="grey">Tsuchiya                                                        [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


   in new subnet masks, no host ever need change addresses.

   This technique is not new, but it is also not widely known, and even
   less widely implemented.  With the development of new routing
   protocols such as OSPF, it is possible to take full advantage of this
   technique.  The purpose of this memo, then, is to make this technique
   widely known, and to specify it exactly.

   This memo requires no changes to existing Internet standards.  It
   does, however, require that the intra-domain routing protocol handle
   multiple different subnet masks.

Acknowledgments

   The author would like to thank Phil Karn, Charles Lynn, Jeff Mogul,
   and Charles Wolverton for their helpful suggestions.  Special thanks
   go to Joel Halpern for his painstaking debugging of the detailed
   specification and the examples.

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Motivation</span>

   The Subnetting standard, <a href="/doc/html/rfc950">RFC-950</a>, specifies that the Host part of the
   formally 2-level Internet address can be divided into two fields,
   Subnet and Host.  This gives the Internet address a third level of
   hierarchy, and the concomitant firewalls and savings in routing
   overhead.  It also introduces increased inefficiency in the
   allocation of addresses.

   This inefficiency arises from the fact that the network administrator
   typically over-estimates the size (number of hosts) of any single
   subnetwork, in order to prevent future re-addressing of subnets.  It
   may also occur if the routing protocol being used does not handle
   different length subnets, and the administrator must therefore give
   every subnet an amount of space equivalent to that received by the
   largest subnet. (This RFC does not help in the latter case, as the
   technique herein requires different length subnets.)

   The administrative hassle associated with changing the subnet
   structure of a network can be considerable.  For instance, consider
   the following case.  A network has three subnets A, B, and C.  Assume
   that the lowest significant byte is the host part, and the next byte
   is the subnet part (that is, the mask is 255.255.255.0).  Assume
   further that A has subnet 1.0, B has subnet 2.0, and C has subnet
   3.0.

   Now, assume that B grows beyond its allocation of 254 hosts.
   Ideally, we would like to simply change B&#x27;s mask without changing any
   of the host addresses in B.  However, the subnets numerically above



<span class="grey">Tsuchiya                                                        [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


   and below B are already taken by A and C.  (If say 3.0 was not taken
   by C, B&#x27;s mask could be changed from 255.0 (ff00) to 254.0 (fe00).
   In this case, all of B&#x27;s existing addresses would still match the new
   subnet.  Indeed, if non-contiguous masks were in use, it might be
   possible for B to find some other mask bit to change to 0.  However,
   non-contiguous masks are generally not in favor, as they impose
   limitations on certain forwarding table lookup algorithms.  Indeed,
   <a href="/doc/html/rfc950">RFC-950</a> discourages their use.)

   So, the choices available to the network administrator are to 1) form
   two subnets out of the existing one, or 2) renumber the subnet so
   that the subnet ends up with a smaller (fewer 1&#x27;s) mask.  Choice 1
   can either be accomplished physically or logically.  Physically
   forming two subnets requires partitioning the subnet and inserting a
   gateway between the two partitions.  For obvious reasons, this is not
   a desirable course of action.  Logically forming two subnets can be
   done by simply assigning another subnet number (say 4.0) to the same
   subnet, and assigning host addresses under the new subnet.  The
   result of this logical partition is that the hosts with different
   subnet numbers will not recognize that the others are on the same
   subnet, and will send packets to the default gateway rather than
   directly to the host.  In fact, this is not such a bad solution,
   because assuming that the gateway is capable of recognizing multiple
   subnet numbers on the same subnet, the gateway will simply send the
   host an ICMP Redirect [<a href="#ref-4">4</a>], and subsequent packets will go directly to
   the host [<a href="#ref-1">1</a>] (this may not work correctly on all hosts).

   If, however, neither choice is acceptable or possible, then the
   network administrator must assign a new subnet number to B, thus
   renumbering the existing hosts, modifying the Domain Name System
   entries, and changing any other configuration files that have
   hardwired addresses for hosts in subnet B.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>. A More Flexible and Efficient Technique for Assigning Subnet Numbers</span>

   In order to help explain the new technique, we shall show what is
   wrong with what is currently done now.  Currently, most subnets are
   assigned by splitting the host part of the address in two fields; the
   subnet field and the host field.  Mask bits are one for subnet field
   bits, and 0 for host field bits.  (In all of our addresses, the least
   significant bit (LSB) is on the right, the most significant bit (MSB)
   is on the left.)

        MSB                                LSB
        --------------------------------------
       | subnet field    | host field         |
        --------------------------------------




<span class="grey">Tsuchiya                                                        [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


   The subnet field could be different lengths for different size
   subnets.  For instance, say a network had two large subnets and the
   rest small subnets (by large subnet we mean a large number of hosts).
   Then the network administrator might assign two types of addresses:

        --------------------------------------
       | subnet |               host          |  large subnets
        --------------------------------------

        --------------------------------------
       |         subnet             |  host   |  small subnets
        --------------------------------------

   In this case, the full range of subnet numbers would not be available
   to the small subnets, as the bits in the small subnet that correspond
   to those in the large subnet could not have the same values as those
   in the large subnets.  For instance, say that the large subnets had
   4-bit subnet numbers, and the small subnets had 8-bit subnet numbers.
   If the large subnets had values 0001 and 0010, then subnet numbers in
   the range 00010000 to 00101111 could not be assigned to the small
   subnets, otherwise there will be addresses that would match both
   subnets.

   In any event, a network administrator will typically assign values to
   the two fields in numerical order.  For example, within a given
   subnet, hosts will be numbered 1, 2, 3, etc.  Within a given network,
   subnets will be numbered 1, 2, 3, etc.  The result is that some
   number of bits on the right side of the subnet and host fields will
   be ones for some hosts and zeros for others, and some number of bits
   on the left side of the subnet and host fields will be zeros for all
   subnets and hosts.  The &quot;all zeros&quot; bits represent room for growth,
   and the &quot;ones and zeros&quot; bits represent bits already consumed by
   growth.

        --------------------------------------
       | subnet field    | host field         |
       |-----+-----------+-------+------------|
       |     |           |       |            |
       | 0&#x27;s | 1&#x27;s &amp; 0&#x27;s |  0&#x27;s  | 1&#x27;s &amp; 0&#x27;s  |
          /\                /\
          ||                ||
        subnets can         hosts can grow here
        grow here

   Now, let&#x27;s assume that the number of hosts in a certain subnet grows
   to the maximum allowed, but that there is still room in the subnet
   field to assign more addresses.  We then have the following:




<span class="grey">Tsuchiya                                                        [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


        --------------------------------------
       | subnet field    | host field         |
       |-----+-----------+--------------------|
       |     |           |                    |
       | 0&#x27;s | 1&#x27;s &amp; 0&#x27;s |     1&#x27;s &amp; 0&#x27;s      |


   While the host field can no longer grow, there is still room in the
   address for growth.  The problem is that because of where the growth
   areas are situated, the remaining growth has been effectively
   reserved for subnets only.

   What should be done instead is to assign subnet numbers so that the
   ones start from the left of the subnet field and work right.  In this
   case we get the following:

        --------------------------------------
       | subnet field    | host field         |
       |-----------+-------------+------------|
       |           |             |            |
       | 1&#x27;s &amp; 0&#x27;s |    0&#x27;s      | 1&#x27;s &amp; 0&#x27;s  |
                         /\
                         ||
                    Both hosts and subnets can
                    grow here

   Now, both hosts and subnets individually have considerably more
   growing space than before, although the combined growing space is the
   same.  Since one can rarely predict how many hosts might end up in a
   subnet, or how many subnets there might eventually be, this
   arrangement allows for the maximum flexibility in growth.

   Actually, the previous figure is misleading.  The boundary between
   the host and subnet fields is being shown in the middle of the growth
   area.  However, the boundary could exist anywhere within the growth
   area.  Note that it is the mask itself that determines where the
   boundary is.  Ones in the mask indicate subnet bits, and zeros
   indicate host bits.  We will show later that in fact the boundary
   should lie somewhere in the middle.  Putting it there minimizes the
   number of times that the masks must be changed in hosts.

   2.1  Specification of the New Technique

   Having given the appropriate explanatory material, we can now specify
   the procedure for subnet number assignment.  We need the following
   definitions:

   Host-assigned Bits (h-bits):  These are the bits, contiguous from



<span class="grey">Tsuchiya                                                        [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


      the right, for which host values, within a given subnet, contain
      both ones and zeros.  Different subnets may have different h-bits.

   Subnet-assigned Bits (s-bits):  These are the bits, contiguous from
      the left, which 1) are not h-bits, AND 2) are required to
      distinguish one subnet from another, AND 3) include all bits
      to the left of and including the right-most one.  Notice that
      different subnets may have different s-bits.

   Growth Bits (g-bits):  These are the &quot;all zeros&quot; bits in between
      the h-bits and s-bits.

   s-mask:  For a given subnet, the mask whereby all s-bits are one,
      and all g-bits and h-bits are zero.

   g-mask:  For a given subnet, the mask whereby all s-bits and g-bits
      are one, and all h-bits are zero.

   Subnet Field:  These are the one bits in the subnet mask (as
      defined in <a href="/doc/html/rfc950">RFC-950</a>).  These bits are on the left.  The subnet
      field must at least include all of the s-bits, and may
      additionally include some or all of the g-bits.

   Host Field:  These are the zero bits in the subnet mask.
      These bits are on the right.  The host field must at least
      include all of the h-bits, and may additionally include some
      or all of the g-bits.

   Mirror-image Counting:  Normal counting, in binary, causes one
      bits to start at the right and work left.  This is how host
      values are assigned.  However, for subnet assignment, we want
      the one bits to start at the left and work right.  This process
      is the mirror image of normal counting, where the MSB is swapped
      with the LSB, the second MSB is swapped with the second LSB, and
      so on.  So, where normal counting is:

                0       (reserved to mean &quot;this host&quot;)
               01
               10
              011
              100
              101
              :
              :
        11...<a href="#page-1110">1110</a>
        11...1111       (reserved to mean &quot;all hosts&quot;)

      and so on, Mirror-image, or MI counting, is:



<span class="grey">Tsuchiya                                                        [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


        0       (reserved to mean &quot;this subnet&quot;)
        10
        01
        110
        001
        101
          :
          :
        011...<a href="#page-11">11</a>
        111...11        (reserved to mean &quot;all subnets&quot;)

      and so on.  If the current MI counting value is, say, 001,
      the &quot;next&quot; MI value is 101, and the &quot;previous&quot; MI value is 11.

   Now we can specify the algorithm.  We have the following functions:
   Initialize(), AddSubnet(), RemoveSubnet(subnet#), AddHost(subnet#),
   and RemoveHost(subnet#,host#).

   Notice that the algorithm is described as though one state machine is
   executing it.  In reality, there may be a root Address Authority
   (RootAA) that assigns subnet numbers (Initialize, AddSubnet, and
   RemoveSubnet), and subnet AA, that assign host numbers within a
   subnet (AddHost and RemoveHost).  While in general the AAs can act
   independently, there are two cases where &quot;coordination&quot; is required
   between the rootAA and a subnetAA.  These are the cases where either
   the rootAA or the subnetAA &quot;grabs&quot; the last growth bit (in the former
   case because another subnet has been added, and in the latter because
   another host has been added).  Since it is impossible for the rootAA
   and a subnetAA to simultaneously grab the last growth bit, either one
   or the other must do it.

   Finally, note that the following C language style notation is used:
        &amp;               bit-wise AND function
        ==              is equal to
        !=              is not equal to
        x-mask(X)       the x-mask of X (where x is s or g)

   Initialize():
      Assign the first subnet value to be 0 (the value reserved to mean
      &quot;this subnet&quot;).  This is not assigned to any real subnet.

   AddSubnet():
      1.  Find the lowest non-zero (in MI counting) non-assigned subnet
          number S such that (S &amp; g-mask(Y)) != (Y &amp; g-mask(Y)) for all
          existing subnet numbers Y, (Y != S).
      2.  If all bits in S from the rightmost one bit left are ones,
          then label all bits to the left of and including one bit
          position to the right of the rightmost one bit in S to be



<span class="grey">Tsuchiya                                                        [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


          s-bits. Else, label all bits to the left of and including the
          rightmost one bit in S to be s-bits.  This prevents the &quot;all
          ones&quot; value (which is the &quot;all subnets&quot; broadcast address)
          from being assigned to a subnet.  (Since no hosts have been
          added, the rightmost one bit is a subnet bit.)
      3.  Label all other bits in the address to be g-bits.  (By
          address, we mean that part of the IP address not including
          the network number.)
      4.  Set the subnet mask to include at least all s-bits, and
          optionally some g-bits.  The subnet mask must be contiguous.
          (<a href="#section-2.2">Section 2.2</a> discusses the pros and cons of choosing a mask.)
      5.  For all existing subnet numbers Y (Y != S):
          51. If (S &amp; s-mask(Y)) == (Y &amp; s-mask(Y)), then:
              511.  Change the leftmost g-bit of Y to an s-bit.  If
                    the rootAA and YAA (the address authority for Y) are
                    separate AAs, then the YAA must be informed of the
                    change of bit status.  If this is the last g-bit,
                    then this change must be coordinated with YAA.
              512.  Expand the subnet mask for all hosts in Y if
                    necessary (that is, if the subnet mask no longer
                    includes all s-bits).

   RemoveSubnet(S):
      1.  Consider B to be the bit position of the rightmost s-bit in S.
      2.  Remove S.
      3.  For all existing subnet numbers Y:
          31.  If the bit in position B is not an s-bit, or if the bit
               in bit position B is a one, or if the bit in bit position
               B is a zero and all bits to the left of bit position B
               are ones, then do nothing (skip steps 32 and 33).
          32.  Change the s-bit in position B to a g-bit.
          33.  If for any other existing subnet numbers X
               (X &amp; s-mask(Y)) == (Y &amp; s-mask(Y)), then change the
               g-bit in position B back into an s-bit for Y.  Else,
               inform YAA that of the change of bit status.

   AddHost(S):
      1.  Create an address A consisting of subnet number S concatenated
          with zeros.
      2.  Assign to A the same h-bits, g-bits, and s-bits as the
          other host addresses.
      3.  Find the lowest non-zero (using normal counting) non-assigned
          host number H.
      4.  If all bits from the leftmost one bit to bit position 0 are
          ones, then execute steps 5 and 6 using bit position B equals
          one bit position to the left of the leftmost one bit in H.
          Else, execute steps 5 and 6 with bit position B equals
          the leftmost one bit in H.  This prevents the &quot;all ones&quot; value



<span class="grey">Tsuchiya                                                        [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


          (which is the &quot;all hosts&quot; broadcast address) from being
          assigned to a host.
      5.  If bit position B is an s-bit, then the host cannot be added.
          Skip the remaining steps.
      6.  If bit position B is a g-bit:
          61.  Change the g-bit to an h-bit for all hosts in S.  Note
               that if this is the last g-bit, this change must be
               coordinated with the address authority assigning subnet
               numbers (see <a href="#section-2.2">section 2.2</a>).
          62.  Modify the subnet mask in all hosts if necessary.
      7.  Create a new address A consisting of S concatenated with H
      8.  Assign A to the host.

   RemoveHost(S,H):
      1.  Remove H.
      2.  If for all remaining host numbers in S, the value of the bit
          position of the leftmost h-bit is zero, and there is a zero in
          at least one of the bit positions to the right of the leftmost
          h-bit, then for all hosts change the leftmost h-bit into a
          g-bit.

      It is worth noting here that this technique is a 2-level subset of
      the more general n-level kampai addressing [<a href="#ref-5">5</a>].  The main
      difference here is that n-level kampai results in non-contiguous
      masks, while 2-level does not.  In the description of kampai
      addressing in [<a href="#ref-5">5</a>], g-bits are called a-bits, h-bits are called
      g-bits, and s-bits are called i-bits.

   2.2  An Example

   For this example, we assume a class C network, so we will only need
   to work with 8 bits.  We start with 3 subnets, A, B, and C.  Our
   nomenclature is h for h-bit and g for g-bit.  Note that h-bits can be
   one or zero, but g-bits are all zero.  The remaining bits are s-bits,
   but are shown as 1&#x27;s and 0&#x27;s according to the subnet number
   assignment.  The space is just to make the addresses and masks easier
   to read.  Finally, we number our bits 0 to 7 from right to left as
   shown below.

        Subnet  Address         Mask
        A       10gg ghhh       1111 0000
        B       01gg ghhh       1111 0000
        C       110g ghhh       1111 0000
            bit 7       bit 0

   We see that each subnet has at most 6 hosts (because of the three h-
   bits).  Notice that we have chosen the masks so that there is room
   for growth in both hosts and subnets without requiring a mask change.



<span class="grey">Tsuchiya                                                        [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


   However, we have generally allowed for more growth in subnets than in
   hosts because adding new subnets can cause mask changes in existing
   subnets, while adding new hosts in a subnet only causes that subnet&#x27;s
   mask to change.

   Further, if a subnet&#x27;s mask must change, but not all hosts are
   reconfigured at the same time, then it is less damaging if the not
   yet reconfigured hosts have too large a mask (too many ones) than if
   they have too small a mask.  This is because with too large a mask, a
   host may think that another host which is in fact on the subnet is on
   another subnet.  In this case, the host will send packets to the
   gateway, and will be redirected to the host.

   However, with too small a mask, a host may think that another host
   which is in fact not on the subnet is on the subnet, and will ARP for
   that host but receive no reply.  (Note that broadcasts may fail if
   all masks do not match.)

   Finally, notice that subnet C requires three s-bits instead of just
   two.  This is because with just two, the subnet address of C could be
   &quot;11&quot; (rather than &quot;110&quot;), which is a broadcast value.  Step 2 of
   AddSubnet checks for this case.

   Now, a fourth subnet, D, also with 6 hosts, is added.  We get:

        Subnet  Addr            Mask
        A       10gg ghhh       1111 0000
        B       01gg ghhh       1111 0000
        C       110g ghhh       1111 0000
        D       001g ghhh       1111 0000

   Notice that none of the original subnets required a change in any of
   their status bits.  This is because, when D compared its subnet
   number with the others (step 5 of AddSubnet(), using the s-mask),
   they were all different.  In other words, a router would be able to
   distinguish an address in D from addresses in A, B, and C.

   Next, a fifth subnet, E, is added.  We get:

        Subnet  Addr            Mask
        A       100g ghhh       1111 0000
        B       01gg ghhh       1111 0000
        C       110g ghhh       1111 0000
        D       001g ghhh       1111 0000
        E       101g ghhh       1111 0000

   Notice that this time, A was forced to change its leftmost g-bit (bit
   5) into an s-bit, because bit 5 is needed to distinguish subnet A



<span class="grey">Tsuchiya                                                       [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


   from subnet E (step 511 of AddSubnet()).  Changing bit 5 into an s-
   bit prevents hosts from being added to A to the point where bit 5
   would be changed into a one (that is, step 5 of AddHost() would
   fail).

   Notice also that if the masks in A, B, and C were originally set to
   1100.0000, then the addition of E would have caused A&#x27;s mask to
   change to 1110.0000 (Step 512 of AddSubnet()).

   Next, 8 hosts each are added to subnets A and C, thus causing the
   right-most g-bit in each to change to an h-bit.

        Subnet  Addr            Mask
        A       100g hhhh       1111 0000
        B       01gg ghhh       1111 0000
        C       110g hhhh       1111 0000
        D       001g ghhh       1111 0000
        E       101g ghhh       1111 0000

   Notice again that no masks have changed.  If the masks for A, B, and
   C were originally set to 1111 1000, then they would have required
   changing (step 62 of AddHost()).

   Next, enough hosts are added to subnet B that all of its remaining
   g-bits become h-bits.

        Subnet  Addr            Mask
        A       100g hhhh       1111 0000
        B       01hh hhhh       1100 0000
        C       110g hhhh       1111 0000
        D       001g ghhh       1111 0000
        E       101g ghhh       1111 0000

   Notice here that the masks in B&#x27;s subnet had to be changed to
   accommodate the new h-bits (step 62 of AddHost()).  Notice also that
   if the person assigning host addresses for B (B Address Authority, or
   BAA) is different than the person assigning network numbers (RootAA),
   then BAA must coordinate the change of its last g-bit to an h-bit
   with the RootAA.  This allows the RootAA to properly assign
   additional subnet numbers, as in the next step, where we add another
   subnet F:

        Subnet  Addr            Mask
        A       100g hhhh       1111 0000
        B       01hh hhhh       1100 0000
        C       110g hhhh       1111 0000
        D       001g ghhh       1111 0000
        E       101g ghhh       1111 0000



<span class="grey">Tsuchiya                                                       [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


        F       1110 ghhh       1111 0000

   Notice that F received subnet number 1110 rather than subnet number
   011 (which is what comes after 101 in MI counting).  The reason is
   that 1) 011 is not distinguishable from B&#x27;s subnet address using B&#x27;s
   mask, and 2) we can&#x27;t increase B&#x27;s mask to make it distinguishable
   because B has already assigned hosts at bit position 5.  In other
   words, when the comparison of step 1 in AddSubnet() was tried on
   number 011, the two values were equal, and so the next number was
   tried.  In fact, no subnet numbers with 01 in bit positions 7 and 6
   can be assigned (unless B loses hosts).

   Next, subnet E is removed:

        Subnet  Addr            Mask
        A       10gg hhhh       1111 0000
        B       01hh hhhh       1100 0000
        C       110g hhhh       1111 0000
        D       001g ghhh       1111 0000
        F       1110 ghhh       1111 0000

   Notice that this caused subnet A to change an s-bit back into a g-
   bit.  This is because the equality of step 33 of RemoveSubnet() did
   not hold true for subnet A with respect to the remaining subnets.

References

   [<a id="ref-1">1</a>] Braden, R., &quot;Requirements for Internet Hosts -- Communication
       Layers&quot;, <a href="/doc/html/rfc1122">RFC 1122</a>, USC/Information Sciences Institute, October
       1989.

   [<a id="ref-2">2</a>] Mogul, J., and J. Postel, &quot;Internet Standard Subnetting
       Procedure&quot;, <a href="/doc/html/rfc950">RFC 950</a>, USC/Information Sciences Institute, August
       1985.

   [<a id="ref-3">3</a>] Moy, J., &quot;OSPF Specification&quot;, <a href="/doc/html/rfc1131">RFC 1131</a>, Proteon, October 1989.

   [<a id="ref-4">4</a>] Postel, J., &quot;Internet Control Message Protocol&quot;, <a href="/doc/html/rfc792">RFC 792</a>,
       USC/Information Sciences Institute, September 1981.

   [<a id="ref-5">5</a>] Tsuchiya, P., &quot;Efficient and Flexible Hierarchical Address
       Assignment&quot;, TM-ARH-018495, Bellcore, February 1991.

   [<a id="ref-6">6</a>] Hedrick, C., &quot;Routing Information Protocol&quot; <a href="/doc/html/rfc1058">RFC 1058</a>, Rutgers
       University, June 1988.

   [<a id="ref-7">7</a>] Braden, R., and J. Postel, &quot;Requirements for Internet Gateways&quot;,
       <a href="/doc/html/rfc1009">RFC 1009</a>, USC/Information Sciences Institute, June 1987.



<span class="grey">Tsuchiya                                                       [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey"><a href="/doc/html/rfc1219">RFC 1219</a>          On the Assignment of Subnet Numbers         April 1991</span>


Security Considerations

   Security issues are not discussed in this memo.

Author&#x27;s Address

   Paul F. Tsuchiya
   Bellcore
   435 South St.5 South St.
   MRE 2L-281
   Morristown, NJ 07960

   Phone: 201 829-4484

   EMail: tsuchiya@thumper.bellcore.com




































Tsuchiya                                                       [Page 13]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

