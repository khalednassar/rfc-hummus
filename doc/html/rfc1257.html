<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc1257
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.34.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.34.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/rfc1257/">
  <meta name="description" content="Isochronous applications do not require jitter-controlled networks (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.34.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.34.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgorange"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc1257.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc1257.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc1257.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc1257/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc1257/" title="Datatracker information for this document">Tracker</a>] [<a href="mailto:rfc1257@ietf.org?subject=rfc1257" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=rfc1257-.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=rfc1257-.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/rfc1257-.txt" title="Run an idnits check of this document">Nits</a>]

                                                           Informational</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Network Working Group                                       C. Partridge
Request for Comments: 1257         Swedish Institute of Computer Science
                                                          September 1991


   <span class="h1">Isochronous Applications Do Not Require Jitter-Controlled Networks</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard.  Distribution of this memo is
   unlimited.

Abstract

   This memo argues that jitter control is not required for networks to
   support isochronous applications.  A network providing bandwidth and
   bounds delay is sufficient.  The implications for gigabit
   internetworking protocols are briefly considered.

Introduction

   An oft-stated goal of many of the ongoing gigabit networking research
   projects is to make it possible to support high bandwidth isochronous
   applications.  An isochronous application is an application which
   must generate or process regular amounts of data at fixed intervals.
   Examples of such applications include telephones, which send and
   receive voice samples at regular intervals, and fixed rate video-
   codecs, which generate data at regular intervals and which must
   receive data at regular intervals.

   One of the properties of isochronous applications like voice and
   video data streams is that their users may be sensitive to the
   variation in interarrival times between data delivered to the final
   output device.  This interarrival time is called &quot;jitter&quot; for very
   small variances (less than 10 Hz) and &quot;wander&quot; if it is somewhat
   larger (less than one day).  For convenience, this memo will use the
   term jitter for both jitter and wander.

   A couple of examples help illustrate the sensitivity of applications
   to jitter.  Consider a user watching a video at her workstation.  If
   the screen is not updated regularly every 30th of a second or faster,
   the user will notice a flickering in the image.  Similarly, if voice
   samples are not delivered at regular intervals, voice output may
   sound distorted.  Thus the user is sensitive to the interarrival time
   of data at the output device.

   Observe that if two users are conferring with each other from their



<span class="grey">Partridge                                                       [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc1257">RFC 1257</a>                 Isochronous and Jitter           September 1991</span>


   workstations, then beyond sensitivity to interarrival times, the
   users will also be sensitive to end-to-end delay.  Consider the
   difference between conferencing over a satellite link and a
   terrestrial link.  Furthermore, for the data to be able to arrive in
   time, there must be sufficient bandwidth.  Bandwidth requirements are
   particularly important for video: HDTV, even after compression,
   currently requires bandwidth in excess of 100 Mbits/second.

   Because multimedia applications are sensitive to jitter, bandwidth
   and delay, it has been suggested that the networks that carry
   multimedia traffic must be able to allocate and control jitter,
   bandwidth and delay [<a href="#ref-1" title="&quot;Critical Issues in High Bandwidth Networking&quot;">1</a>,<a href="#ref-2" title="&quot;Client Requirements for Real-Time Communication Services&quot;">2</a>].

   This memo argues that a network which simply controls bandwidth and
   delay is sufficient to support networked multimedia applications.
   Jitter control is not required.

Isochrony without Jitter Control

   The key argument of this memo is that an isochronous service can be
   provided by simply bounding the maximum delay through the network.

   To prove this argument, consider the following scenario.

   The network is able to bound the maximum transit delay on a channel
   between sender and receiver and at least the receiver knows what the
   bound is.  (These assumptions come directly from our assertion that
   the network can bound delay).  The term &quot;channel&quot; is used to mean
   some amount of bandwidth delivered over some path between sender and
   receiver.

   Now imagine an operating system in which applications can be
   scheduled to be active at regular intervals. Further assume that the
   receiving application has buffer space equal to the channel bandwidth
   times the maximum interarrival variance.  (Observe that the maximum
   interarrival variance is always known - in the worst case, the
   receiver can assume the maximum variance equals the maximum delay).

   Now consider a situation in which the sender of the isochronous data
   timestamps each piece of data when it is generated, using a universal
   time source, and then sends the data to the receiver.  The receiver
   reads a piece data in as soon as it is received and and places the
   timestamped data into its buffer space.  The receiver processes each
   piece of data only at the time equal to the data&#x27;s timestamp plus the
   maximum transit delay.

   I argue that the receiver is processing data isochronously and thus
   we have shown that a network need not be isochronous to support



<span class="grey">Partridge                                                       [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc1257">RFC 1257</a>                 Isochronous and Jitter           September 1991</span>


   isochronous applications.

   A few issues have to be resolved to really make this proof stick.

   The first issue is whether the operating system can be expected to
   schedule applications to be active at regular intervals.  I will
   argue that whether or not the network is isochronous, the operating
   system must be able to schedule applications at regular intervals

   Consider an isochronous network which delivers data with a tight
   bound on jitter.  If the application on the receiving system does not
   wake up when new data arrives, but waits until its next turn in the
   processor, then the isochrony of the network service would be lost
   due to the vagaries of operating system scheduling.  Thus, we may
   reasonably expect that the operating system provides some mechanism
   for waking up the application in response to a network interrupt for
   a particular packet.  But if the operating system can wake up an
   application in response to an interrupt, it can just as easily wake
   the application in response to a clock interrupt at a particular
   time.  Waking up to a clock interrupt provides the regular scheduling
   service we wanted.

   Observe that the last paragraph suggests an application of the End-
   To-End Principle [<a href="#ref-3" title="&quot;End-To-End Arguments in System Design&quot;">3</a>].  Given that the operating system must provide a
   mechanism sufficient for restoring isochrony, regardless of whether
   the network is isochronous, it seems unreasonable to require the
   network to redundantly provide the same service.

   Another issue is the question of whether all receiving systems will
   have memory for buffering.  For example, the telephone network is
   required to deliver its data isochronously because many telephones do
   not have memory. However, most receiving devices do have memory, and
   those devices, like telephones, that do not currently have memory
   seem likely to have memory in the future.  Many telephones have a
   modest amount of memory now.  Furthermore, even if the end nodes
   require isochronous traffic it is possible that last switch before
   delivery to the end node could provide the necessary buffer space to
   restore isochrony to the data flow.

   Readers may wonder if the assumption of a universal time source is
   reasonable.  The Network Time Protocol (NTP) has been widely tested
   on the Internet and is capable of distributing time accurately to the
   millisecond [<a href="#ref-4" title="&quot;Measured Performance of the Network Time Protocol in the Internet System&quot;">4</a>].  Its designer is currently contemplating the
   possibility of distributing time accurate to the microsecond.

Some Implications

   The most important observation that can be made is that jitter



<span class="grey">Partridge                                                       [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc1257">RFC 1257</a>                 Isochronous and Jitter           September 1991</span>


   control is not required for networks to be able to support
   isochronous applications.  A corollary observation is that if we are
   to design an internetworking protocol for isochronous applications,
   that internetworking protocol should probably only offer control over
   delay and bandwidth.  (There may exist networks that simply manage
   delay and bandwidth. We know that&#x27;s sufficient for multimedia
   networking so our multimedia internetworking protocol should be
   capable of running over those networks.  But if the multimedia
   internetworking protocol requires control over jitter too, then
   jitter control must be implemented on those subnetworks that don&#x27;t
   have it.  Implementing jitter control is clearly feasible - the
   method for restoring jitter in the last section could be used on a
   single network.  But if we know jitter control isn&#x27;t needed, why
   require networks to implement it?)

   Note that the argument simply says that jitter control is not
   required to support isochronous applications.  It may be the case
   that jitter control is useful for other reasons.  For example, work
   at Berkeley suggests that jitter control makes it possible to reduce
   the amount of buffering required in intermediate network nodes [Y].
   Thus, even if applications express their requirements only in terms
   of bandwidth and delay, a network may find it useful to try to limit
   jitter and thereby reduce the amount of memory required in each node.

Acknowledgements

   Thanks to the members of the End-To-End Interest mailing list who
   provided a number of invaluable comments on this memo.

References

   [<a id="ref-1">1</a>] Leiner, B., Editor, &quot;Critical Issues in High Bandwidth
       Networking&quot;, Report to DARPA, August 1988.

   [<a id="ref-2">2</a>] Ferrari, D., &quot;Client Requirements for Real-Time Communication
       Services&quot;, IEEE Communications Magazine, November 1990.  See also
       <a href="/doc/html/rfc1193">RFC 1193</a>, November, 1990.

   [<a id="ref-3">3</a>] Saltzer, J., Reed D., and D. Clark, &quot;End-To-End Arguments in
       System Design&quot;, ACM Transactions on Computer Systems, Vol. 2, No.
       4, November 1984.

   [<a id="ref-4">4</a>] Mills, D., &quot;Measured Performance of the Network Time Protocol in
       the Internet System&quot;, <a href="/doc/html/rfc1128">RFC 1128</a>, UDEL, October 1989.

   [<a id="ref-5">5</a>] Verma, D., Zhang H., and D. Ferrari. &quot;Guaranteeing Delay Jitter
       Bounds in Packet Switching Networks&quot;, Proceedings of TriComm &#x27;91,
       Chapel Hill, North Carolina, April 1991.



<span class="grey">Partridge                                                       [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc1257">RFC 1257</a>                 Isochronous and Jitter           September 1991</span>


Security Considertaions

   Security issues are not discussed in this memo.

Author&#x27;s Address

   Craig Partridge
   Swedish Institute of Computer Science
   Box 1263
   164 28 Kista
   SWEDEN

   Phone: +46 8 752 1524

   EMail: craig@SICS.SE




































Partridge                                                       [Page 5]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

