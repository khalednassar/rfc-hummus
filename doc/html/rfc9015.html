<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc9015
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.34.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.34.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-bess-nsh-bgp-control-plane/">
  <meta name="description" content="BGP Control Plane for the Network Service Header in Service Function Chaining (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.34.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.34.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgblue"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc9015.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc9015.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/rfc9015.xml" title="XML source for this document">xml</a>|<a href="https://www.rfc-editor.org/rfc/rfc9015.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc9015/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc9015/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/bess/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-bess-nsh-bgp-control-plane@ietf.org?subject=draft-ietf-bess-nsh-bgp-control-plane" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-bess-nsh-bgp-control-plane-18.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-bess-nsh-bgp-control-plane-18.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-bess-nsh-bgp-control-plane-18.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-bess-nsh-bgp-control-plane-18">draft-ietf-bess-nsh-bgp-control-plane-18</a>         Proposed Standard
                                                        <a class="text-warning" href="/ipr/search/?submit=draft&amp;id=draft-ietf-bess-nsh-bgp-control-plane">IPR declarations</a></pre>
      </div>
    

    <div class="draftcontent">
    <pre>Internet Engineering Task Force (IETF)                         A. Farrel
Request for Comments: 9015                            Old Dog Consulting
Category: Standards Track                                       J. Drake
ISSN: 2070-1721                                                 E. Rosen
                                                        Juniper Networks
                                                               J. Uttaro
                                                                    AT&amp;T
                                                                L. Jalil
                                                                 Verizon
                                                               June 2021


  <span class="h1">BGP Control Plane for the Network Service Header in Service Function</span>
                                <span class="h1">Chaining</span>

Abstract

   This document describes the use of BGP as a control plane for
   networks that support service function chaining.  The document
   introduces a new BGP address family called the &quot;Service Function
   Chain (SFC) Address Family Identifier / Subsequent Address Family
   Identifier&quot; (SFC AFI/SAFI) with two Route Types.  One Route Type is
   originated by a node to advertise that it hosts a particular instance
   of a specified service function.  This Route Type also provides
   &quot;instructions&quot; on how to send a packet to the hosting node in a way
   that indicates that the service function has to be applied to the
   packet.  The other Route Type is used by a controller to advertise
   the paths of &quot;chains&quot; of service functions and give a unique
   designator to each such path so that they can be used in conjunction
   with the Network Service Header (NSH) defined in <a href="/doc/html/rfc8300">RFC 8300</a>.

   This document adopts the service function chaining architecture
   described in <a href="/doc/html/rfc7665">RFC 7665</a>.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="/doc/html/rfc7841#section-2">Section&nbsp;2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc9015">https://www.rfc-editor.org/info/rfc9015</a>.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements Language
     1.2.  Terminology
   2.  Overview
     2.1.  Overview of Service Function Chaining
     2.2.  Control Plane Overview
   3.  BGP SFC Routes
     3.1.  Service Function Instance Route (SFIR)
       3.1.1.  SFIR Pool Identifier Extended Community
       3.1.2.  MPLS Mixed Swapping/Stacking Extended Community
     3.2.  Service Function Path Route (SFPR)
       3.2.1.  The SFP Attribute
       3.2.2.  General Rules for the SFP Attribute
   4.  Mode of Operation
     4.1.  Route Targets
     4.2.  Service Function Instance Routes
     4.3.  Service Function Path Routes
     4.4.  Classifier Operation
     4.5.  Service Function Forwarder Operation
       4.5.1.  Processing with &quot;Gaps&quot; in the SI Sequence
   5.  Selection within Service Function Paths
   6.  Looping, Jumping, and Branching
     6.1.  Protocol Control of Looping, Jumping, and Branching
     6.2.  Implications for Forwarding State
   7.  Advanced Topics
     7.1.  Correlating Service Function Path Instances
     7.2.  Considerations for Stateful Service Functions
     7.3.  VPN Considerations and Private Service Functions
     7.4.  Flow Specification for SFC Classifiers
     7.5.  Choice of Data Plane SPI/SI Representation
       7.5.1.  MPLS Representation of the SPI/SI
     7.6.  MPLS Label Swapping/Stacking Operation
     7.7.  Support for MPLS-Encapsulated NSH Packets
   8.  Examples
     8.1.  Example Explicit SFP with No Choices
     8.2.  Example SFP with Choice of SFIs
     8.3.  Example SFP with Open Choice of SFIs
     8.4.  Example SFP with Choice of SFTs
     8.5.  Example Correlated Bidirectional SFPs
     8.6.  Example Correlated Asymmetrical Bidirectional SFPs
     8.7.  Example Looping in an SFP
     8.8.  Example Branching in an SFP
     8.9.  Examples of SFPs with Stateful Service Functions
       8.9.1.  Forward and Reverse Choice Made at the SFF
       8.9.2.  Parallel End-to-End SFPs with Shared SFF
       8.9.3.  Parallel End-to-End SFPs with Separate SFFs
       8.9.4.  Parallel SFPs Downstream of the Choice
     8.10. Examples Using IPv6 Addressing
       8.10.1.  Example Explicit SFP with No Choices
       8.10.2.  Example SFP with Choice of SFIs
       8.10.3.  Example SFP with Open Choice of SFIs
       8.10.4.  Example SFP with Choice of SFTs
   9.  Security Considerations
   10. IANA Considerations
     10.1.  New BGP AF/SAFI
     10.2.  &quot;SFP attribute&quot; BGP Path Attribute
     10.3.  &quot;SFP Attribute TLVs&quot; Registry
     10.4.  &quot;SFP Association Type&quot; Registry
     10.5.  &quot;Service Function Chaining Service Function Types&quot;
             Registry
     10.6.  Flow Specification for SFC Classifiers
     10.7.  New BGP Transitive Extended Community Type
     10.8.  &quot;SFC Extended Community Sub-Types&quot; Registry
     10.9.  New SPI/SI Representation Sub-TLV
     10.10. &quot;SFC SPI/SI Representation Flags&quot; Registry
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Acknowledgements
   Contributors
   Authors&#x27; Addresses

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   As described in [<a href="/doc/html/rfc7498" title="&quot;Problem Statement for Service Function Chaining&quot;">RFC7498</a>], the delivery of end-to-end services can
   require a packet to pass through a series of Service Functions (SFs)
   -- e.g., WAN and application accelerators, Deep Packet Inspection
   (DPI) engines, firewalls, TCP optimizers, and server load balancers
   -- in a specified order; this is termed &quot;service function chaining&quot;.
   There are a number of issues associated with deploying and
   maintaining service function chaining in production networks, which
   are described below.

   Historically, if a packet needed to travel through a particular
   service chain, the nodes hosting the service functions of that chain
   were placed in the network topology in such a way that the packet
   could not reach its ultimate destination without first passing
   through all the service functions in the proper order.  This need to
   place the service functions at particular topological locations
   limited the ability to adapt a service function chain to changes in
   network topology (e.g., link or node failures), network utilization,
   or offered service load.  These topological restrictions on where the
   service functions could be placed raised the following issues:

   1.  The process of configuring or modifying a service function chain
       is operationally complex and may require changes to the network
       topology.

   2.  Alternate or redundant service functions may need to be co-
       located with the primary service functions.

   3.  When there is more than one path between source and destination,
       forwarding may be asymmetric, and it may be difficult to support
       bidirectional service function chains using simple routing
       methodologies and protocols without adding mechanisms for traffic
       steering or traffic engineering.

   In order to address these issues, the service function chaining
   architecture describes service function chains that are built in
   their own overlay network (the service function overlay network),
   coexisting with other overlay networks, over a common underlay
   network [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>].  A service function chain is a sequence of service
   functions through which packet flows that satisfy specified criteria
   will pass.

   This document describes the use of BGP as a control plane for
   networks that support service function chaining.  The document
   introduces a new BGP address family called the &quot;Service Function
   Chain (SFC) Address Family Identifier / Subsequent Address Family
   Identifier&quot; (SFC AFI/SAFI) with two Route Types.  One Route Type is
   originated by a node to advertise that it hosts a particular instance
   of a specified service function.  This Route Type also provides
   &quot;instructions&quot; on how to send a packet to the hosting node in a way
   that indicates that the service function has to be applied to the
   packet.  The other Route Type is used by a controller (a centralized
   network component responsible for planning and coordinating service
   function chaining within the network) to advertise the paths of
   &quot;chains&quot; of service functions and give a unique designator to each
   such path so that they can be used in conjunction with the Network
   Service Header (NSH) [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>].

   This document adopts the service function chaining architecture
   described in [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>].

<span class="h3"><a class="selflink" id="section-1.1" href="#section-1.1">1.1</a>.  Requirements Language</span>

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="/doc/html/bcp14">BCP</a>
   <a href="/doc/html/bcp14">14</a> [<a href="/doc/html/rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="/doc/html/rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h3"><a class="selflink" id="section-1.2" href="#section-1.2">1.2</a>.  Terminology</span>

   This document uses the following terms from [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]:

   *  Bidirectional Service Function Chain

   *  Classifier

   *  Service Function (SF)

   *  Service Function Chain (SFC)

   *  Service Function Forwarder (SFF)

   *  Service Function Instance (SFI)

   *  Service Function Path (SFP)

   *  SFC branching

   Additionally, this document uses the following terms from [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>]:

   *  Network Service Header (NSH)

   *  Service Index (SI)

   *  Service Path Identifier (SPI)

   This document introduces the following terms:

   Service Function Instance Route (SFIR):  A new BGP Route Type
      advertised by the node that hosts an SFI to describe the SFI and
      to announce the way to forward a packet to the node through the
      underlay network.

   Service Function Overlay Network:  The logical network comprised of
      classifiers, SFFs, and SFIs that are connected by paths or tunnels
      through underlay transport networks.

   Service Function Path Route (SFPR):  A new BGP Route Type originated
      by controllers to advertise the details of each SFP.

   Service Function Type (SFT):  An indication of the function and
      features of an SFI.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Overview</span>

   This section provides an overview of service function chaining in
   general and the control plane defined in this document.  After
   reading this section, readers may find it helpful to look through
   <a href="#section-8">Section 8</a> for some simple worked examples.

<span class="h3"><a class="selflink" id="section-2.1" href="#section-2.1">2.1</a>.  Overview of Service Function Chaining</span>

   In [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>], a Service Function Chain (SFC) is an ordered list of
   Service Functions (SFs).  A Service Function Path (SFP) is an
   indication of which instances of SFs are acceptable to be traversed
   in an instantiation of an SFC in a service function overlay network.
   The Service Path Identifier (SPI) is a 24-bit number that identifies
   a specific SFP, and a Service Index (SI) is an 8-bit number that
   identifies a specific point in that path.  In the context of a
   particular SFP (identified by an SPI), an SI represents a particular
   service function and indicates the order of that SF in the SFP.

   Within the context of a specific SFP, an SI references a set of one
   or more SFs.  Each of those SFs may be supported by one or more
   Service Function Instances (SFIs).  Thus, an SI may represent a
   choice of SFIs of one or more service function types.  By deploying
   multiple SFIs for a single SF, one can provide load balancing and
   redundancy.

   A special functional element, called a &quot;classifier&quot;, is located at
   each ingress point to a service function overlay network.  It assigns
   the packets of a given packet flow to a specific SFP.  This may be
   done by comparing specific fields in a packet&#x27;s header with local
   policy, which may be customer/network/service specific.  The
   classifier picks an SFP and sets the SPI accordingly; it then sets
   the SI to the value of the SI for the first hop in the SFP, and then
   prepends a Network Service Header (NSH) [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>] containing the
   assigned SPI/SI to that packet.  Note that the classifier and the
   node that hosts the first SF in an SFP need not be located at the
   same point in the service function overlay network.

   Note that the presence of the NSH can make it difficult for nodes in
   the underlay network to locate the fields in the original packet that
   would normally be used to constrain equal-cost multipath (ECMP)
   forwarding.  Therefore, it is recommended that the node prepending
   the NSH also provide some form of entropy indicator that can be used
   in the underlay network.  How this indicator is generated and
   supplied, and how an SFF generates a new entropy indicator when it
   forwards a packet to the next SFF, are out of the scope of this
   document.

   The Service Function Forwarder (SFF) receives a packet from the
   previous node in an SFP, removes the packet&#x27;s link layer or tunnel
   encapsulation, and hands the packet and the NSH to the SFI for
   processing.  The SFI has no knowledge of the SFP.

   When the SFF receives the packet and the NSH back from the SFI, it
   must select the next SFI along the path using the SPI and SI in the
   NSH and potentially choosing between multiple SFIs (possibly of
   different SFTs), as described in <a href="#section-5">Section 5</a>.  In the normal case, the
   SPI remains unchanged, and the SI will have been decremented to
   indicate the next SF along the path.  But other possibilities exist
   if the SF makes other changes to the NSH through a process of
   reclassification:

   *  The SI in the NSH may indicate:

      -  A previous SF in the path; this is known as &quot;looping&quot; (see
         <a href="#section-6">Section 6</a>).

      -  An SF further down the path; this is known as &quot;jumping&quot; (again
         see <a href="#section-6">Section 6</a>).

   *  The SPI and the SI may point to an SF on a different SFP; this is
      known as &quot;branching&quot; (see <a href="#section-6">Section 6</a>).

   Such modifications are limited to within the same service function
   overlay network.  That is, an SPI is known within the scope of
   service function overlay network.  Furthermore, the new SI value is
   interpreted in the context of the SFP identified by the SPI.

   As described in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>], an SPI that is unknown or not valid is
   treated as an error, and the SFF drops the packet; such errors should
   be logged, and such logs are subject to rate limits.

   Also, as described in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>], an SFF receiving an SI that is
   unknown in the context of the SPI can reduce the value to the next
   meaningful SI value in the SFP indicated by the SPI.  If no such
   value exists, or if the SFF does not support reducing the SI, the SFF
   drops the packet and should log the event; such logs are also subject
   to rate limits.

   The SFF then selects an SFI that provides the SF denoted by the SPI/
   SI and forwards the packet to the SFF that supports that SFI.

   [<a id="ref-RFC8300">RFC8300</a>] makes it clear that the intended scope is for use within a
   single provider&#x27;s operational domain.

   This document adopts the service function chaining architecture
   described in [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>] and adds a control plane to support the
   functions, as described in <a href="#section-2.2">Section 2.2</a>.  An essential component of
   this solution is the controller.  This is a network component
   responsible for planning SFPs within the network.  It gathers
   information about the availability of SFIs and SFFs, instructs the
   control plane about the SFPs to be programmed, and instructs the
   classifiers how to assign traffic flows to individual SFPs.

<span class="h3"><a class="selflink" id="section-2.2" href="#section-2.2">2.2</a>.  Control Plane Overview</span>

   To accomplish the function described in <a href="#section-2.1">Section 2.1</a>, this document
   introduces the Service Function Type (SFT), which is the category of
   SF that is supported by an SFF (such as &quot;firewall&quot;).  An IANA
   registry of service function types is introduced in <a href="#section-10.5">Section 10.5</a> and
   is consistent with types used in other work, such as [<a href="#ref-BGP-LS-SR">BGP-LS-SR</a>].  An
   SFF may support SFs of multiple different SFTs, and it may support
   multiple SFIs of each SF.

   The registry of SFT values (see <a href="#section-10.5">Section 10.5</a>) is split into three
   ranges with assignment policies per [<a href="/doc/html/rfc8126" title="">RFC8126</a>]:

   *  The special-purpose SFT values range is assigned through Standards
      Action.  Values in that range are used for special SFC operations
      and do not apply to the types of SF that may form part of the SFP.

   *  The First Come First Served range tracks assignments of SFT values
      made by any party that defines an SF type.  Reference through an
      Internet-Draft is desirable, but not required.

   *  The Private Use range is not tracked by IANA and is primarily
      intended for use in private networks where the meaning of the SFT
      values is locally tracked and under the control of a local
      administrator.

   It is envisaged that the majority of SFT values used will be assigned
   from the First Come First Served space in the registry.  This will
   ensure interoperability, especially in situations where software and
   hardware from different vendors are deployed in the same networks, or
   when networks are merged.  However, operators of private networks may
   choose to develop their own SFs and manage the configuration and
   operation of their network through their own list of SFT values.

   This document also introduces a new BGP AFI/SAFI (values 31 and 9,
   respectively) for &quot;SFC Routes&quot;.  Two SFC Route Types are defined by
   this document: the Service Function Instance Route (SFIR) and the
   Service Function Path Route (SFPR).  As detailed in <a href="#section-3">Section 3</a>, the
   Route Type is indicated by a subfield in the Network Layer
   Reachability Information (NLRI).

   *  The SFIR is advertised by the node that provides access to the
      service function instance (i.e., the SFF).  The SFIR describes a
      particular instance of a particular SF (i.e., an SFI) and the way
      to forward a packet to it through the underlay network, i.e., IP
      address and encapsulation information.

   *  The SFPRs are originated by controllers.  One SFPR is originated
      for each SFP.  The SFPR specifies:

      A.  the SPI of the path,

      B.  the sequence of SFTs and/or SFIs of which the path consists,
          and

      C.  for each such SFT or SFI, the SI that represents it in the
          identified path.

   This approach assumes that there is an underlay network that provides
   connectivity between SFFs and controllers and that the SFFs are
   grouped to form one or more service function overlay networks through
   which SFPs are built.  We assume that the controllers have BGP
   connectivity to all SFFs and all classifiers within each service
   function overlay network.

   When choosing the next SFI in a path, the SFF uses the SPI and SI as
   well as the SFT to choose among the SFIs, applying, for example, a
   load-balancing algorithm or direct knowledge of the underlay network
   topology, as described in <a href="#section-4">Section 4</a>.

   The SFF then encapsulates the packet using the encapsulation
   specified by the SFIR of the selected SFI and forwards the packet.
   See Figure 1.

   Thus, the SFF can be seen as a portal in the underlay network through
   which a particular SFI is reached.

   Figure 1 shows a reference model for the service function chaining
   architecture.  There are four SFFs (SFF-1 through SFF-4) connected by
   tunnels across the underlay network.  Packets arrive at a classifier
   and are channeled along SFPs to destinations reachable through SFF-4.

   SFF-1 and SFF-4 each have one instance of one SF attached (SFa and
   SFe).  SFF-2 has two types of SF attached: one instance of one (SFc)
   and three instances of the other (SFb).  SFF-3 has just one instance
   of an SF (SFd), but in this case, the type of SFd is the same type as
   SFb (SFTx).

   This figure demonstrates how load balancing can be achieved by
   creating several SFPs that satisfy the same SFC.  Suppose an SFC
   needs to include SFa, an SF of type SFTx, and SFc.  A number of SFPs
   can be constructed using any instance of SFb or using SFd.  Load
   balancing may be applied at two places:

   *  The classifier may distribute different flows onto different SFPs
      to share the load in the network and across SFIs.

   *  SFF-2 may distribute different flows (on the same SFP) to
      different instances of SFb to share the processing load.

   Note that, for convenience and clarity, Figure 1 shows only a few
   tunnels between SFFs.  There could be a full mesh of such tunnels, or
   more likely, a selection of tunnels connecting key SFFs to enable the
   construction of SFPs and balance load and traffic in the network.
   Further, the figure does not show any controllers; these would each
   have BGP connectivity to the classifier and all of the SFFs.

       Packets
       | | |
    ------------
   |            |
   | Classifier |
   |            |
    ------+-----
          |
       ---+---                 ---------           -------
      |       |    Tunnel     |         |         |       |
      | SFF-1 |===============|  SFF-2  |=========| SFF-4 |
      |       |               |         |         |       |
      |       |                -+-----+-          |       |
      |       |  ,,,,,,,,,,,,,,/,,     \          |       |
      |       | &#x27;  .........../.  &#x27;   ..\......   |       |
      |       | &#x27; : SFb      /  : &#x27;  :   \ SFc :  |       |
      |       | &#x27; :      ---+-  : &#x27;  :  --+--  :  |       |
      |       | &#x27; :    -| SFI | : &#x27;  : | SFI | :  |       |
      |       | &#x27; :  -|  -----  : &#x27;  :  -----  :  |       |
      |       | &#x27; : |  -----    : &#x27;   .........   |       |
      |       | &#x27; :  -----      : &#x27;               |       |
      |       | &#x27;  .............  &#x27;               |       |--- Dests
      |       | &#x27;                 &#x27;               |       |--- Dests
      |       | &#x27;    .........    &#x27;               |       |
      |       | &#x27;   :  -----  :   &#x27;               |       |
      |       | &#x27;   : | SFI | :   &#x27;               |       |
      |       | &#x27;   :  --+--  :   &#x27;               |       |
      |       | &#x27;   :SFd |    :   &#x27;               |       |
      |       | &#x27;    ....|....    &#x27;               |       |
      |       | &#x27;        |        &#x27;               |       |
      |       | &#x27; SFTx   |        &#x27;               |       |
      |       | &#x27;,,,,,,,,|,,,,,,,,&#x27;               |       |
      |       |          |                        |       |
      |       |       ---+---                     |       |
      |       |      |       |                    |       |
      |       |======| SFF-3 |====================|       |
       ---+---       |       |                     ---+---
          |           -------                         |
      ....|....                                   ....|....
     :    | SFa:                                 :    | SFe:
     :  --+--  :                                 :  --+--  :
     : | SFI | :                                 : | SFI | :
     :  -----  :                                 :  -----  :
      .........                                   .........

    Figure 1: The Service Function Chaining Architecture Reference Model

   As previously noted, [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>] makes it clear that the mechanisms it
   defines are intended for use within a single provider&#x27;s operational
   domain.  This reduces the requirements on the control plane function.

   <a href="/doc/html/rfc7665#section-5.2">Section&nbsp;5.2 of [RFC7665]</a> sets out the functions provided by a control
   plane for a service function chaining network.  The functions are
   broken down into six items, the first four of which are completely
   covered by the mechanisms described in this document:

   1.  Visibility of all SFs and the SFFs through which they are
       reached.

   2.  Computation of SFPs and programming into the network.

   3.  Selection of SFIs explicitly in the SFP or dynamically within the
       network.

   4.  Programming of SFFs with forwarding path information.

   The fifth and sixth items in the list in <a href="/doc/html/rfc7665">RFC 7665</a> concern the use of
   metadata.  These are more peripheral to the control plane mechanisms
   defined in this document but are discussed in <a href="#section-4.4">Section 4.4</a>.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  BGP SFC Routes</span>

   This document defines a new AFI/SAFI for BGP, known as &quot;SFC&quot;, with an
   NLRI that is described in this section.

   The format of the SFC NLRI is shown in Figure 2.

                    +---------------------------------------+
                    |  Route Type (2 octets)                |
                    +---------------------------------------+
                    |  Length (2 octets)                    |
                    +---------------------------------------+
                    |  Route Type specific (variable)       |
                    +---------------------------------------+

                    Figure 2: The Format of the SFC NLRI

   The &quot;Route Type&quot; field determines the encoding of the rest of the
   Route Type specific SFC NLRI.

   The &quot;Length&quot; field indicates the length, in octets, of the &quot;Route
   Type specific&quot; field of the SFC NLRI.

   This document defines the following Route Types:

   1.  Service Function Instance Route (SFIR)

   2.  Service Function Path Route (SFPR)

   An SFIR is used to identify an SFI.  An SFPR defines a sequence of
   SFs (each of which has at least one instance advertised in an SFIR)
   that form an SFP.

   The detailed encoding and procedures for these Route Types are
   described in subsequent sections.

   The SFC NLRI is carried in BGP [<a href="/doc/html/rfc4271" title="&quot;A Border Gateway Protocol 4 (BGP-4)&quot;">RFC4271</a>] using BGP Multiprotocol
   Extensions [<a href="/doc/html/rfc4760" title="&quot;Multiprotocol Extensions for BGP-4&quot;">RFC4760</a>] with an Address Family Identifier (AFI) of 31
   and a Subsequent Address Family Identifier (SAFI) of 9.  The &quot;NLRI&quot;
   field in the MP_REACH_NLRI/MP_UNREACH_NLRI attribute contains the SFC
   NLRI, encoded as specified above.

   In order for two BGP speakers to exchange SFC NLRIs, they MUST use
   BGP capabilities advertisements to ensure that they both are capable
   of properly processing such NLRIs.  This is done as specified in
   [<a href="/doc/html/rfc4760" title="&quot;Multiprotocol Extensions for BGP-4&quot;">RFC4760</a>], by using capability code 1 (Multiprotocol BGP) with an AFI
   of 31 and a SAFI of 9.

   The &quot;nexthop&quot; field of the MP_REACH_NLRI attribute of the SFC NLRI
   MUST be set to a loopback address of the advertising SFF.

<span class="h3"><a class="selflink" id="section-3.1" href="#section-3.1">3.1</a>.  Service Function Instance Route (SFIR)</span>

   Figure 3 shows the Route Type specific NLRI of the SFIR.

                    +--------------------------------------------+
                    |  Route Distinguisher (RD) (8 octets)       |
                    +--------------------------------------------+
                    |  Service Function Type (2 octets)          |
                    +--------------------------------------------+

                  Figure 3: SFIR Route Type Specific NLRI

   [<a id="ref-RFC4364">RFC4364</a>] defines a Route Distinguisher (RD) as consisting of a two-
   byte &quot;Type&quot; field and a six-byte &quot;Value&quot; field, and it defines RD
   types 0, 1, and 2.  In this specification, the RD (used for the SFIR)
   MUST be of type 0, 1, or 2.

   If two SFIRs are originated from different administrative domains
   (within the same provider&#x27;s operational domain), they MUST have
   different RDs.  In particular, SFIRs from different VPNs (for
   different service function overlay networks) MUST have different RDs,
   and those RDs MUST be different from any non-VPN SFIRs.

   The SFT identifies the functions/features an SF can offer, e.g.,
   classifier, firewall, load balancer.  There may be several SFIs that
   can perform a given service function.  Each node hosting an SFI MUST
   originate an SFIR for each type of SF that it hosts (as indicated by
   the SFT value), and it MAY advertise an SFIR for each instance of
   each type of SF.  A minimal advertisement allows construction of
   valid SFPs and leaves the selection of SFIs to the local SFF; a
   detailed advertisement may have scaling concerns but allows a
   controller that constructs an SFP to make an explicit choice of SFI.

   Note that a node may advertise all its SFIs of one SFT in one shot
   using normal BGP UPDATE packing.  That is, all of the SFIRs in an
   Update share a common Tunnel Encapsulation and Route Target (RT)
   attribute.  See also <a href="#section-3.2.1">Section 3.2.1</a>.

   The SFIR representing a given SFI will contain an NLRI with &quot;RD&quot;
   field set to an RD as specified above, and with the &quot;SFT&quot; field set
   to identify that SFI&#x27;s SFT.  The values for the &quot;SFT&quot; field are taken
   from a registry administered by IANA (see <a href="#section-10">Section 10</a>).  A BGP UPDATE
   containing one or more SFIRs MUST also include a tunnel encapsulation
   attribute [<a href="/doc/html/rfc9012" title="&quot;The BGP Tunnel Encapsulation Attribute&quot;">RFC9012</a>].  If a data packet needs to be sent to an SFI
   identified in one of the SFIRs, it will be encapsulated as specified
   by the tunnel encapsulation attribute and then transmitted through
   the underlay network.

   Note that the tunnel encapsulation attribute MUST contain sufficient
   information to allow the advertising SFF to identify the overlay or
   VPN network that a received packet is transiting.  This is because
   the [SPI, SI] in a received packet is specific to a particular
   overlay or VPN network.

<span class="h4"><a class="selflink" id="section-3.1.1" href="#section-3.1.1">3.1.1</a>.  SFIR Pool Identifier Extended Community</span>

   This document defines a new transitive Extended Community [<a href="/doc/html/rfc4360" title="&quot;BGP Extended Communities Attribute&quot;">RFC4360</a>]
   of type 0x0b called the &quot;SFC Extended Community&quot;.  When used with
   Sub-Type 1, this is called the &quot;SFIR Pool Identifier extended
   community&quot;.  It MAY be included in SFIR advertisements, and it is
   used to indicate the identity of a pool of SFIRs to which an SFIR
   belongs.  Since an SFIR may be a member of more than one pool,
   multiple of these extended communities may be present on a single
   SFIR advertisement.

   SFIR pools allow SFIRs to be grouped for any purpose.  Possible uses
   include control plane scalability and stability.  A pool identifier
   may be included in an SFPR to indicate a set of SFIs that are
   acceptable at a specific point on an SFP (see Sections <a href="#section-3.2.1.3">3.2.1.3</a> and
   4.3).

   The SFIR Pool Identifier Extended Community is encoded in 8 octets as
   shown in Figure 4.

                +--------------------------------------------+
                |  Type = 0x0b (1 octet)                     |
                +--------------------------------------------+
                |  Sub-Type = 1 (1 octet)                    |
                +--------------------------------------------+
                |  SFIR Pool Identifier value (6 octets)     |
                +--------------------------------------------+

           Figure 4: The SFIR Pool Identifier Extended Community

   The SFIR Pool Identifier value is encoded in a 6-octet field in
   network byte order, and the value is unique within the scope of an
   overlay network.  This means that pool identifiers need to be
   centrally managed, which is consistent with the assignment of SFIs to
   pools.

<span class="h4"><a class="selflink" id="section-3.1.2" href="#section-3.1.2">3.1.2</a>.  MPLS Mixed Swapping/Stacking Extended Community</span>

   As noted in <a href="#section-3.1.1">Section 3.1.1</a>, this document defines a new transitive
   Extended Community of type 0x0b called the &quot;SFC Extended Community&quot;.
   When used with Sub-Type 2, this is called the &quot;MPLS Mixed Swapping/
   Stacking Labels Extended Community&quot;.  The community is encoded as
   shown in Figure 5.  It contains a pair of MPLS labels: an SFC Context
   Label and an SF Label, as described in [<a href="/doc/html/rfc8595" title="&quot;An MPLS-Based Forwarding Plane for Service Function Chaining&quot;">RFC8595</a>].  Each label is 20
   bits encoded in a 3-octet (24-bit) field with 4 trailing bits that
   MUST be set to zero.

                +--------------------------------------------+
                |  Type = 0x0b (1 octet)                     |
                +--------------------------------------------|
                |  Sub-Type = 2 (1 octet)                    |
                +--------------------------------------------|
                |  SFC Context Label (3 octets)              |
                +--------------------------------------------|
                |  SF Label (3 octets)                       |
                +--------------------------------------------+

    Figure 5: The MPLS Mixed Swapping/Stacking Labels Extended Community

   Note that it is assumed that each SFF has one or more globally unique
   SFC Context Labels and that the context-label space and the SPI-
   address space are disjoint.  In other words, a label value cannot be
   used to indicate both an SFC context and an SPI, and it can be
   determined from knowledge of the label spaces whether a label
   indicates an SFC context or an SPI.

   If an SFF supports SFP Traversal with an MPLS Label Stack, it MUST
   include this Extended Community with the SFIRs that it advertises.

   See <a href="#section-7.6">Section 7.6</a> for a description of how this Extended Community is
   used.

<span class="h3"><a class="selflink" id="section-3.2" href="#section-3.2">3.2</a>.  Service Function Path Route (SFPR)</span>

   Figure 6 shows the Route Type specific NLRI of the SFPR.


                +-----------------------------------------------+
                |  Route Distinguisher (RD) (8 octets)          |
                +-----------------------------------------------+
                |  Service Path Identifier (SPI) (3 octets)     |
                +-----------------------------------------------+

                  Figure 6: SFPR Route Type Specific NLRI

   [<a id="ref-RFC4364">RFC4364</a>] defines a Route Distinguisher (RD) as consisting of a two-
   byte &quot;Type&quot; field and a six-byte &quot;Value&quot; field, and it defines RD
   types 0, 1, and 2.  In this specification, the RD (used for the SFPR)
   MUST be of type 0, 1, or 2.

   All SFPs MUST be associated with an RD.  The association of an SFP
   with an RD is determined by provisioning.  If two SFPRs are
   originated from different controllers, they MUST have different RDs.
   Additionally, SFPRs from different VPNs (i.e., in different service
   function overlay networks) MUST have different RDs, and those RDs
   MUST be different from any non-VPN SFPRs.

   The Service path identifier is defined in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>] and is the value
   to be placed in the &quot;Service Path Identifier&quot; field of the NSH of any
   packet sent on this SFP.  It is expected that one or more controllers
   will originate these routes in order to configure a service function
   overlay network.

   The SFP is described in a new BGP Path attribute, the SFP attribute.
   <a href="#section-3.2.1">Section 3.2.1</a> shows the format of that attribute.

<span class="h4"><a class="selflink" id="section-3.2.1" href="#section-3.2.1">3.2.1</a>.  The SFP Attribute</span>

   [<a id="ref-RFC4271">RFC4271</a>] defines BGP Path attributes.  This document introduces a
   new Optional Transitive Path attribute called the &quot;SFP attribute&quot;,
   with value 37.  The first SFP attribute MUST be processed, and
   subsequent instances MUST be ignored.

   The common fields of the SFP attribute are set as follows:

   *  The Optional bit is set to 1 to indicate that this is an optional
      attribute.

   *  The Transitive bit is set to 1 to indicate that this is a
      transitive attribute.

   *  The Extended Length bit is set if the length of the SFP attribute
      is encoded in one octet (set to 0) or two octets (set to 1), as
      described in [<a href="/doc/html/rfc4271" title="&quot;A Border Gateway Protocol 4 (BGP-4)&quot;">RFC4271</a>].

   *  The Attribute Type Code is set to 37.

   The content of the SFP attribute is a series of Type-Length-Value
   (TLV) constructs.  Some TLVs may include Sub-TLVs.  All TLVs and Sub-
   TLVs have a common format:

   Type:  A single octet indicating the type of the SFP attribute TLV.
      Values are taken from the registry described in <a href="#section-10.3">Section 10.3</a>.

   Length:  A two-octet field indicating the length of the data
      following the &quot;Length&quot; field, counted in octets.

   Value:  The contents of the TLV.

   The formats of the TLVs defined in this document are shown in the
   following sections.  The presence rules and meanings are as follows.

   *  The SFP attribute contains a sequence of zero or more Association
      TLVs.  That is, the Association TLV is OPTIONAL.  Each Association
      TLV provides an association between this SFPR and another SFPR.
      Each associated SFPR is indicated using the RD with which it is
      advertised (we say the SFPR-RD to avoid ambiguity).

   *  The SFP attribute contains a sequence of one or more Hop TLVs.
      Each Hop TLV contains all of the information about a single hop in
      the SFP.

   *  Each Hop TLV contains an SI value and a sequence of one or more
      SFT TLVs.  Each SFT TLV contains an SFI reference for each
      instance of an SF that is allowed at this hop of the SFP for the
      specific SFT.  Each SFI is indicated using the RD with which it is
      advertised (we say the SFIR-RD to avoid ambiguity).

   <a href="/doc/html/rfc4271#section-6">Section&nbsp;6 of [RFC4271]</a> describes the handling of malformed BGP
   attributes, or those that are in error in some way.  [<a href="/doc/html/rfc7606" title="&quot;Revised Error Handling for BGP UPDATE Messages&quot;">RFC7606</a>]
   revises BGP error handling specifically for the UPDATE message,
   provides guidelines for the authors of documents defining new
   attributes, and revises the error-handling procedures for a number of
   existing attributes.  This document introduces the SFP attribute and
   so defines error handling as follows:

   *  When parsing a message, an unknown Attribute Type Code or a length
      that suggests that the attribute is longer than the remaining
      message is treated as a malformed message, and the &quot;treat-as-
      withdraw&quot; approach is used as per [<a href="/doc/html/rfc7606" title="&quot;Revised Error Handling for BGP UPDATE Messages&quot;">RFC7606</a>].

   *  When parsing a message that contains an SFP attribute, the
      following cases constitute errors:

      1.  Optional bit is set to 0 in the SFP attribute.

      2.  Transitive bit is set to 0 in the SFP attribute.

      3.  Unknown &quot;TLV Type&quot; field found in the SFP attribute.

      4.  TLV length that suggests the TLV extends beyond the end of the
          SFP attribute.

      5.  Association TLV contains an unknown SFPR-RD.

      6.  No Hop TLV found in the SFP attribute.

      7.  No Sub-TLV found in a Hop TLV.

      8.  Unknown SFIR-RD found in an SFT TLV.

   *  The errors listed above are treated as follows:

      1, 2, 4, 6, 7:  The attribute MUST be treated as malformed and the
         &quot;treat-as-withdraw&quot; approach used as per [<a href="/doc/html/rfc7606" title="&quot;Revised Error Handling for BGP UPDATE Messages&quot;">RFC7606</a>].

      3:  Unknown TLVs MUST be ignored, and message processing MUST
         continue.

      5, 8:  The absence of an RD with which to correlate is nothing
         more than a soft error.  The receiver SHOULD store the
         information from the SFP attribute until a corresponding
         advertisement is received.

<span class="h5"><a class="selflink" id="section-3.2.1.1" href="#section-3.2.1.1">3.2.1.1</a>.  The Association TLV</span>

   The Association TLV is an optional TLV in the SFP attribute.  It MAY
   be present multiple times.  Each occurrence provides an association
   with another SFP as advertised in another SFPR.  The format of the
   Association TLV is shown in Figure 7.


                +--------------------------------------------+
                |  Type = 1 (1 octet)                        |
                +--------------------------------------------|
                |  Length (2 octets)                         |
                +--------------------------------------------|
                |  Association Type (1 octet)                |
                +--------------------------------------------|
                |  Associated SFPR-RD (8 octets)             |
                +--------------------------------------------|
                |  Associated SPI (3 octets)                 |
                +--------------------------------------------+

                Figure 7: The Format of the Association TLV

   The fields are as follows:

   *  &quot;Type&quot; is set to 1 to indicate an Association TLV.

   *  &quot;Length&quot; indicates the length in octets of the &quot;Association Type&quot;
      and &quot;Associated SFPR-RD&quot; fields.  The value of the &quot;Length&quot; field
      is 12.

   *  The &quot;Association Type&quot; field indicates the type of association.
      The values are tracked in an IANA registry (see <a href="#section-10.4">Section 10.4</a>).
      Only one value is defined in this document: Type 1 indicates
      association of two unidirectional SFPs to form a bidirectional
      SFP.  An SFP attribute SHOULD NOT contain more than one
      Association TLV with Association Type 1; if more than one is
      present, the first one MUST be processed, and subsequent instances
      MUST be ignored.  Note that documents that define new association
      types must also define the presence rules for Association TLVs of
      the new type.

   *  The Associated SFPR-RD contains the RD of the associated SFP as
      advertised in an SFPR.

   *  The Associated SPI contains the SPI of the associated SFP as
      advertised in an SFPR.

   Association TLVs with unknown Association Type values SHOULD be
   ignored.  Association TLVs that contain an Associated SFPR-RD value
   equal to the RD of the SFPR in which they are contained SHOULD be
   ignored.  If the Associated SPI is not equal to the SPI advertised in
   the SFPR indicated by the Associated SFPR-RD, then the Association
   TLV SHOULD be ignored.  In all three of these cases, an
   implementation MAY reject the SFP attribute as malformed and use the
   &quot;treat-as-withdraw&quot; approach per [<a href="/doc/html/rfc7606" title="&quot;Revised Error Handling for BGP UPDATE Messages&quot;">RFC7606</a>]; however, implementors are
   cautioned that such an approach may make an implementation less
   flexible in the event of future extensions to this protocol.

   Note that when two SFPRs reference each other using the Association
   TLV, one SFPR advertisement will be received before the other.
   Therefore, processing of an association MUST NOT be rejected simply
   because the Associated SFPR-RD is unknown.

   Further discussion of correlation of SFPRs is provided in
   <a href="#section-7.1">Section 7.1</a>.

<span class="h5"><a class="selflink" id="section-3.2.1.2" href="#section-3.2.1.2">3.2.1.2</a>.  The Hop TLV</span>

   There is one Hop TLV in the SFP attribute for each hop in the SFP.
   The format of the Hop TLV is shown in Figure 8.  At least one Hop TLV
   MUST be present in an SFP attribute.


                +--------------------------------------------+
                |  Type = 2 (1 octet)                        |
                +--------------------------------------------|
                |  Length (2 octets)                         |
                +--------------------------------------------|
                |  Service Index (1 octet)                   |
                +--------------------------------------------|
                |  Hop Details (variable)                    |
                +--------------------------------------------+

                    Figure 8: The Format of the Hop TLV

   The fields are as follows:

   *  &quot;Type&quot; is set to 2 to indicate a Hop TLV.

   *  &quot;Length&quot; indicates the length, in octets, of the &quot;Service Index&quot;
      and &quot;Hop Details&quot; fields.

   *  The Service Index is defined in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>] and is the value found
      in the &quot;Service Index&quot; field of the NSH that an SFF will use to
      look up to which next SFI a packet is to be sent.

   *  The &quot;Hop Details&quot; field consists of a sequence of one or more Sub-
      TLVs.

   Each hop of the SFP may demand that a specific type of SF is
   executed, and that type is indicated in Sub-TLVs of the Hop TLV.  At
   least one Sub-TLV MUST be present.  This document defines the SFT
   Sub-TLV (see <a href="#section-3.2.1.3">Section 3.2.1.3</a>) and the MPLS Swapping/Stacking Sub-TLV
   (see <a href="#section-3.2.1.4">Section 3.2.1.4</a>); other Sub-TLVs may be defined in future.  The
   SFT Sub-TLV provides a list of which types of SF are acceptable at a
   specific hop, and for each type it allows a degree of control to be
   imposed on the choice of SFIs of that particular type.  The MPLS
   Swapping/Stacking Sub-TLV indicates the type of SFC encoding to use
   in an MPLS label stack.

   If no Hop TLV is present in an SFP attribute, it is a malformed
   attribute.

<span class="h5"><a class="selflink" id="section-3.2.1.3" href="#section-3.2.1.3">3.2.1.3</a>.  The SFT Sub-TLV</span>

   The SFT Sub-TLV MAY be included in the list of Sub-TLVs of the Hop
   TLV.  The format of the SFT Sub-TLV is shown in Figure 9.  The Hop
   Sub-TLV contains a list of SFIR-RD values each taken from the
   advertisement of an SFI.  Together they form a list of acceptable
   SFIs of the indicated type.

                +--------------------------------------------+
                |  Type = 3 (1 octet)                        |
                +--------------------------------------------|
                |  Length (2 octets)                         |
                +--------------------------------------------|
                |  Service Function Type (2 octets)          |
                +--------------------------------------------|
                |  SFIR-RD List (variable)                   |
                +--------------------------------------------+

                  Figure 9: The Format of the SFT Sub-TLV

   The fields are as follows:

   *  &quot;Type&quot; is set to 3 to indicate an SFT Sub-TLV.

   *  &quot;Length&quot; indicates the length, in octets, of the &quot;Service Function
      Type&quot; and &quot;SFIR-RD List&quot; fields.

   *  The SFT value indicates the category (type) of SF that is to be
      executed at this hop.  The types are as advertised for the SFs
      supported by the SFFs.  SFT values in the range 1-31 are special-
      purpose SFT values and have meanings defined by the documents that
      describe them -- the value &quot;Change Sequence&quot; is defined in
      <a href="#section-6.1">Section 6.1</a> of this document.

   *  The hop description is further qualified beyond the specification
      of the SFTs by listing, for each SFT in each hop, the SFIs that
      may be used at the hop.  The SFIs are identified using the SFIR-
      RDs from the advertisements of the SFIs in the SFIRs.  Note that
      if the list contains one or more SFIR Pool Identifiers, then for
      each, the SFIR-RD list is effectively expanded to include the
      SFIR-RD of each SFIR advertised with that SFIR Pool Identifier.
      An SFIR-RD of value zero has special meaning, as described in
      <a href="#section-5">Section 5</a>.  Each entry in the list is eight octets long, and the
      number of entries in the list can be deduced from the value of the
      &quot;Length&quot; field.

   *  Note that an SFIR-RD is of type 0, 1, or 2 (as described in
      <a href="#section-3.1">Section 3.1</a>).  Thus, the high-order octet of an RD found in an
      SFIR-RD List always has a value of 0x00.  However, the high-order
      octet of an SFIR Pool Identifier (an Extended Community with
      &quot;Type&quot; field 0x0b) will always have a nonzero value.  This allows
      the node processing the SFIR-RD list to distinguish between the
      two types of list entry.

<span class="h5"><a class="selflink" id="section-3.2.1.4" href="#section-3.2.1.4">3.2.1.4</a>.  MPLS Swapping/Stacking Sub-TLV</span>

   The MPLS Swapping/Stacking Sub-TLV (Type value 4) is a zero-length
   Sub-TLV that is OPTIONAL in the Hop TLV and is used when the data
   representation is MPLS (see <a href="#section-7.5">Section 7.5</a>).  When present, it indicates
   to the classifier imposing an MPLS label stack that the current hop
   is to use an {SFC Context Label, SF label} rather than an {SPI, SF}
   label pair.  See <a href="#section-7.6">Section 7.6</a> for more details.

<span class="h5"><a class="selflink" id="section-3.2.1.5" href="#section-3.2.1.5">3.2.1.5</a>.  SFP Traversal With MPLS Label Stack TLV</span>

   The SFP Traversal With MPLS Label Stack TLV (Type value 5) is a zero-
   length TLV that can be carried in the SFP attribute and indicates to
   the classifier and the SFFs on the SFP that an MPLS label stack with
   label swapping/stacking is to be used for packets traversing the SFP.
   All of the SFFs specified at each of the SFP&#x27;s hops MUST have
   advertised an MPLS Mixed Swapping/Stacking Extended Community (see
   <a href="#section-3.1.2">Section 3.1.2</a>) for the SFP to be considered usable.

<span class="h4"><a class="selflink" id="section-3.2.2" href="#section-3.2.2">3.2.2</a>.  General Rules for the SFP Attribute</span>

   It is possible for the same SFI, as described by an SFIR, to be used
   in multiple SFPRs.

   When two SFPRs have the same SPI but different SFPR-RDs, there can be
   three cases:

   1.  Two or more controllers are originating SFPRs for the same SFP.
       In this case, the content of the SFPRs is identical, and the
       duplication is to ensure receipt and provide controller
       redundancy.

   2.  There is a transition in content of the advertised SFP, and the
       advertisements may originate from one or more controllers.  In
       this case, the content of the SFPRs will be different.

   3.  The reuse of an SPI may result from a configuration error.

   There is no way in any of these cases for the receiving SFF to know
   which SFPR to process, and the SFPRs could be received in any order.
   At any point in time, when multiple SFPRs have the same SPI but
   different SFPR-RDs, the SFF MUST use the SFPR with the numerically
   lowest SFPR-RD when interpreting the RDs as 8-octet integers in
   network byte order.  The SFF SHOULD log this occurrence to assist
   with debugging.

   Furthermore, a controller that wants to change the content of an SFP
   is RECOMMENDED to use a new SPI and so create a new SFP onto which
   the classifiers can transition packet flows before the SFPR for the
   old SFP is withdrawn.  This avoids any race conditions with SFPR
   advertisements.

   Additionally, a controller SHOULD NOT reuse an SPI after it has
   withdrawn the SFPR that used it until at least a configurable amount
   of time has passed.  This timer SHOULD have a default of one hour.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Mode of Operation</span>

   This document describes the use of BGP as a control plane to create
   and manage a service function overlay network.

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>.  Route Targets</span>

   The main feature introduced by this document is the ability to create
   multiple service function overlay networks through the use of Route
   Targets (RTs) [<a href="/doc/html/rfc4364" title="&quot;BGP/MPLS IP Virtual Private Networks (VPNs)&quot;">RFC4364</a>].

   Every BGP UPDATE containing an SFIR or SFPR carries one or more RTs.
   The RT carried by a particular SFIR or SFPR is determined by the
   provisioning of the route&#x27;s originator.

   Every node in a service function overlay network is configured with
   one or more import RTs.  Thus, each SFF will import only the SFPRs
   with matching RTs, allowing the construction of multiple service
   function overlay networks or the instantiation of SFCs within a Layer
   3 Virtual Private Network (L3VPN) or Ethernet VPN (EVPN) instance
   (see <a href="#section-7.3">Section 7.3</a>).  An SFF that has a presence in multiple service
   function overlay networks (i.e., one that imports more than one RT)
   will usually maintain separate forwarding state for each overlay
   network.

<span class="h3"><a class="selflink" id="section-4.2" href="#section-4.2">4.2</a>.  Service Function Instance Routes</span>

   The SFIR (see <a href="#section-3.1">Section 3.1</a>) is used to advertise the existence and
   location of a specific SFI; it consists of:

   *  The RT as just described.

   *  A Service Function Type (SFT) that is the type of service function
      that is provided (such as &quot;firewall&quot;).

   *  A Route Distinguisher (RD) that is unique to a specific overlay.

<span class="h3"><a class="selflink" id="section-4.3" href="#section-4.3">4.3</a>.  Service Function Path Routes</span>

   The SFPR (see <a href="#section-3.2">Section 3.2</a>) describes a specific path of an SFC.  The
   SFPR contains the Service Path Identifier (SPI) used to identify the
   SFP in the NSH in the data plane.  It also contains a sequence of
   Service Indexes (SIs).  Each SI identifies a hop in the SFP, and each
   hop is a choice between one or more SFIs.

   As described in this document, each SFP route is identified in the
   service function overlay network by an RD and an SPI.  The SPI is
   unique within a single VPN instance supported by the underlay
   network.

   The SFPR advertisement comprises:

   *  An RT as described in <a href="#section-4.1">Section 4.1</a>.

   *  A tuple that identifies the SFPR.

      -  An RD that identifies an advertisement of an SFPR.

      -  The SPI that uniquely identifies this path within the VPN
         instance distinguished by the RD.  This SPI also appears in the
         NSH.

   *  A series of SIs.  Each SI is used in the context of a particular
      SPI and identifies one or more SFs (distinguished by their SFTs).
      For each SF, it identifies a set of SFIs that instantiate the SF.
      The values of the SI indicate the order in which the SFs are to be
      executed in the SFP that is represented by the SPI.

   *  The SI is used in the NSH to identify the entries in the SFP.
      Note that the SI values have meaning only relative to a specific
      path.  They have no semantic other than to indicate the order of
      SFs within the path and are assumed to be monotonically decreasing
      from the start to the end of the path [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>].

   *  Each SI is associated with a set of one or more SFIs that can be
      used to provide the indexed SF within the path.  Each member of
      the set comprises:

      -  The RD used in an SFIR advertisement of the SFI.

      -  The SFT that indicates the type of function as used in the same
         SFIR advertisement of the SFI.

   This may be summarized as follows, where the notations &quot;SFPR-RD&quot; and
   &quot;SFIR-RD&quot; are used to distinguish the two different RDs, and where
   &quot;*&quot; indicates a multiplier:

      RT, {SFPR-RD, SPI}, m * {SI, {n * {SFT, p * SFIR-RD} } }

   Where:

   RT:  Route Target

   SFPR-RD:  The Route Descriptor of the SFPR advertisement

   SPI:  Service Path Identifier used in the NSH

   m:  The number of hops in the SFP

   n:  The number of choices of SFT for a specific hop

   p:  The number of choices of SFI for a given SFT in a specific hop

   SI:  Service Index used in the NSH to indicate a specific hop

   SFT:  The Service Function Type used in the same advertisement of the
      SFIR

   SFIR-RD:  The Route Descriptor used in an advertisement of the SFIR

   That is, there can be multiple SFTs at a given hop, as described in
   <a href="#section-5">Section 5</a>.

   Note that the values of SI are from the set {255, ..., 1} and are
   monotonically decreasing within the SFP.  SIs MUST appear in order
   within the SFPR (i.e., monotonically decreasing) and MUST NOT appear
   more than once.  Gaps MAY appear in the sequence, as described in
   <a href="#section-4.5.1">Section 4.5.1</a>.  Malformed SFPRs MUST be discarded and MUST cause any
   previous instance of the SFPR (same SFPR-RD and SPI) to be discarded.

   Note that if the SFIR-RD list in an SFT TLV contains one or more SFIR
   Pool Identifiers, then in the above expression, &quot;p&quot; is the sum of the
   number of individual SFIR-RD values and the sum for each SFIR Pool
   Identifier of the number of SFIRs advertised with that SFIR Pool
   Identifier.  In other words, the list of SFIR-RD values is
   effectively expanded to include the SFIR-RD of each SFIR advertised
   with each SFIR Pool Identifier in the SFIR-RD list.

   The choice of SFI is explained further in <a href="#section-5">Section 5</a>.  Note that an
   SFIR-RD value of zero has special meaning, as described in that
   section.

<span class="h3"><a class="selflink" id="section-4.4" href="#section-4.4">4.4</a>.  Classifier Operation</span>

   As shown in Figure 1, the classifier is a component that is used to
   assign packets to an SFP.

   The classifier is responsible for determining to which packet flow a
   packet belongs.  The mechanism it uses to achieve that classification
   is out of the scope of this document but might include inspection of
   the packet header.  The classifier has been instructed (by the
   controller or through some other configuration mechanism -- see
   <a href="#section-7.4">Section 7.4</a>) which flows are to be assigned to which SFPs, and so it
   can impose an NSH on each packet and initialize the NSH with the SPI
   of the selected SFP and the SI of its first hop.

   Note that instructions delivered to the classifier may include
   information about the metadata to encode (and the format for that
   encoding) on packets that are classified by the classifier to a
   particular SFP.  As mentioned in <a href="#section-2.2">Section 2.2</a>, this corresponds to the
   fifth element of control plane functionality described in [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>].
   Such instructions fall outside the scope of this specification (but
   see <a href="#section-7.4">Section 7.4</a>), as do instructions to other service function
   chaining elements on how to interpret metadata (as described in the
   sixth element of control plane functionality described in [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]).

<span class="h3"><a class="selflink" id="section-4.5" href="#section-4.5">4.5</a>.  Service Function Forwarder Operation</span>

   Each packet sent to an SFF is transmitted encapsulated in an NSH.
   The NSH includes an SPI and SI: the SPI indicates the SFPR
   advertisement that announced the SFP; the tuple SPI/SI indicates a
   specific hop in a specific path and maps to the RD/SFT of a
   particular SFIR advertisement.

   When an SFF gets an SFPR advertisement, it will first determine
   whether to import the route by examining the RT.  If the SFPR is
   imported, the SFF then determines whether it is on the SFP by looking
   for its own SFIR-RDs or any SFIR-RD with value zero in the SFPR.  For
   each occurrence in the SFP, the SFF creates forwarding state for
   incoming packets and forwarding state for outgoing packets that have
   been processed by the specified SFI.

   The SFF creates local forwarding state for packets that it receives
   from other SFFs.  This state makes the association between the SPI/SI
   in the NSH of the received packet and one or more specific local
   SFIs, as identified by the SFIR-RD/SFT.  If there are multiple local
   SFIs that match, this is because a single advertisement was made for
   a set of equivalent SFIs, and the SFF may use local policy (such as
   load balancing) to determine to which SFI to forward a received
   packet.

   The SFF also creates next-hop forwarding state for packets received
   back from the local SFI that need to be forwarded to the next hop in
   the SFP.  There may be a choice of next hops, as described in
   <a href="#section-4.3">Section 4.3</a>.  The SFF could install forwarding state for all
   potential next hops or it could choose to only install forwarding
   state for a subset of the potential next hops.  If a choice is made,
   then it will be as described in <a href="#section-5">Section 5</a>.

   The installed forwarding state may change over time, reacting to
   changes in the underlay network and the availability of particular
   SFIs.  Note that the forwarding state describes how one SFF sends
   packets to another SFF, but not how those packets are routed through
   the underlay network.  SFFs may be connected by tunnels across the
   underlay, or packets may be sent addressed to the next SFF and routed
   through the underlay.  In any case, transmission across the underlay
   requires encapsulation of packets with a header for transport in the
   underlay network.

   Note that SFFs only create and store forwarding state for the SFPs on
   which they are included.  They do not retain state for all SFPs
   advertised.

   An SFF may also install forwarding state to support looping, jumping,
   and branching.  The protocol mechanism for explicit control of
   looping, jumping, and branching uses a specific reserved SFT value at
   a given hop of an SFPR and is described in <a href="#section-6.1">Section 6.1</a>.

<span class="h4"><a class="selflink" id="section-4.5.1" href="#section-4.5.1">4.5.1</a>.  Processing with &quot;Gaps&quot; in the SI Sequence</span>

   The behavior of an SF, as described in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>], is to decrement the
   value of the &quot;SI&quot; field in the NSH by one before returning a packet
   to the local SFF for further processing.  This means that there is a
   good reason to assume that the SFP is composed of a series of SFs,
   each indicated by an SI value one less than the previous.

   However, there is an advantage to having nonsuccessive SIs in an SPI.
   Consider the case where an SPI needs to be modified by the insertion
   or removal of an SF.  In the latter case, this would lead to a &quot;gap&quot;
   in the sequence of SIs, and in the former case, this could only be
   achieved if a gap already existed into which the new SF with its new
   SI value could be inserted.  Otherwise, all &quot;downstream&quot; SFs would
   need to be renumbered.

   Now, of course, such renumbering could be performed, but it would
   lead to a significant disruption to the SFC as all the SFFs along the
   SFP were &quot;reprogrammed&quot;.  Thus, to achieve dynamic modification of an
   SFP (and even in-service modification), it is desirable to be able to
   make these modifications without changing the SIs of the elements
   that were present before the modification.  This will produce much
   more consistent/predictable behavior during the convergence period,
   where otherwise the change would need to be fully propagated.

   Another approach says that any change to an SFP simply creates a new
   SFP that can be assigned a new SPI.  All that would be needed would
   be to give a new instruction to the classifier, and traffic would be
   switched to the new SFP that contains the new set of SFs.  This
   approach is practical but neglects to consider that the SFP may be
   referenced by other SFPs (through &quot;branch&quot; instructions) and used by
   many classifiers.  In those cases, the corresponding configuration
   resulting from a change in SPI may have wide ripples and create scope
   for errors that are hard to trace.

   Therefore, while this document requires that the SI values in an SFP
   are monotonically decreasing, it makes no assumption that the SI
   values are sequential.  Configuration tools may apply that rule, but
   they are not required to.  To support this, an SFF SHOULD process as
   follows when it receives a packet:

   *  If the SI indicates a known entry in the SFP, the SFF MUST process
      the packet as normal, looking up the SI and determining to which
      local SFI to deliver the packet.

   *  If the SI does not match an entry in the SFP, the SFF MUST reduce
      the SI value to the next (smaller) value present in the SFP and
      process the packet using that SI.

   *  If there is no smaller SI (i.e., if the end of the SFP has been
      reached), the SFF MUST treat the SI value as not valid, as
      described in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>].

   This makes the behavior described in this document a superset of the
   function in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>].  That is, an implementation that strictly
   follows <a href="/doc/html/rfc8300">RFC 8300</a> in performing SI decrements in units of one is
   perfectly in line with the mechanisms defined in this document.

   SFF implementations MAY choose to only support contiguous SI values
   in an SFP.  Such an implementation will not support receiving an SI
   value that is not present in the SFP and will discard the packets as
   described in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>].

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  Selection within Service Function Paths</span>

   As described in <a href="#section-2">Section 2</a>, the SPI/SI in the NSH passed back from an
   SFI to the SFF may leave the SFF with a choice of next-hop SFTs and a
   choice of SFIs for each SFT.  That is, the SPI indicates an SFPR, and
   the SI indicates an entry in that SFPR.  Each entry in an SFPR is a
   set of one or more SFT/SFIR-RD pairs.  The SFF MUST choose one of
   these, identify the SFF that supports the chosen SFI, and send the
   packet to that next-hop SFF.

   The choice be may offered for load balancing across multiple SFIs, or
   for discrimination between different actions necessary at a specific
   hop in the SFP.  Different SFT values may exist at a given hop in an
   SFP to support several cases:

   *  There may be multiple instances of similar service functions that
      are distinguished by different SFT values.  For example, firewalls
      made by vendor A and vendor B may need to be identified by
      different SFT values because, while they have similar
      functionality, their behavior is not identical.  Then, some SFPs
      may limit the choice of SF at a given hop by specifying the SFT
      for vendor A, but other SFPs might not need to control which
      vendor&#x27;s SF is used and so can indicate that either SFT can be
      used.

   *  There may be an obvious branch needed in an SFP, such as the
      processing after a firewall where admitted packets continue along
      the SFP, but suspect packets are diverted to a &quot;penalty box&quot;.  In
      this case, the next hop in the SFP will be indicated with two
      different SFT values.

   In the typical case, the SFF chooses a next-hop SFF by looking at the
   set of all SFFs that support the SFs identified by the SI (that set
   having been advertised in individual SFIR advertisements), finding
   the one or more that are &quot;nearest&quot; in the underlay network, and
   choosing between next-hop SFFs using its own load-balancing
   algorithm.

   An SFI may influence this choice process by passing additional
   information back, along with the packet and NSH.  This information
   may influence local policy at the SFF to either cause it to favor a
   next-hop SFF (perhaps selecting one that is not nearest in the
   underlay) or influence the load-balancing algorithm.

   This selection applies to the normal case but also applies in the
   case of looping, jumping, and branching (see <a href="#section-6">Section 6</a>).

   Suppose an SFF in a particular service function overlay network
   (identified by a particular import RT, RT-z) needs to forward an NSH-
   encapsulated packet whose SPI is SPI-x and whose SI is SI-y.  It does
   the following:

   1.  It looks for an installed SFPR that carries RT-z and has SPI-x in
       its NLRI.  If there is none, then such packets cannot be
       forwarded.

   2.  From the SFP attribute of that SFPR, it finds the Hop TLV with SI
       value set to SI-y.  If there is no such Hop TLV, then such
       packets cannot be forwarded.

   3.  It then finds the &quot;relevant&quot; set of SFIRs by going through the
       list of SFT TLVs contained in the Hop TLV as follows:

       A.  An SFIR is relevant if it carries RT-z, the SFT in its NLRI
           matches the SFT value in one of the SFT TLVs, and the RD
           value in its NLRI matches an entry in the list of SFIR-RDs in
           that SFT TLV.

       B.  If an entry in the SFIR-RD list of an SFT TLV contains the
           value zero, then an SFIR is relevant if it carries RT-z and
           the SFT in its NLRI matches the SFT value in that SFT TLV.
           That is, any SFIR in the service function overlay network
           defined by RT-z and with the correct SFT is relevant.

       C.  If a pool identifier is in use, then an SFIR is relevant if
           it is a member of the pool.

   Each of the relevant SFIRs identifies a single SFI and contains a
   tunnel encapsulation attribute that specifies how to send a packet to
   that SFI.  For a particular packet, the SFF chooses a particular SFI
   from the set of relevant SFIRs.  This choice is made according to
   local policy.

   A typical policy might be to figure out the set of SFIs that are
   closest and load balance among them.  But this is not the only
   possible policy.

   Thus, at any point in time when an SFF selects its next hop, it
   chooses from the intersection of the set of next-hop RDs contained in
   the SFPR and the RDs contained in the SFF&#x27;s local set of SFIRs (i.e.,
   according to the determination of &quot;relevance&quot;, above).  If the
   intersection is null, the SFPR is unusable.  Similarly, when this
   condition applies on the controller that originated the SFPR, it
   SHOULD either withdraw the SFPR or re-advertise it with a new set of
   RDs for the affected hop.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Looping, Jumping, and Branching</span>

   As described in <a href="#section-2">Section 2</a>, an SFI or an SFF may cause a packet to
   &quot;loop back&quot; to a previous SF on a path in order that a sequence of
   functions may be re-executed.  This is simply achieved by replacing
   the SI in the NSH with a higher value, instead of decreasing it as
   would normally be the case, to determine the next hop in the path.

   <a href="#section-2">Section 2</a> also describes how an SFI or SFF may cause a packet to
   &quot;jump forward&quot; to an SF on a path that is not the immediate next SF
   in the SFP.  This is simply achieved by replacing the SI in the NSH
   with a lower value than would be achieved by decreasing it by the
   normal amount.

   A more complex option to move packets from one SFP to another is
   described in [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>] and <a href="#section-2">Section 2</a>, where it is termed &quot;branching&quot;.
   This mechanism allows an SFI or SFF to make a choice of downstream
   treatments for packets based on local policy and the output of the
   local SF.  Branching is achieved by changing the SPI in the NSH to
   indicate the new path and setting the SI to indicate the point in the
   path at which the packets enter.

   Note that the NSH does not include a marker to indicate whether a
   specific packet has been around a loop before.  Therefore, the use of
   NSH metadata [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>] may be required in order to prevent infinite
   loops.

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>.  Protocol Control of Looping, Jumping, and Branching</span>

   If the SFT value in an SFT TLV in an SFPR has the special-purpose SFT
   value &quot;Change Sequence&quot; (see <a href="#section-10">Section 10</a>), then this is an indication
   that the SFF may make a loop, jump, or branch according to local
   policy and information returned by the local SFI.

   In this case, the SPI and SI of the next hop are encoded in the eight
   bytes of an entry in the SFIR-RD list as follows:

      3 bytes SPI

      1 byte SI

      4 bytes Reserved (SHOULD be set to zero and ignored)

   If the SI in this encoding is not part of the SFPR indicated by the
   SPI in this encoding, then this is an explicit error that SHOULD be
   detected by the SFF when it parses the SFPR.  The SFPR SHOULD NOT
   cause any forwarding state to be installed in the SFF, and packets
   received with the SPI that indicates this SFPR SHOULD be silently
   discarded.

   If the SPI in this encoding is unknown, the SFF SHOULD NOT install
   any forwarding state for this SFPR but MAY hold the SFPR pending
   receipt of another SFPR that does use the encoded SPI.

   If the SPI matches the current SPI for the path, this is a loop or
   jump.  In this case, if the SI is greater than or equal to the
   current SI, it is a loop.  If the SPI matches and the SI is less than
   the next SI, it is a jump.

   If the SPI indicates another path, this is a branch, and the SI
   indicates the point at which to enter that path.

   The Change Sequence SFT is just another SFT that may appear in a set
   of SFI/SFT tuples within an SI and is selected as described in
   <a href="#section-5">Section 5</a>.

   Note that special-purpose SFTs MUST NOT be advertised in SFIRs.  If
   such an SFIR is received, it SHOULD be ignored.

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>.  Implications for Forwarding State</span>

   Support for looping and jumping requires that the SFF has forwarding
   state established to an SFF that provides access to an instance of
   the appropriate SF.  This means that the SFF must have seen the
   relevant SFIR advertisements and mush have known that it needed to
   create the forwarding state.  This is a matter of local configuration
   and implementation; for example, an implementation could be
   configured to install forwarding state for specific looping/jumping.

   Support for branching requires that the SFF has forwarding state
   established to an SFF that provides access to an instance of the
   appropriate entry SF on the other SFP.  This means that the SFF must
   have seen the relevant SFIR and SFPR advertisements and known that it
   needed to create the forwarding state.  This is a matter of local
   configuration and implementation; for example, an implementation
   could be configured to install forwarding state for specific
   branching (identified by SPI and SI).

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  Advanced Topics</span>

   This section highlights several advanced topics introduced elsewhere
   in this document.

<span class="h3"><a class="selflink" id="section-7.1" href="#section-7.1">7.1</a>.  Correlating Service Function Path Instances</span>

   It is often useful to create bidirectional SFPs to enable packet
   flows to traverse the same set of SFs, but in the reverse order.
   However, packets on SFPs in the data plane (per [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>]) do not
   contain a direction indicator, so each direction must use a different
   SPI.

   As described in <a href="#section-3.2.1.1">Section 3.2.1.1</a>, an SFPR can contain one or more
   correlators encoded in Association TLVs.  If the Association Type
   indicates &quot;Bidirectional SFP&quot;, then the SFP advertised in the SFPR is
   one direction of a bidirectional pair of SFPs, where the other in the
   pair is advertised in the SFPR with RD as carried in the &quot;Associated
   SFPR-RD&quot; field of the Association TLV.  The SPI carried in the
   &quot;Associated SPI&quot; field of the Association TLV provides a cross-check
   against the SPI advertised in the SFPR with RD as carried in the
   &quot;Associated SFPR-RD&quot; field of the Association TLV.

   As noted in <a href="#section-3.2.1.1">Section 3.2.1.1</a>, when SFPRs reference each other, one
   SFPR advertisement will be received before the other.  Therefore,
   processing of an association will require that the first SFPR not be
   rejected simply because the Associated SFPR-RD it carries is unknown.
   However, the SFP defined by the first SFPR is valid and SHOULD be
   available for use as a unidirectional SFP, even in the absence of an
   advertisement of its partner.

   Furthermore, in error cases where SFPR-a associates with SFPR-b, but
   SFPR-b associates with SFPR-c such that a bidirectional pair of SFPs
   cannot be formed, the individual SFPs are still valid and SHOULD be
   available for use as unidirectional SFPs.  An implementation SHOULD
   log this situation, because it represents a controller error.

   Usage of a bidirectional SFP may be programmed into the classifiers
   by the controller.  Alternatively, a classifier may look at incoming
   packets on a bidirectional packet flow, extract the SPI from the
   received NSH, and look up the SFPR to find the reverse-direction SFP
   to use when it sends packets.

   See <a href="#section-8">Section 8</a> for an example of how this works.

<span class="h3"><a class="selflink" id="section-7.2" href="#section-7.2">7.2</a>.  Considerations for Stateful Service Functions</span>

   Some service functions are stateful.  That means that they build and
   maintain state derived from configuration or the packet flows that
   they handle.  In such cases, it can be important or necessary that
   all packets from a flow continue to traverse the same instance of a
   service function so that the state can be leveraged and does not need
   to be regenerated.

   In the case of bidirectional SFPs, it may be necessary to traverse
   the same instances of a stateful service function in both directions.
   A firewall is a good example of such a service function.

   This issue becomes a concern where there are multiple parallel
   instances of a service function and a determination of which one to
   use could normally be left to the SFF as a load-balancing or local-
   policy choice.

   For the forward-direction SFP, the concern is that the same choice of
   SF is made for all packets of a flow under normal network conditions.
   It may be possible to guarantee that the load-balancing functions
   applied in the SFFs are stable and repeatable, but a controller that
   constructs SFPs might not want to trust to this.  The controller can,
   in these cases, build a number of more specific SFPs, each traversing
   a specific instance of the stateful SFs.  In this case, the load-
   balancing choice can be left up to the classifier.  Thus, the
   classifier selects which instance of a stateful SF is used by a
   particular flow by selecting the SFP that the flow uses.

   For bidirectional SFPs where the same instance of a stateful SF must
   be traversed in both directions, it is not enough to leave the choice
   of SFI as a local choice, even if the load balancing is stable,
   because coordination would be required between the decision points in
   the forward and reverse directions, and this may be hard to achieve
   in all cases except where it is the same SFF that makes the choice in
   both directions.

   Note that this approach necessarily increases the amount of SFP state
   in the network (i.e., there are more SFPs).  It is possible to
   mitigate this effect by careful construction of SFPs built from a
   concatenation of other SFPs.

   <a href="#section-8.9">Section 8.9</a> includes some simple examples of SFPs for stateful SFs.

<span class="h3"><a class="selflink" id="section-7.3" href="#section-7.3">7.3</a>.  VPN Considerations and Private Service Functions</span>

   Likely deployments include reserving specific instances of SFs for
   specific customers or allowing customers to deploy their own SFs
   within the network.  Building SFs in such environments requires that
   suitable identifiers be used to ensure that SFFs distinguish which
   SFIs can be used and which cannot.

   This problem is similar to a problem in the way that VPNs are
   supported and is solved in a similar way.  The &quot;RT&quot; field is used to
   indicate a set of SFs from which all choices must be made.

<span class="h3"><a class="selflink" id="section-7.4" href="#section-7.4">7.4</a>.  Flow Specification for SFC Classifiers</span>

   [<a id="ref-RFC8955">RFC8955</a>] defines a set of BGP routes that can be used to identify
   the packets in a given flow using fields in the header of each
   packet, and a set of actions -- encoded as Extended Communities --
   that can be used to disposition those packets.  This document enables
   the use of these mechanisms by SFC classifiers by defining a new
   action Extended Community called &quot;Flow Specification for SFC
   Classifiers&quot;, identified by the value 0x0d.  Note that implementation
   of this section of this specification will be controllers or
   classifiers communicating with each other directly for the purpose of
   instructing the classifier how to place packets onto an SFP.  So that
   the implementation of classifiers can be kept simple, and to avoid
   the confusion between the purposes of different Extended Communities,
   a controller MUST NOT include other action Extended Communities at
   the same time as a &quot;Flow Specification for SFC Classifiers&quot; Extended
   Community.  A &quot;Flow Specification for SFC Classifiers&quot; Traffic
   Filtering Action Extended Community advertised with any other Traffic
   Filtering Action Extended Community MUST be treated as malformed in
   line with [<a href="/doc/html/rfc8955" title="&quot;Dissemination of Flow Specification Rules&quot;">RFC8955</a>] and result in the flow-specification UPDATE
   message being handled as &quot;treat-as-withdraw&quot;, according to <a href="/doc/html/rfc7606#section-2">[RFC7606],
   Section&nbsp;2</a>.

   To put the flow specification into context, when multiple service
   function chaining overlays are present in one network, each FlowSpec
   update MUST be tagged with the route target of the overlay or VPN
   network for which it is intended.

   This Extended Community is encoded as an 8-octet value, as shown in
   Figure 10.


                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Type=0x80     | Sub-Type=0x0d |  SPI                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  SPI  (cont.) |   SI          |  SFT                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          Figure 10: The Format of the Flow Specification for SFC
                       Classifiers Extended Community

   The Extended Community contains the Service Path Identifier (SPI),
   Service Index (SI), and Service Function Type (SFT), as defined
   elsewhere in this document.  Thus, each action extended community
   defines the entry point (not necessarily the first hop) into a
   specific SFP.  This allows, for example, different flows to enter the
   same SFP at different points.

   Note that, according to [<a href="/doc/html/rfc8955" title="&quot;Dissemination of Flow Specification Rules&quot;">RFC8955</a>], a given flow-specification update
   may include multiple of these action Extended Communities.  If a
   given action extended community does not contain an installed SFPR
   with the specified {SPI, SI, SFT}, it MUST NOT be used for
   dispositioning the packets of the specified flow.

   The normal case of packet classification for service function
   chaining will see a packet enter the SFP at its first hop.  In this
   case, the SI in the Extended Community is superfluous, and the SFT
   may also be unnecessary.  To allow these cases to be handled, a
   special meaning is assigned to an SI of zero (not a valid value) and
   an SFT of zero (a reserved value in the registry -- see
   <a href="#section-10.5">Section 10.5</a>).

   *  If an SFC Classifiers Extended Community is received with SI = 0,
      then it means that the first hop of the SFP indicated by the SPI
      MUST be used.

   *  If an SFC Classifiers Extended Community is received with SFT = 0,
      then there are two subcases:

      -  If there is a choice of SFT in the hop indicated by the value
         of the SI (including SI = 0), then SFT = 0 means there is a
         free choice of which SFT to use, according to local policy).

      -  If there is no choice of SFT in the hop indicated by the value
         of SI, then SFT = 0 means that the value of the SFT at that
         hop, as indicated in the SFPR for the indicated SPI, MUST be
         used.

   One of the filters that the flow specification may describe is the
   VPN to which the traffic belongs.  Additionally, as noted above, to
   put the indicated SPI into context when multiple SFC overlays are
   present in one network, each FlowSpec update MUST be tagged with the
   route target of the overlay or VPN network for which it is intended.

   Note that future extensions might be made to the Flow Specification
   for SFC Classifiers Extended Community to provide instruction to the
   classifier about what metadata to add to packets that it classifies
   for forwarding on a specific SFP; however, that is outside the scope
   of this document.

<span class="h3"><a class="selflink" id="section-7.5" href="#section-7.5">7.5</a>.  Choice of Data Plane SPI/SI Representation</span>

   This document ties together the control and data planes of a service
   function chaining overlay network through the use of the SPI/SI that
   is nominally carried in the NSH of a given packet.  However, in order
   to handle situations in which the NSH is not ubiquitously deployed,
   it is also possible to use alternative data plane representations of
   the SPI/SI by carrying the identical semantics in other protocol
   fields, such as MPLS labels [<a href="/doc/html/rfc8595" title="&quot;An MPLS-Based Forwarding Plane for Service Function Chaining&quot;">RFC8595</a>].

   This document defines a new Sub-TLV for the tunnel encapsulation
   attribute [<a href="/doc/html/rfc9012" title="&quot;The BGP Tunnel Encapsulation Attribute&quot;">RFC9012</a>], the SPI/SI Representation Sub-TLV of type 16.
   This Sub-TLV MAY be present in each Tunnel TLV contained in a tunnel
   encapsulation attribute when the attribute is carried by an SFIR.
   The &quot;Value&quot; field of this Sub-TLV is a two-octet field of flags
   numbered counting from the most significant bit, each of which
   describes how the originating SFF expects to see the SPI/SI
   represented in the data plane for packets carried in the tunnels
   described by the Tunnel TLV.

   The following bits are defined by this document and are tracked in an
   IANA registry described in <a href="#section-10.10">Section 10.10</a>:

   Bit 0:  If this bit is set, the NSH is to be used to carry the SPI/SI
      in the data plane.

   Bit 1:  If this bit is set, two labels in an MPLS label stack are to
      be used as described in <a href="#section-7.5.1">Section 7.5.1</a>.

   If a given Tunnel TLV does not contain an SPI/SI Representation Sub-
   TLV, then it MUST be processed as if such a Sub-TLV is present with
   Bit 0 set and no other bits set.  That is, the absence of the Sub-TLV
   SHALL be interpreted to mean that the NSH is to be used.

   If a given Tunnel TLV contains an SPI/SI Representation Sub-TLV with
   a &quot;Value&quot; field that has no flag set, then the tunnel indicated by
   the Tunnel TLV MUST NOT be used for forwarding SFC packets.  If a
   given Tunnel TLV contains an SPI/SI Representation Sub-TLV with both
   bit 0 and bit 1 set, then the tunnel indicated by the Tunnel TLV MUST
   NOT be used for forwarding SFC packets.  The meaning and rules for
   the presence of other bits is to be defined in future documents, but
   implementations of this specification MUST set other bits to zero and
   ignore them on receipt.

   If a given Tunnel TLV contains more than one SPI/SI Representation
   Sub-TLV, then the first one MUST be considered and subsequent
   instances MUST be ignored.

   Note that the MPLS representation of the logical NSH may be used even
   if the tunnel is not an MPLS tunnel.  Conversely, MPLS tunnels may be
   used to carry other encodings of the logical NSH (specifically, the
   NSH itself).  It is a requirement that both ends of a tunnel over the
   underlay network know that the tunnel is used for service function
   chaining and know what form of NSH representation is used.  The
   signaling mechanism described here allows coordination of this
   information.

<span class="h4"><a class="selflink" id="section-7.5.1" href="#section-7.5.1">7.5.1</a>.  MPLS Representation of the SPI/SI</span>

   If bit 1 is set in the SPI/SI Representation Sub-TLV, then labels in
   the MPLS label stack are used to indicate SFC forwarding and
   processing instructions to achieve the semantics of a logical NSH.
   The label stack is encoded as shown in [<a href="/doc/html/rfc8595" title="&quot;An MPLS-Based Forwarding Plane for Service Function Chaining&quot;">RFC8595</a>].

<span class="h3"><a class="selflink" id="section-7.6" href="#section-7.6">7.6</a>.  MPLS Label Swapping/Stacking Operation</span>

   When a classifier constructs an MPLS label stack for an SFP, it
   starts with that SFP&#x27;s last hop.  If the last hop requires an {SPI,
   SI} label pair for label swapping, it pushes the SI (set to the SI
   value of the last hop) and the SFP&#x27;s SPI onto the MPLS label stack.
   If the last hop requires a {context label, SFI label} label pair for
   label stacking, it selects a specific SFIR and pushes that SFIR&#x27;s SFI
   label and context label onto the MPLS label stack.

   The classifier then moves sequentially back through the SFP one hop
   at a time.  For each hop, if the hop requires an {SPI, SI} and there
   is an {SPI, SI} at the top of the MPLS label stack, the SI is set to
   the SI value of the current hop.  If there is not an {SPI, SI} at the
   top of the MPLS label stack, it pushes the SI (set to the SI value of
   the current hop) and the SFP&#x27;s SPI onto the MPLS label stack.

   If the hop requires a {context label, SFI label}, it selects a
   specific SFIR and pushes that SFIR&#x27;s SFI label and context label onto
   the MPLS label stack.

<span class="h3"><a class="selflink" id="section-7.7" href="#section-7.7">7.7</a>.  Support for MPLS-Encapsulated NSH Packets</span>

   [<a id="ref-RFC8596">RFC8596</a>] describes how to transport SFC packets using the NSH over
   an MPLS transport network.  Signaling that this approach is in use is
   supported by this document as follows:

   *  A &quot;BGP Tunnel Encapsulation Attribute&quot; Sub-TLV is included with
      the codepoint 10 (representing &quot;MPLS Label Stack&quot;) from the &quot;BGP
      Tunnel Encapsulation Attribute Sub-TLVs&quot; registry defined in
      [<a href="/doc/html/rfc9012" title="&quot;The BGP Tunnel Encapsulation Attribute&quot;">RFC9012</a>].

   *  An &quot;SFP Traversal With MPLS Label Stack&quot; TLV is included
      containing an &quot;SPI/SI Representation&quot; Sub-TLV with bit 0 set and
      bit 1 cleared.

   In this case, the MPLS label stack constructed by the SFF to forward
   a packet to the next SFF on the SFP will consist of the labels needed
   to reach that SFF, and if label stacking is used, it will also
   include the labels advertised in the MPLS Label Stack Sub-TLV and the
   labels remaining in the stack needed to traverse the remainder of the
   SFP.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  Examples</span>

   Most of the examples in this section use IPv4 addressing.  But there
   is nothing special about IPv4 in the mechanisms described in this
   document, and they are equally applicable to IPv6.  A few examples
   using IPv6 addressing are provided in <a href="#section-8.10">Section 8.10</a>.

   Assume we have a service function overlay network with four SFFs
   (SFF1, SFF2, SFF3, and SFF4).  The SFFs have addresses in the
   underlay network as follows:

      SFF1 192.0.2.1
      SFF2 192.0.2.2
      SFF3 192.0.2.3
      SFF4 192.0.2.4

   Each SFF provides access to some SFIs from the four SFTs, SFT=41,
   SFT=42, SFT=43, and SFT=44, as follows:

      SFF1 SFT=41 and SFT=42
      SFF2 SFT=41 and SFT=43
      SFF3 SFT=42 and SFT=44
      SFF4 SFT=43 and SFT=44

   The service function network also contains a controller with address
   198.51.100.1.

   This example service function overlay network is shown in Figure 11.


          --------------
         |  Controller  |
         | 198.51.100.1 |   ------     ------    ------     ------
          --------------   | SFI  |   | SFI  |  | SFI  |   | SFI  |
                           |SFT=41|   |SFT=42|  |SFT=41|   |SFT=43|
                            ------     ------    ------     ------
                                 \     /              \     /
                                ---------            ---------
                  ----------   |   SFF1  |          |   SFF2  |
      Packet --&gt; |          |  |192.0.2.1|          |192.0.2.2|
      Flows  --&gt; |Classifier|   ---------            ---------  --&gt;Dest
                 |          |                                   --&gt;
                  ----------    ---------            ---------
                               |   SFF3  |          |   SFF4  |
                               |192.0.2.3|          |192.0.2.4|
                                ---------            ---------
                                 /     \              /     \
                            ------     ------    ------     ------
                           | SFI  |   | SFI  |  | SFI  |   | SFI  |
                           |SFT=42|   |SFT=44|  |SFT=43|   |SFT=44|
                            ------     ------    ------     ------

            Figure 11: Example Service Function Overlay Network

   The SFFs advertise routes to the SFIs they support.  These
   advertisements contain RDs that are set according to the network
   operator&#x27;s configuration model.  In all of these IPv4 examples, we
   use RDs of Type 1 such that the available six octets are partitioned
   as four octets for the IPv4 address of the advertising SFF, and two
   octets that are a local index of the SFI.  This scheme is chosen
   purely for convenience of documentation, and an operator is totally
   free to use any other scheme so long as it conforms to the
   definitions of SFIR and SFPR in Sections <a href="#section-3.1">3.1</a> and <a href="#section-3.2">3.2</a>.

   Thus, we see the following SFIRs advertised:

      RD = 192.0.2.1/1, SFT = 41
      RD = 192.0.2.1/2, SFT = 42
      RD = 192.0.2.2/1, SFT = 41
      RD = 192.0.2.2/2, SFT = 43
      RD = 192.0.2.3/7, SFT = 42
      RD = 192.0.2.3/8, SFT = 44
      RD = 192.0.2.4/5, SFT = 43
      RD = 192.0.2.4/6, SFT = 44

   Note that the addressing used for communicating between SFFs is taken
   from the tunnel encapsulation attribute of the SFIR and not from the
   SFIR-RD.

<span class="h3"><a class="selflink" id="section-8.1" href="#section-8.1">8.1</a>.  Example Explicit SFP with No Choices</span>

   Consider the following SFPR.

      SFP1:  RD = 198.51.100.1/101, SPI = 15,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 43, RD = 192.0.2.2/2]

   The SFP consists of an SF of Type 41 located at SFF1, followed by an
   SF of Type 43 located at SFF2.  This path is fully explicit, and each
   SFF is offered no choice in forwarding packets along the path.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (15).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 has no flexibility in the
   choice of SFF to support the next-hop SFI and will forward the packet
   to SFF2, which will send the packets to the SFI that supports SFT 43
   before forwarding the packets to their destinations.

<span class="h3"><a class="selflink" id="section-8.2" href="#section-8.2">8.2</a>.  Example SFP with Choice of SFIs</span>

      SFP2:  RD = 198.51.100.1/102, SPI = 16,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 43, {RD = 192.0.2.2/2,
                                   RD = 192.0.2.4/5 } ]

   In this example, the path also consists of an SF of Type 41 located
   at SFF1, and this is followed by an SF of Type 43.  However, in this
   case, the SI = 250 contains a choice between the SFI located at SFF2
   and the SFI located at SFF4.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (16).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 now has a choice of next-hop
   SFFs to execute the next hop in the path.  It can either forward
   packets to SFF2 or SFF4 to execute a function of Type 43.  It uses
   its local load-balancing algorithm to make this choice.  The chosen
   SFF will send the packets to the SFI that supports SFT 43 before
   forwarding the packets to their destinations.

<span class="h3"><a class="selflink" id="section-8.3" href="#section-8.3">8.3</a>.  Example SFP with Open Choice of SFIs</span>

      SFP3:  RD = 198.51.100.1/103, SPI = 17,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 44, RD = 0]

   In this example, the path also consists of an SF of Type 41 located
   at SFF1, and this is followed by an SI with an RD of zero and SF of
   Type 44.  This means that a choice can be made between any SFF that
   supports an SFI of Type 44.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (17).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 now has a free choice of
   next-hop SFFs to execute the next hop in the path, selecting between
   all SFFs that support SFs of Type 44.  Looking at the SFIRs it has
   received, SFF1 knows that SF Type 44 is supported by SFF3 and SFF4.
   SFF1 uses its local load-balancing algorithm to make this choice.
   The chosen SFF will send the packets to the SFI that supports SFT 44
   before forwarding the packets to their destinations.

<span class="h3"><a class="selflink" id="section-8.4" href="#section-8.4">8.4</a>.  Example SFP with Choice of SFTs</span>

      SFP4:  RD = 198.51.100.1/104, SPI = 18,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, {SFT = 43, RD = 192.0.2.2/2,
                         SFT = 44, RD = 192.0.2.3/8 } ]

   This example provides a choice of SF type in the second hop in the
   path.  The SI of 250 indicates a choice between SF Type 43 located at
   SF2 and SF Type 44 located at SF3.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (18).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 now has a free choice of
   next-hop SFFs to execute the next hop in the path, selecting between
   all SFFs that support an SF of Type 43 and SFF3, which supports an SF
   of Type 44.  These may be completely different functions that are to
   be executed dependent on specific conditions, or they may be similar
   functions identified with different type identifiers (such as
   firewalls from different vendors).  SFF1 uses its local policy and
   load-balancing algorithm to make this choice and may use additional
   information passed back from the local SFI to help inform its
   selection.  The chosen SFF will send the packets to the SFI that
   supports the chosen SFT before forwarding the packets to their
   destinations.

<span class="h3"><a class="selflink" id="section-8.5" href="#section-8.5">8.5</a>.  Example Correlated Bidirectional SFPs</span>

     SFP5:  RD = 198.51.100.1/105, SPI = 19,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/106, Assoc-SPI = 20,
            [SI = 255, SFT = 41, RD = 192.0.2.1/1],
            [SI = 250, SFT = 43, RD = 192.0.2.2/2]

     SFP6:  RD = 198.51.100.1/106, SPI = 20,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/105, Assoc-SPI = 19,
            [SI = 254, SFT = 43, RD = 192.0.2.2/2],
            [SI = 249, SFT = 41, RD = 192.0.2.1/1]

   This example demonstrates correlation of two SFPs to form a
   bidirectional SFP, as described in <a href="#section-7.1">Section 7.1</a>.

   Two SFPRs are advertised by the controller.  They have different SPIs
   (19 and 20), so they are known to be separate SFPs, but they both
   have Association TLVs with Association Type set to 1, indicating
   bidirectional SFPs.  Each has an &quot;Associated SFPR-RD&quot; field
   containing the value of the other SFPR-RD to correlate the two SFPs
   as a bidirectional pair.

   As can be seen from the SFPRs in this example, the paths are
   symmetric: the hops in SFP5 appear in the reverse order in SFP6.

<span class="h3"><a class="selflink" id="section-8.6" href="#section-8.6">8.6</a>.  Example Correlated Asymmetrical Bidirectional SFPs</span>

     SFP7:  RD = 198.51.100.1/107, SPI = 21,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/108, Assoc-SPI = 22,
            [SI = 255, SFT = 41, RD = 192.0.2.1/1],
            [SI = 250, SFT = 43, RD = 192.0.2.2/2]

     SFP8:  RD = 198.51.100.1/108, SPI = 22,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/107, Assoc-SPI = 21,
            [SI = 254, SFT = 44, RD = 192.0.2.4/6],
            [SI = 249, SFT = 41, RD = 192.0.2.1/1]

   Asymmetric bidirectional SFPs can also be created.  This example
   shows a pair of SFPs with distinct SPIs (21 and 22) that are
   correlated in the same way as in the example in <a href="#section-8.5">Section 8.5</a>.

   However, unlike in that example, the SFPs are different in each
   direction.  Both paths include a hop of SF Type 41, but SFP7 includes
   a hop of SF Type 43 supported at SFF2, while SFP8 includes a hop of
   SF Type 44 supported at SFF4.

<span class="h3"><a class="selflink" id="section-8.7" href="#section-8.7">8.7</a>.  Example Looping in an SFP</span>

      SFP9:  RD = 198.51.100.1/109, SPI = 23,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 44, RD = 192.0.2.4/5],
             [SI = 245, {SFT = 1, RD = {SPI=23, SI=255, Rsv=0},
                         SFT = 42, RD = 192.0.2.3/7 } ]

   Looping and jumping are described in <a href="#section-6">Section 6</a>.  This example shows
   an SFP that contains an explicit loop-back instruction that is
   presented as a choice within an SFP hop.

   The first two hops in the path (SI = 255 and SI = 250) are normal.
   That is, the packets will be delivered to SFF1 and SFF4 in turn for
   execution of SFs of Type 41 and 44, respectively.

   The third hop (SI = 245) presents SFF4 with a choice of next hop.  It
   can either forward the packets to SFF3 for an SF of Type 42 (the
   second choice) or it can loop back.

   The loop-back entry in the SFPR for SI = 245 is indicated by the
   special-purpose SFT value 1 (&quot;Change Sequence&quot;).  Within this hop,
   the RD is interpreted as encoding the SPI and SI of the next hop (see
   <a href="#section-6.1">Section 6.1</a>).  In this case, the SPI is 23, which indicates that this
   is a loop or branch, i.e., the next hop is on the same SFP.  The SI
   is set to 255; this is a higher number than the current SI (245),
   indicating a loop.

   SFF4 must make a choice between these two next hops.  The packet will
   be either forwarded to SFF3 with the NSH SI decreased to 245 or
   looped back to SFF1 with the NSH SI reset to 255.  This choice will
   be made according to local policy, information passed back by the
   local SFI, and details in the packets&#x27; metadata that are used to
   prevent infinite looping.

<span class="h3"><a class="selflink" id="section-8.8" href="#section-8.8">8.8</a>.  Example Branching in an SFP</span>

      SFP10:  RD = 198.51.100.1/110, SPI = 24,
             [SI = 254, SFT = 42, RD = 192.0.2.3/7],
             [SI = 249, SFT = 43, RD = 192.0.2.2/2]

      SFP11:  RD = 198.51.100.1/111, SPI = 25,
             [SI = 255, SFT = 41, RD = 192.0.2.1/1],
             [SI = 250, SFT = 1, RD = {SPI=24, SI=254, Rsv=0}]

   Branching follows a similar procedure to that for looping (and
   jumping), as shown in <a href="#section-8.7">Section 8.7</a>.  However, there are two SFPs
   involved.

   SFP10 shows a normal path with packets forwarded to SFF3 and SFF2 for
   execution of service functions of Type 42 and 43, respectively.

   SFP11 starts as normal (SFF1 for an SF of Type 41), but then SFF1
   processes the next hop in the path and finds a &quot;Change Sequence&quot;
   special-purpose SFT.  The &quot;SFIR-RD&quot; field includes an SPI of 24,
   which indicates SFP10, not the current SFP.  The SI in the SFIR-RD is
   254, so SFF1 knows that it must set the SPI/SI in the NSH to 24/254
   and send the packets to the appropriate SFF, as advertised in the
   SFPR for SFP10 (that is, SFF3).

<span class="h3"><a class="selflink" id="section-8.9" href="#section-8.9">8.9</a>.  Examples of SFPs with Stateful Service Functions</span>

   This section provides some examples to demonstrate establishing SFPs
   when there is a choice of service functions at a particular hop, and
   where consistency of choice is required in both directions.  The
   scenarios that give rise to this requirement are discussed in
   <a href="#section-7.2">Section 7.2</a>.

<span class="h4"><a class="selflink" id="section-8.9.1" href="#section-8.9.1">8.9.1</a>.  Forward and Reverse Choice Made at the SFF</span>

   Consider the topology shown in Figure 12.  There are three SFFs
   arranged neatly in a line, and the middle one (SFF2) supports three
   SFIs all of SFT 42.  These three instances can be used by SFF2 to
   load balance so that no one instance is swamped.

                   ------     ------   ------   ------    ------
                  | SFI  |   | SFIa | | SFIb | | SFIc |  | SFI  |
                  |SFT=41|   |SFT=42| |SFT=42| |SFT=42|  |SFT=43|
                   ------     ------\  ------  /------    ------
                        \            \   |    /           /
                       ---------     ---------     ---------
         ----------   |   SFF1  |   |   SFF2  |   |   SFF3  |
    --&gt; |          |..|192.0.2.1|...|192.0.2.2|...|192.0.2.3|--&gt;
    --&gt; |Classifier|   ---------     ---------     ---------
        |          |
         ----------

             Figure 12: Example Where Choice Is Made at the SFF

   This leads to the following SFIRs being advertised.

      RD = 192.0.2.1/11, SFT = 41
      RD = 192.0.2.2/11, SFT = 42  (for SFIa)
      RD = 192.0.2.2/12, SFT = 42  (for SFIb)
      RD = 192.0.2.2/13, SFT = 42  (for SFIc)
      RD = 192.0.2.3/11, SFT = 43

   The controller can create a single forward SFP (SFP12), giving SFF2
   the choice of which SFI to use to provide a function of SFT 42, as
   follows.  The load-balancing choice between the three available SFIs
   is assumed to be within the capabilities of the SFF, and if the SFs
   are stateful, it is assumed that the SFF knows this and arranges load
   balancing in a stable, flow-dependent way.

      SFP12:  RD = 198.51.100.1/112, SPI = 26,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/113, Assoc-SPI = 27,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, {RD = 192.0.2.2/11,
                                        192.0.2.2/12,
                                        192.0.2.2/13 }],
             [SI = 253, SFT = 43, RD = 192.0.2.3/11]

   The reverse SFP (SFP13) in this case may also be created as shown
   below, using association with the forward SFP and giving the load-
   balancing choice to SFF2.  This is safe, even in the case that the
   SFs of Type 42 are stateful, because SFF2 is doing the load balancing
   in both directions and can apply the same algorithm to ensure that
   packets associated with the same flow use the same SFI regardless of
   the direction of travel.

      SFP13:  RD = 198.51.100.1/113, SPI = 27,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/112, Assoc-SPI = 26,
             [SI = 255, SFT = 43, RD = 192.0.2.3/11],
             [SI = 254, SFT = 42, {RD = 192.0.2.2/11,
                                        192.0.2.2/12,
                                        192.0.2.2/13 }],
             [SI = 253, SFT = 41, RD = 192.0.2.1/11]

   How an SFF knows that an attached SFI is stateful is out of the scope
   of this document.  It is assumed that this will form part of the
   process by which SFIs are registered as local to SFFs.  <a href="#section-7.2">Section 7.2</a>
   provides additional observations about the coordination of the use of
   stateful SFIs in the case of bidirectional SFPs.

   In general, the problems of load balancing and the selection of the
   same SFIs in both directions of a bidirectional SFP can be addressed
   by using sufficiently precisely specified SFPs (specifying the exact
   SFIs to use) and suitable programming of the classifiers at each end
   of the SFPs to make sure that the matching pair of SFPs are used.

<span class="h4"><a class="selflink" id="section-8.9.2" href="#section-8.9.2">8.9.2</a>.  Parallel End-to-End SFPs with Shared SFF</span>

   The mechanism described in <a href="#section-8.9.1">Section 8.9.1</a> might not be desirable
   because of the functional assumptions it places on SFF2 to be able to
   load balance with suitable flow identification, stability, and
   equality in both directions.  Instead, it may be desirable to place
   the responsibility for flow classification in the classifier and let
   it determine load balancing with the implied choice of SFIs.

   Consider the network graph as shown in Figure 12 and with the same
   set of SFIRs as listed in <a href="#section-8.9.1">Section 8.9.1</a>.  In this case, the
   controller could specify three forward SFPs with their corresponding
   associated reverse SFPs.  Each bidirectional pair of SFPs uses a
   different SFI for the SF of Type 42.  The controller can instruct the
   classifier how to place traffic on the three bidirectional SFPs, or
   it can treat them as a group, leaving the classifier responsible for
   balancing the load.

      SFP14:  RD = 198.51.100.1/114, SPI = 28,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/117, Assoc-SPI = 31,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, RD = 192.0.2.2/11],
             [SI = 253, SFT = 43, RD = 192.0.2.3/11]

      SFP15:  RD = 198.51.100.1/115, SPI = 29,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/118, Assoc-SPI = 32,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, RD = 192.0.2.2/12],
             [SI = 253, SFT = 43, RD = 192.0.2.3/11]

      SFP16:  RD = 198.51.100.1/116, SPI = 30,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/119, Assoc-SPI = 33,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, RD = 192.0.2.2/13],
             [SI = 253, SFT = 43, RD = 192.0.2.3/11]

      SFP17:  RD = 198.51.100.1/117, SPI = 31,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/114, Assoc-SPI = 28,
             [SI = 255, SFT = 43, RD = 192.0.2.3/11],
             [SI = 254, SFT = 42, RD = 192.0.2.2/11],
             [SI = 253, SFT = 41, RD = 192.0.2.1/11]

      SFP18:  RD = 198.51.100.1/118, SPI = 32,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/115, Assoc-SPI = 29,
             [SI = 255, SFT = 43, RD = 192.0.2.3/11],
             [SI = 254, SFT = 42, RD = 192.0.2.2/12],
             [SI = 253, SFT = 41, RD = 192.0.2.1/11]

      SFP19:  RD = 198.51.100.1/119, SPI = 33,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/116, Assoc-SPI = 30,
             [SI = 255, SFT = 43, RD = 192.0.2.3/11],
             [SI = 254, SFT = 42, RD = 192.0.2.2/13],
             [SI = 253, SFT = 41, RD = 192.0.2.1/11]

<span class="h4"><a class="selflink" id="section-8.9.3" href="#section-8.9.3">8.9.3</a>.  Parallel End-to-End SFPs with Separate SFFs</span>

   While the examples in Sections <a href="#section-8.9.1">8.9.1</a> and <a href="#section-8.9.2">8.9.2</a> place the choice of
   SFI as subtended from the same SFF, it is also possible that the SFIs
   are each subtended from a different SFF, as shown in Figure 13.  In
   this case, it is harder to coordinate the choices for forward and
   reverse paths without some form of coordination between SFF1 and
   SFF3.  Therefore, it would be normal to consider end-to-end parallel
   SFPs, as described in <a href="#section-8.9.2">Section 8.9.2</a>.


                                        ------
                                       | SFIa |
                                       |SFT=42|
                                        ------
                         ------           |
                        | SFI  |      ---------
                        |SFT=41|     |   SFF5  |
                         ------    ..|192.0.2.5|..
                           |     ..:  ---------  :..
                       ---------.:                 :.---------
         ----------   |   SFF1  |     ---------     |   SFF3  |
    --&gt; |          |..|192.0.2.1|....|   SFF6  |....|192.0.2.3| --&gt;
    --&gt; |Classifier|   ---------:    |192.0.2.6|    :---------
        |          |            :     ---------     :    |
         ----------             :         |         :  ------
                                :       ------      : | SFI  |
                                :..    | SFIb |   ..: |SFT=43|
                                  :..  |SFT=42| ..:    ------
                                    :   ------  :
                                    :.---------.:
                                     |   SFF7  |
                                     |192.0.2.7|
                                      ---------
                                          |
                                        ------
                                       | SFIc |
                                       |SFT=42|
                                        ------

          Figure 13: Second Example with Parallel End-to-End SFPs

   In this case, five SFIRs are advertised as follows:

      RD = 192.0.2.1/11, SFT = 41
      RD = 192.0.2.5/11, SFT = 42  (for SFIa)
      RD = 192.0.2.6/11, SFT = 42  (for SFIb)
      RD = 192.0.2.7/11, SFT = 42  (for SFIc)
      RD = 192.0.2.3/11, SFT = 43

   In this case, the controller could specify three forward SFPs with
   their corresponding associated reverse SFPs.  Each bidirectional pair
   of SFPs uses a different SFF and SFI for the middle hop (for an SF of
   Type 42).  The controller can instruct the classifier how to place
   traffic on the three bidirectional SFPs, or it can treat them as a
   group, leaving the classifier responsible for balancing the load.

      SFP20:  RD = 198.51.100.1/120, SPI = 34,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/123, Assoc-SPI = 37,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, RD = 192.0.2.5/11],
             [SI = 253, SFT = 43, RD = 192.0.2.3/11]

      SFP21:  RD = 198.51.100.1/121, SPI = 35,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/124, Assoc-SPI = 38,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, RD = 192.0.2.6/11],
             [SI = 253, SFT = 43, RD = 192.0.2.3/11]

      SFP22:  RD = 198.51.100.1/122, SPI = 36,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/125, Assoc-SPI = 39,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, RD = 192.0.2.7/11],
             [SI = 253, SFT = 43, RD = 192.0.2.3/11]

      SFP23:  RD = 198.51.100.1/123, SPI = 37,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/120, Assoc-SPI = 34,
             [SI = 255, SFT = 43, RD = 192.0.2.3/11],
             [SI = 254, SFT = 42, RD = 192.0.2.5/11],
             [SI = 253, SFT = 41, RD = 192.0.2.1/11]

      SFP24:  RD = 198.51.100.1/124, SPI = 38,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/121, Assoc-SPI = 35,
             [SI = 255, SFT = 43, RD = 192.0.2.3/11],
             [SI = 254, SFT = 42, RD = 192.0.2.6/11],
             [SI = 253, SFT = 41, RD = 192.0.2.1/11]

      SFP25:  RD = 198.51.100.1/125, SPI = 39,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/122, Assoc-SPI = 36,
             [SI = 255, SFT = 43, RD = 192.0.2.3/11],
             [SI = 254, SFT = 42, RD = 192.0.2.7/11],
             [SI = 253, SFT = 41, RD = 192.0.2.1/11]

<span class="h4"><a class="selflink" id="section-8.9.4" href="#section-8.9.4">8.9.4</a>.  Parallel SFPs Downstream of the Choice</span>

   The mechanism of parallel SFPs demonstrated in <a href="#section-8.9.3">Section 8.9.3</a> is
   perfectly functional and may be practical in many environments.
   However, there may be scaling concerns because of the large amount of
   state (knowledge of SFPs -- i.e., SFPR advertisements retained) if
   there is a very large number of possible SFIs (for example, tens of
   instances of the same stateful SF) or if there are multiple choices
   of stateful SF along a path.  This situation may be mitigated using
   SFP fragments that are combined to form the end-to-end SFPs.

   The example presented here is necessarily simplistic but should
   convey the basic principle.  The example presented in Figure 14 is
   similar to that in <a href="#section-8.9.3">Section 8.9.3</a> but with an additional first hop.


                                             ------
                                            | SFIa |
                                            |SFT=43|
                                             ------
                  ------      ------           |
                 | SFI  |    | SFI  |      ---------
                 |SFT=41|    |SFT=42|     |   SFF5  |
                  ------      ------    ..|192.0.2.5|..
                    |           |     ..:  ---------  :..
                ---------   ---------.:                 :.---------
       ------  |   SFF1  | |   SFF2  |     ---------     |   SFF3  |
   --&gt;|Class-|.|192.0.2.1|.|192.0.2.2|....|   SFF6  |....|192.0.2.3|--&gt;
   --&gt;| ifier|  ---------   ---------:    |192.0.2.6|    :---------
       ------                        :     ---------     :    |
                                     :         |         :  ------
                                     :       ------      : | SFI  |
                                     :..    | SFIb |   ..: |SFT=44|
                                       :..  |SFT=43| ..:    ------
                                         :   ------  :
                                         :.---------.:
                                          |   SFF7  |
                                          |192.0.2.7|
                                           ---------
                                               |
                                             ------
                                            | SFIc |
                                            |SFT=43|
                                             ------

         Figure 14: Example with Parallel SFPs Downstream of Choice

   The six SFIs are advertised as follows:

      RD = 192.0.2.1/11, SFT = 41
      RD = 192.0.2.2/11, SFT = 42
      RD = 192.0.2.5/11, SFT = 43  (for SFIa)
      RD = 192.0.2.6/11, SFT = 43  (for SFIb)
      RD = 192.0.2.7/11, SFT = 43  (for SFIc)
      RD = 192.0.2.3/11, SFT = 44

   SFF2 is the point at which a load-balancing choice must be made.  So
   &quot;tail-end&quot; SFPs are constructed as follows.  Each takes in a
   different SFF that provides access to an SF of Type 43.

      SFP26:  RD = 198.51.100.1/126, SPI = 40,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/130, Assoc-SPI = 44,
             [SI = 255, SFT = 43, RD = 192.0.2.5/11],
             [SI = 254, SFT = 44, RD = 192.0.2.3/11]

      SFP27:  RD = 198.51.100.1/127, SPI = 41,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/131, Assoc-SPI = 45,
             [SI = 255, SFT = 43, RD = 192.0.2.6/11],
             [SI = 254, SFT = 44, RD = 192.0.2.3/11]

      SFP28:  RD = 198.51.100.1/128, SPI = 42,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/132, Assoc-SPI = 46,
             [SI = 255, SFT = 43, RD = 192.0.2.7/11],
             [SI = 254, SFT = 44, RD = 192.0.2.3/11]

   Now an end-to-end SFP with load-balancing choice can be constructed
   as follows.  The choice made by SFF2 is expressed in terms of
   entering one of the three &quot;tail-end&quot; SFPs.

      SFP29:  RD = 198.51.100.1/129, SPI = 43,
             [SI = 255, SFT = 41, RD = 192.0.2.1/11],
             [SI = 254, SFT = 42, RD = 192.0.2.2/11],
             [SI = 253, {SFT = 1, RD = {SPI=40, SI=255, Rsv=0},
                                  RD = {SPI=41, SI=255, Rsv=0},
                                  RD = {SPI=42, SI=255, Rsv=0} } ]

   Now, despite the load-balancing choice being made elsewhere than at
   the initial classifier, it is possible for the reverse SFPs to be
   well constructed without any ambiguity.  The three reverse paths
   appear as follows.

      SFP30:  RD = 198.51.100.1/130, SPI = 44,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/126, Assoc-SPI = 40,
             [SI = 255, SFT = 44, RD = 192.0.2.4/11],
             [SI = 254, SFT = 43, RD = 192.0.2.5/11],
             [SI = 253, SFT = 42, RD = 192.0.2.2/11],
             [SI = 252, SFT = 41, RD = 192.0.2.1/11]

      SFP31:  RD = 198.51.100.1/131, SPI = 45,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/127, Assoc-SPI = 41,
             [SI = 255, SFT = 44, RD = 192.0.2.4/11],
             [SI = 254, SFT = 43, RD = 192.0.2.6/11],
             [SI = 253, SFT = 42, RD = 192.0.2.2/11],
             [SI = 252, SFT = 41, RD = 192.0.2.1/11]

      SFP32:  RD = 198.51.100.1/132, SPI = 46,
            Assoc-Type = 1, Assoc-RD = 198.51.100.1/128, Assoc-SPI = 42,
             [SI = 255, SFT = 44, RD = 192.0.2.4/11],
             [SI = 254, SFT = 43, RD = 192.0.2.7/11],
             [SI = 253, SFT = 42, RD = 192.0.2.2/11],
             [SI = 252, SFT = 41, RD = 192.0.2.1/11]

<span class="h3"><a class="selflink" id="section-8.10" href="#section-8.10">8.10</a>.  Examples Using IPv6 Addressing</span>

   This section provides several examples using IPv6 addressing.  As
   will be seen from the examples, there is nothing special or clever
   about using IPv6 addressing rather than IPv4 addressing.

   The reference network for these IPv6 examples is based on that
   described at the top of <a href="#section-8">Section 8</a> and shown in Figure 11.

   Assume we have a service function overlay network with four SFFs
   (SFF1, SFF3, SFF3, and SFF4).  The SFFs have addresses in the
   underlay network as follows:

         SFF1 2001:db8::192:0:2:1
         SFF2 2001:db8::192:0:2:2
         SFF3 2001:db8::192:0:2:3
         SFF4 2001:db8::192:0:2:4

   Each SFF provides access to some SFIs from the four service function
   types SFT=41, SFT=42, SFT=43, and SFT=44, just as before:

         SFF1 SFT=41 and SFT=42
         SFF2 SFT=41 and SFT=43
         SFF3 SFT=42 and SFT=44
         SFF4 SFT=43 and SFT=44

   The service function network also contains a controller with address
   2001:db8::198:51:100:1.

   This example service function overlay network is shown in Figure 15.


          ------------------------
         |       Controller       |
         | 2001:db8::198:51:100:1 |
          ------------------------
                       ------     ------        ------     ------
                      | SFI  |   | SFI  |      | SFI  |   | SFI  |
                      |SFT=41|   |SFT=42|      |SFT=41|   |SFT=43|
                       ------     ------        ------     ------
                            \     /                  \     /
                       -------------------     -------------------
                      |       SFF1        |   |       SFF2        |
                      |2001:db8::192:0:2:1|   |2001:db8::192:0:2:2|
                       -------------------     -------------------
                  ----------
      Packet --&gt; |          |                                    --&gt;
      Flows  --&gt; |Classifier|                                    --&gt;Dest
                 |          |                                    --&gt;
                  ----------
                      -------------------      -------------------
                     |       SFF3        |    |       SFF4        |
                     |2001:db8::192:0:2:3|    |2001:db8::192:0:2:4|
                      -------------------      -------------------
                            /     \                  /     \
                       ------     ------        ------     ------
                      | SFI  |   | SFI  |      | SFI  |   | SFI  |
                      |SFT=42|   |SFT=44|      |SFT=43|   |SFT=44|
                       ------     ------        ------     ------

            Figure 15: Example Service Function Overlay Network

   The SFFs advertise routes to the SFIs they support.  These
   advertisements contain RDs that are set according to the network
   operator&#x27;s configuration model.  Note that in an IPv6 network, the RD
   is not large enough to contain the full IPv6 address, as only six
   octets are available.  So, in all of these IPv6 examples, we use RDs
   of Type 1 such that the available six octets are partitioned as four
   octets for an IPv4 address of the advertising SFF, and two octets
   that are a local index of the SFI.  Furthermore, we have chosen an
   IPv6 addressing scheme so that the low-order four octets of the IPv6
   address match an IPv4 address of the advertising node.  This scheme
   is chosen purely for convenience of documentation, and an operator is
   totally free to use any other scheme so long as it conforms to the
   definitions of SFIR and SFPR in Sections <a href="#section-3.1">3.1</a> and <a href="#section-3.2">3.2</a>.

   Observant readers will notice that this makes the BGP advertisements
   shown in these examples exactly the same as in the previous examples.
   All that is different is that the advertising SFFs and controller
   have IPv6 addresses.

   Thus, we see the following SFIRs advertised.

   The SFFs advertise routes to the SFIs they support.  So we see the
   following SFIRs:

         RD = 192.0.2.1/1, SFT = 41
         RD = 192.0.2.1/2, SFT = 42
         RD = 192.0.2.2/1, SFT = 41
         RD = 192.0.2.2/2, SFT = 43
         RD = 192.0.2.3/7, SFT = 42
         RD = 192.0.2.3/8, SFT = 44
         RD = 192.0.2.4/5, SFT = 43
         RD = 192.0.2.4/6, SFT = 44

   Note that the addressing used for communicating between SFFs is taken
   from the tunnel encapsulation attribute of the SFIR and not from the
   SFIR-RD.

<span class="h4"><a class="selflink" id="section-8.10.1" href="#section-8.10.1">8.10.1</a>.  Example Explicit SFP with No Choices</span>

   Consider the following SFPR similar to that in <a href="#section-8.1">Section 8.1</a>.

         SFP1:  RD = 198.51.100.1/101, SPI = 15,
                [SI = 255, SFT = 41, RD = 192.0.2.1/1],
                [SI = 250, SFT = 43, RD = 192.0.2.2/2]

   The SFP consists of an SF of Type 41 located at SFF1, followed by an
   SF of Type 43 located at SFF2.  This path is fully explicit, and each
   SFF is offered no choice in forwarding a packet along the path.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (15).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 has no flexibility in the
   choice of SFF to support the next-hop SFI and will forward the packet
   to SFF2, which will send the packets to the SFI that supports SFT 43
   before forwarding the packets to their destinations.

<span class="h4"><a class="selflink" id="section-8.10.2" href="#section-8.10.2">8.10.2</a>.  Example SFP with Choice of SFIs</span>

         SFP2:  RD = 198.51.100.1/102, SPI = 16,
                [SI = 255, SFT = 41, RD = 192.0.2.1/1],
                [SI = 250, SFT = 43, {RD = 192.0.2.2/2,
                                      RD = 192.0.2.4/5 } ]

   In this example, like that in <a href="#section-8.2">Section 8.2</a>, the path also consists of
   an SF of Type 41 located at SFF1, and this is followed by an SF of
   Type 43; but in this case, the SI = 250 contains a choice between the
   SFI located at SFF2 and the SFI located at SFF4.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (16).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 now has a choice of next-hop
   SFFs to execute the next hop in the path.  It can either forward
   packets to SFF2 or SFF4 to execute a function of Type 43.  It uses
   its local load-balancing algorithm to make this choice.  The chosen
   SFF will send the packets to the SFI that supports SFT 43 before
   forwarding the packets to their destinations.

<span class="h4"><a class="selflink" id="section-8.10.3" href="#section-8.10.3">8.10.3</a>.  Example SFP with Open Choice of SFIs</span>

         SFP3:  RD = 198.51.100.1/103, SPI = 17,
                [SI = 255, SFT = 41, RD = 192.0.2.1/1],
                [SI = 250, SFT = 44, RD = 0]

   In this example, like that in <a href="#section-8.3">Section 8.3</a>, the path also consists of
   an SF of Type 41 located at SFF1, and this is followed by an SI with
   an RD of zero and SF of Type 44.  This means that a choice can be
   made between any SFF that supports an SFI of Type 44.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (17).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 now has a free choice of
   next-hop SFFs to execute the next hop in the path, selecting between
   all SFFs that support SFs of Type 44.  Looking at the SFIRs it has
   received, SFF1 knows that SF Type 44 is supported by SFF3 and SFF4.
   SFF1 uses its local load-balancing algorithm to make this choice.
   The chosen SFF will send the packets to the SFI that supports SFT 44
   before forwarding the packets to their destinations.

<span class="h4"><a class="selflink" id="section-8.10.4" href="#section-8.10.4">8.10.4</a>.  Example SFP with Choice of SFTs</span>

         SFP4:  RD = 198.51.100.1/104, SPI = 18,
                [SI = 255, SFT = 41, RD = 192.0.2.1/1],
                [SI = 250, {SFT = 43, RD = 192.0.2.2/2,
                            SFT = 44, RD = 192.0.2.3/8 } ]

   This example, similar to that in <a href="#section-8.4">Section 8.4</a>, provides a choice of SF
   type in the second hop in the path.  The SI of 250 indicates a choice
   between SF Type 43 located through SF2 and SF Type 44 located at SF3.

   SFF1 will receive packets on the path from the classifier and will
   identify the path from the SPI (18).  The initial SI will be 255, and
   so SFF1 will deliver the packets to the SFI for SFT 41.

   When the packets are returned to SFF1 by the SFI, the SI will be
   decreased to 250 for the next hop.  SFF1 now has a free choice of
   next-hop SFFs to execute the next hop in the path, selecting between
   all SFFs that support an SF of Type 43 and SFF3, which supports an SF
   of Type 44.  These may be completely different functions that are to
   be executed dependent on specific conditions, or they may be similar
   functions identified with different type identifiers (such as
   firewalls from different vendors).  SFF1 uses its local policy and
   load-balancing algorithm to make this choice, and it may use
   additional information passed back from the local SFI to help inform
   its selection.  The chosen SFF will send the packets to the SFI that
   supports the chosen SFT before forwarding the packets to their
   destinations.

<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>.  Security Considerations</span>

   The mechanisms in this document use BGP for the control plane.
   Hence, techniques such as those discussed in [<a href="/doc/html/rfc5925" title="&quot;The TCP Authentication Option&quot;">RFC5925</a>] can be used to
   help authenticate BGP sessions and, thus, the messages between BGP
   peers, making it harder to spoof updates (which could be used to
   install bogus SFPs or advertise false SIs) or withdrawals.

   Further discussion of security considerations for BGP may be found in
   the BGP specification itself [<a href="/doc/html/rfc4271" title="&quot;A Border Gateway Protocol 4 (BGP-4)&quot;">RFC4271</a>] and the security analysis for
   BGP [<a href="/doc/html/rfc4272" title="&quot;BGP Security Vulnerabilities Analysis&quot;">RFC4272</a>].  [<a href="/doc/html/rfc5925" title="&quot;The TCP Authentication Option&quot;">RFC5925</a>] contains a discussion of the
   inappropriateness of the TCP MD5 signature option for protecting BGP
   sessions.  [<a href="/doc/html/rfc6952" title="&quot;Analysis of BGP, LDP, PCEP, and MSDP Issues According to the Keying and Authentication for Routing Protocols (KARP) Design Guide&quot;">RFC6952</a>] includes an analysis of BGP keying and
   authentication issues.

   Additionally, this document depends on other documents that specify
   BGP Multiprotocol Extensions and the documents that define the
   attributes that are carried by BGP UPDATEs of the SFC AFI/SAFI.
   [<a href="/doc/html/rfc4760" title="&quot;Multiprotocol Extensions for BGP-4&quot;">RFC4760</a>] observes that the use of AFI/SAFI does not change the
   underlying security issues inherent in the existing BGP.  Relevant
   additional security measures are considered in [<a href="/doc/html/rfc9012" title="&quot;The BGP Tunnel Encapsulation Attribute&quot;">RFC9012</a>].

   This document does not fundamentally change the security behavior of
   BGP deployments, which depend considerably on the network operator&#x27;s
   perception of risk in their network.  It may be observed that the
   application of the mechanisms described in this document is scoped to
   a single domain, as implied by [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>] and noted in <a href="#section-2.1">Section 2.1</a> of
   this document.  Applicability of BGP within a single domain may
   enable a network operator to make easier and more consistent
   decisions about what security measures to apply, and the domain
   boundary, which BGP enforces by definition, provides a safeguard that
   prevents leakage of SFC programming in either direction at the
   boundary.

   Service function chaining provides a significant attack opportunity;
   packets can be diverted from their normal paths through the network,
   packets can be made to execute unexpected functions, and the
   functions that are instantiated in software can be subverted.
   However, this specification does not change the existence of service
   function chaining, and security issues specific to service function
   chaining are covered in [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>] and [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>].

   This document defines a control plane for service function chaining.
   Clearly, this provides an attack vector for a service function
   chaining system, as an attack on this control plane could be used to
   make the system misbehave.  Thus, the security of the BGP system is
   critically important to the security of the whole service function
   chaining system.  The control plane mechanisms are very similar to
   those used for BGP/MPLS IP VPNs as described in [<a href="/doc/html/rfc4364" title="&quot;BGP/MPLS IP Virtual Private Networks (VPNs)&quot;">RFC4364</a>], and so the
   security considerations in that document (<a href="#section-13">Section 13</a>) provide good
   guidance for securing service function chaining systems reliant on
   this specification.  Of particular relevance is the need to securely
   distinguish between messages intended for the control of different
   SFC overlays, which is similar to the need to distinguish between
   different VPNs.  <a href="/doc/html/rfc7432#section-19">Section&nbsp;19 of [RFC7432]</a> also provides useful
   guidance on the use of BGP in a similar environment.

   Note that a component of a service function chaining system that uses
   the procedures described in this document also requires
   communications between a controller and the service function chaining
   network elements (specifically the SFFs and classifiers).  This
   communication covers instructing the classifiers using BGP mechanisms
   (see <a href="#section-7.4">Section 7.4</a>); therefore, the use of BGP security is strongly
   recommended.  But it also covers other mechanisms for programming the
   classifier and instructing the SFFs and SFs (for example, to bind SFs
   to an SFF, and to cause the establishment of tunnels between SFFs).
   This document does not cover these latter mechanisms, and so their
   security is out of scope, but it should be noted that these
   communications provide an attack vector on the service function
   chaining system, and so attention must be paid to ensuring that they
   are secure.

   There is an intrinsic assumption in service function chaining systems
   that nodes that announce support for specific SFs actually offer
   those functions and that SFs are not, themselves, attacked or
   subverted.  This is particularly important when the SFs are
   implemented as software that can be updated.  Protection against this
   sort of concern forms part of the security of any service function
   chaining system and so is outside the scope of the control plane
   mechanisms described in this document.

   Similarly, there is a vulnerability if a rogue or subverted
   controller announces SFPs, especially if that controller &quot;takes over&quot;
   an existing SFP and changes its contents.  This corresponds to a
   rogue BGP speaker entering a routing system, or even a Route
   Reflector becoming subverted.  Protection mechanisms, as above,
   include securing BGP sessions and protecting software loads on the
   controllers.

   In an environment where there is concern that rogue controllers might
   be introduced to the network and inject false SFPRs or take over and
   change existing SFPRs, it is RECOMMENDED that each SFF and classifier
   be configured with the identities of authorized controllers.  Thus,
   the announcement of an SFPR by any other BGP peer would be rejected.

   Lastly, note that <a href="#section-3.2.2">Section 3.2.2</a> makes two operational suggestions
   that have implications for the stability and security of the
   mechanisms described in this document:

   *  That modifications to active SFPs not be made.

   *  That SPIs not be immediately reused.

<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>.  IANA Considerations</span>

<span class="h3"><a class="selflink" id="section-10.1" href="#section-10.1">10.1</a>.  New BGP AF/SAFI</span>

   IANA maintains the &quot;Address Family Numbers&quot; registry.  IANA has
   assigned a new Address Family Number from the &quot;Standards Action&quot;
   range called &quot;BGP SFC&quot; (31), with this document as a reference.

   IANA maintains the &quot;Subsequent Address Family Identifiers (SAFI)
   Parameters&quot; registry.  IANA has assigned a new SAFI value from the
   &quot;Standards Action&quot; range called &quot;BGP SFC&quot; (9), with this document as
   a reference.

<span class="h3"><a class="selflink" id="section-10.2" href="#section-10.2">10.2</a>.  &quot;SFP attribute&quot; BGP Path Attribute</span>

   IANA maintains a registry of &quot;Border Gateway Protocol (BGP)
   Parameters&quot; with a subregistry of &quot;BGP Path Attributes&quot;.  IANA has
   assigned a new Path attribute called &quot;SFP attribute&quot; with a value of
   37 and with this document as a reference.

<span class="h3"><a class="selflink" id="section-10.3" href="#section-10.3">10.3</a>.  &quot;SFP Attribute TLVs&quot; Registry</span>

   IANA maintains a registry of &quot;Border Gateway Protocol (BGP)
   Parameters&quot;.  IANA has created a new subregistry called the &quot;SFP
   Attribute TLVs&quot; registry.

   Valid values are in the range 0 to 65535.

   *  Values 0 and 65535 are marked &quot;Reserved&quot;.

   *  Values 1 through 65534 are to be assigned according to the &quot;First
      Come First Served&quot; policy [<a href="/doc/html/rfc8126" title="">RFC8126</a>].

   This document is a reference for this registry.

   The registry tracks:

   *  Type

   *  Name

   *  Reference

   *  Registration Date

   The registry is initially populated as follows:

    +======+=========================+===========+===================+
    | Type | Name                    | Reference | Registration Date |
    +======+=========================+===========+===================+
    | 1    | Association TLV         | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02        |
    +------+-------------------------+-----------+-------------------+
    | 2    | Hop TLV                 | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02        |
    +------+-------------------------+-----------+-------------------+
    | 3    | SFT TLV                 | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02        |
    +------+-------------------------+-----------+-------------------+
    | 4    | MPLS Swapping/Stacking  | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02        |
    +------+-------------------------+-----------+-------------------+
    | 5    | SFP Traversal With MPLS | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02        |
    +------+-------------------------+-----------+-------------------+

         Table 1: SFP Attribute TLVs Subregistry Initial Contents

<span class="h3"><a class="selflink" id="section-10.4" href="#section-10.4">10.4</a>.  &quot;SFP Association Type&quot; Registry</span>

   IANA maintains a registry of &quot;Border Gateway Protocol (BGP)
   Parameters&quot;.  IANA has created a new subregistry called the &quot;SFP
   Association Type&quot; registry.

   Valid values are in the range 0 to 65535.

   *  Values 0 and 65535 are marked &quot;Reserved&quot;.

   *  Values 1 through 65534 are assigned according to the &quot;First Come
      First Served&quot; policy [<a href="/doc/html/rfc8126" title="">RFC8126</a>].

   This document is given as a reference for this registry.

   The new registry tracks:

   *  Association Type

   *  Name

   *  Reference

   *  Registration Date

   The registry should initially be populated as follows:

     +==================+===================+===========+============+
     | Association Type | Name              | Reference | Date       |
     +==================+===================+===========+============+
     | 1                | Bidirectional SFP | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02 |
     +------------------+-------------------+-----------+------------+

         Table 2: SFP Association Type Subregistry Initial Contents

<span class="h3"><a class="selflink" id="section-10.5" href="#section-10.5">10.5</a>.  &quot;Service Function Chaining Service Function Types&quot; Registry</span>

   IANA has created a new top-level registry called &quot;Service Function
   Chaining Service Function Types&quot;.

   Valid values are in the range 0 to 65535.

   *  Values 0 and 65535 are marked &quot;Reserved&quot;.

   *  Values 1 through 31 are to be assigned by &quot;Standards Action&quot;
      [<a href="/doc/html/rfc8126" title="">RFC8126</a>] and are referred to as the &quot;special-purpose SFT values&quot;.

   *  Values 32 through 64495 are to be assigned according to the &quot;First
      Come First Served&quot; policy [<a href="/doc/html/rfc8126" title="">RFC8126</a>].

   *  Values 64496 through 65534 are for Private Use and are not to be
      recorded by IANA.

   This document is given as a reference for this registry.

   The registry tracks:

   *  Value

   *  Name

   *  Reference

   *  Registration Date

   The registry is initially populated as follows.

      +=============+===================+=============+============+
      | Value       | Name              | Reference   | Date       |
      +=============+===================+=============+============+
      | 0           | Reserved          | <a href="/doc/html/rfc9015">RFC 9015</a>    | 2020-09-02 |
      +-------------+-------------------+-------------+------------+
      | 1           | Change Sequence   | <a href="/doc/html/rfc9015">RFC 9015</a>    | 2020-09-02 |
      +-------------+-------------------+-------------+------------+
      | 2-31        | Unassigned        |             |            |
      +-------------+-------------------+-------------+------------+
      | 32          | Classifier        | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="#ref-BGP-LS-SR">BGP-LS-SR</a>] |            |
      +-------------+-------------------+-------------+------------+
      | 33          | Firewall          | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="#ref-BGP-LS-SR">BGP-LS-SR</a>] |            |
      +-------------+-------------------+-------------+------------+
      | 34          | Load balancer     | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="#ref-BGP-LS-SR">BGP-LS-SR</a>] |            |
      +-------------+-------------------+-------------+------------+
      | 35          | Deep packet       | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             | inspection engine | [<a href="#ref-BGP-LS-SR">BGP-LS-SR</a>] |            |
      +-------------+-------------------+-------------+------------+
      | 36          | Penalty box       | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 37          | WAN accelerator   | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>],  |            |
      |             |                   | [<a href="/doc/html/rfc8300" title="&quot;Network Service Header (NSH)&quot;">RFC8300</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 38          | Application       | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             | accelerator       | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 39          | TCP optimizer     | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 40          | Network Address   | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             | Translator        | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 41          | NAT44             | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>],  |            |
      |             |                   | [<a href="/doc/html/rfc3022" title="&quot;Traditional IP Network Address Translator (Traditional NAT)&quot;">RFC3022</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 42          | NAT64             | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>],  |            |
      |             |                   | [<a href="/doc/html/rfc6146" title="&quot;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers&quot;">RFC6146</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 43          | NPTv6             | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>],  |            |
      |             |                   | [<a href="/doc/html/rfc6296" title="&quot;IPv6-to-IPv6 Network Prefix Translation&quot;">RFC6296</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 44          | Lawful intercept  | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 45          | HOST_ID injection | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 46          | HTTP header       | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             | enrichment        | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 47          | Caching engine    | <a href="/doc/html/rfc9015">RFC 9015</a>,   | 2020-09-02 |
      |             |                   | [<a href="/doc/html/rfc7665" title="&quot;Service Function Chaining (SFC) Architecture&quot;">RFC7665</a>]   |            |
      +-------------+-------------------+-------------+------------+
      | 48-64495    | Unassigned        |             |            |
      +-------------+-------------------+-------------+------------+
      | 64496-65534 | Reserved for      |             |            |
      |             | Private Use       |             |            |
      +-------------+-------------------+-------------+------------+
      | 65535       | Reserved, not to  | <a href="/doc/html/rfc9015">RFC 9015</a>    | 2020-09-02 |
      |             | be allocated      |             |            |
      +-------------+-------------------+-------------+------------+

        Table 3: Service Function Chaining Service Function Types
                        Registry Initial Contents

<span class="h3"><a class="selflink" id="section-10.6" href="#section-10.6">10.6</a>.  Flow Specification for SFC Classifiers</span>

   IANA maintains a registry of &quot;Border Gateway Protocol (BGP) Extended
   Communities&quot; with a subregistry of &quot;Generic Transitive Experimental
   Use Extended Community Sub-Types&quot;.  IANA has assigned a new subtype
   as follows:

      &quot;Flow Specification for SFC Classifiers&quot; with a value of 0x0d and
      with this document as the reference.

<span class="h3"><a class="selflink" id="section-10.7" href="#section-10.7">10.7</a>.  New BGP Transitive Extended Community Type</span>

   IANA maintains a registry of &quot;Border Gateway Protocol (BGP) Extended
   Communities&quot; with a subregistry of &quot;BGP Transitive Extended Community
   Types&quot;.  IANA has assigned a new type as follows:

      SFC (Sub-Types are defined in the &quot;SFC Extended Community Sub-
      Types&quot; registry) with a value of 0x0b and with this document as
      the reference.

<span class="h3"><a class="selflink" id="section-10.8" href="#section-10.8">10.8</a>.  &quot;SFC Extended Community Sub-Types&quot; Registry</span>

   IANA maintains a registry of &quot;Border Gateway Protocol (BGP)
   Parameters&quot;.  IANA has created a new subregistry called the &quot;SFC
   Extended Community Sub-Types&quot; registry.

   IANA has included the following note:

      |  This registry contains values of the second octet (the &quot;Sub-
      |  Type&quot; field) of an extended community when the value of the
      |  first octet (the &quot;Type&quot; field) is set to 0x0b.

   The allocation policy for this registry is First Come First Served.

   Valid values are 0 to 255.  The value 0 is reserved and should not be
   allocated.

   IANA has populated this registry with the following entries:

     +==========+==========================+===========+============+
     | Sub-Type | Name                     | Reference | Date       |
     | Value    |                          |           |            |
     +==========+==========================+===========+============+
     | 0        | Reserved                 | <a href="/doc/html/rfc9015">RFC 9015</a>  |            |
     +----------+--------------------------+-----------+------------+
     | 1        | SFIR pool identifier     | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02 |
     +----------+--------------------------+-----------+------------+
     | 2        | MPLS Label Stack Mixed   | <a href="/doc/html/rfc9015">RFC 9015</a>  | 2020-09-02 |
     |          | Swapping/Stacking Labels |           |            |
     +----------+--------------------------+-----------+------------+
     | 3-255    | Unassigned               |           |            |
     +----------+--------------------------+-----------+------------+

          Table 4: SFC Extended Community Sub-Types Subregistry
                             Initial Contents

<span class="h3"><a class="selflink" id="section-10.9" href="#section-10.9">10.9</a>.  New SPI/SI Representation Sub-TLV</span>

   IANA has assigned a codepoint from the &quot;BGP Tunnel Encapsulation
   Attribute Sub-TLVs&quot; registry for the &quot;SPI/SI Representation Sub-TLV&quot;
   with a value of 16 and with this document as the reference.

<span class="h3"><a class="selflink" id="section-10.10" href="#section-10.10">10.10</a>.  &quot;SFC SPI/SI Representation Flags&quot; Registry</span>

   IANA maintains the &quot;BGP Tunnel Encapsulation Attribute Sub-TLVs&quot;
   registry and has created an associated registry called the &quot;SFC SPI/
   SI Representation Flags&quot; registry.

   Bits are to be assigned by Standards Action.  The field is 16 bits
   long, and bits are counted from the most significant bit as bit zero.

   IANA has populated the registry as follows:

                  +=======+=================+===========+
                  | Value | Name            | Reference |
                  +=======+=================+===========+
                  | 0     | NSH data plane  | <a href="/doc/html/rfc9015">RFC 9015</a>  |
                  +-------+-----------------+-----------+
                  | 1     | MPLS data plane | <a href="/doc/html/rfc9015">RFC 9015</a>  |
                  +-------+-----------------+-----------+

                     Table 5: SFC SPI/SI Representation
                      Flags Registry Initial Contents

<span class="h2"><a class="selflink" id="section-11" href="#section-11">11</a>.  References</span>

<span class="h3"><a class="selflink" id="section-11.1" href="#section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC4271">RFC4271</a>]  Rekhter, Y., Ed., Li, T., Ed., and S. Hares, Ed., &quot;A
              Border Gateway Protocol 4 (BGP-4)&quot;, <a href="/doc/html/rfc4271">RFC 4271</a>,
              DOI 10.17487/RFC4271, January 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4271">https://www.rfc-editor.org/info/rfc4271</a>&gt;.

   [<a id="ref-RFC4360">RFC4360</a>]  Sangli, S., Tappan, D., and Y. Rekhter, &quot;BGP Extended
              Communities Attribute&quot;, <a href="/doc/html/rfc4360">RFC 4360</a>, DOI 10.17487/RFC4360,
              February 2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4360">https://www.rfc-editor.org/info/rfc4360</a>&gt;.

   [<a id="ref-RFC4364">RFC4364</a>]  Rosen, E. and Y. Rekhter, &quot;BGP/MPLS IP Virtual Private
              Networks (VPNs)&quot;, <a href="/doc/html/rfc4364">RFC 4364</a>, DOI 10.17487/RFC4364, February
              2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4364">https://www.rfc-editor.org/info/rfc4364</a>&gt;.

   [<a id="ref-RFC4760">RFC4760</a>]  Bates, T., Chandra, R., Katz, D., and Y. Rekhter,
              &quot;Multiprotocol Extensions for BGP-4&quot;, <a href="/doc/html/rfc4760">RFC 4760</a>,
              DOI 10.17487/RFC4760, January 2007,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4760">https://www.rfc-editor.org/info/rfc4760</a>&gt;.

   [<a id="ref-RFC7432">RFC7432</a>]  Sajassi, A., Ed., Aggarwal, R., Bitar, N., Isaac, A.,
              Uttaro, J., Drake, J., and W. Henderickx, &quot;BGP MPLS-Based
              Ethernet VPN&quot;, <a href="/doc/html/rfc7432">RFC 7432</a>, DOI 10.17487/RFC7432, February
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7432">https://www.rfc-editor.org/info/rfc7432</a>&gt;.

   [<a id="ref-RFC7606">RFC7606</a>]  Chen, E., Ed., Scudder, J., Ed., Mohapatra, P., and K.
              Patel, &quot;Revised Error Handling for BGP UPDATE Messages&quot;,
              <a href="/doc/html/rfc7606">RFC 7606</a>, DOI 10.17487/RFC7606, August 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7606">https://www.rfc-editor.org/info/rfc7606</a>&gt;.

   [<a id="ref-RFC7665">RFC7665</a>]  Halpern, J., Ed. and C. Pignataro, Ed., &quot;Service Function
              Chaining (SFC) Architecture&quot;, <a href="/doc/html/rfc7665">RFC 7665</a>,
              DOI 10.17487/RFC7665, October 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7665">https://www.rfc-editor.org/info/rfc7665</a>&gt;.

   [<a id="ref-RFC8126">RFC8126</a>]  Cotton, M., Leiba, B., and T. Narten, &quot;Guidelines for
              Writing an IANA Considerations Section in RFCs&quot;, <a href="/doc/html/bcp26">BCP 26</a>,
              <a href="/doc/html/rfc8126">RFC 8126</a>, DOI 10.17487/RFC8126, June 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8126">https://www.rfc-editor.org/info/rfc8126</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., &quot;Ambiguity of Uppercase vs Lowercase in <a href="/doc/html/rfc2119">RFC</a>
              <a href="/doc/html/rfc2119">2119</a> Key Words&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-RFC8300">RFC8300</a>]  Quinn, P., Ed., Elzur, U., Ed., and C. Pignataro, Ed.,
              &quot;Network Service Header (NSH)&quot;, <a href="/doc/html/rfc8300">RFC 8300</a>,
              DOI 10.17487/RFC8300, January 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8300">https://www.rfc-editor.org/info/rfc8300</a>&gt;.

   [<a id="ref-RFC8595">RFC8595</a>]  Farrel, A., Bryant, S., and J. Drake, &quot;An MPLS-Based
              Forwarding Plane for Service Function Chaining&quot;, <a href="/doc/html/rfc8595">RFC 8595</a>,
              DOI 10.17487/RFC8595, June 2019,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8595">https://www.rfc-editor.org/info/rfc8595</a>&gt;.

   [<a id="ref-RFC8596">RFC8596</a>]  Malis, A., Bryant, S., Halpern, J., and W. Henderickx,
              &quot;MPLS Transport Encapsulation for the Service Function
              Chaining (SFC) Network Service Header (NSH)&quot;, <a href="/doc/html/rfc8596">RFC 8596</a>,
              DOI 10.17487/RFC8596, June 2019,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8596">https://www.rfc-editor.org/info/rfc8596</a>&gt;.

   [<a id="ref-RFC8955">RFC8955</a>]  Loibl, C., Hares, S., Raszuk, R., McPherson, D., and M.
              Bacher, &quot;Dissemination of Flow Specification Rules&quot;,
              <a href="/doc/html/rfc8955">RFC 8955</a>, DOI 10.17487/RFC8955, December 2020,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8955">https://www.rfc-editor.org/info/rfc8955</a>&gt;.

   [<a id="ref-RFC9012">RFC9012</a>]  Patel, K., Van de Velde, G., Sangli, S., and J. Scudder,
              &quot;The BGP Tunnel Encapsulation Attribute&quot;, <a href="/doc/html/rfc9012">RFC 9012</a>,
              DOI 10.17487/RFC9012, April 2021,
              &lt;<a href="https://www.rfc-editor.org/info/rfc9012">https://www.rfc-editor.org/info/rfc9012</a>&gt;.

<span class="h3"><a class="selflink" id="section-11.2" href="#section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-BGP-LS-SR">BGP-LS-SR</a>]
              Dawra, G., Filsfils, C., Talaulikar, K., Clad, F.,
              Bernier, D., Uttaro, J., Decraene, B., Elmalky, H., Xu,
              X., Guichard, J., and C. Li, &quot;BGP-LS Advertisement of
              Segment Routing Service Segments&quot;, Work in Progress,
              Internet-Draft, <a href="/doc/html/draft-dawra-idr-bgp-ls-sr-service-segments-05">draft-dawra-idr-bgp-ls-sr-service-</a>
              <a href="/doc/html/draft-dawra-idr-bgp-ls-sr-service-segments-05">segments-05</a>, 15 February 2021,
              &lt;<a href="https://tools.ietf.org/html/draft-dawra-idr-bgp-ls-sr-service-segments-05">https://tools.ietf.org/html/draft-dawra-idr-bgp-ls-sr-</a>
              <a href="https://tools.ietf.org/html/draft-dawra-idr-bgp-ls-sr-service-segments-05">service-segments-05</a>&gt;.

   [<a id="ref-RFC3022">RFC3022</a>]  Srisuresh, P. and K. Egevang, &quot;Traditional IP Network
              Address Translator (Traditional NAT)&quot;, <a href="/doc/html/rfc3022">RFC 3022</a>,
              DOI 10.17487/RFC3022, January 2001,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3022">https://www.rfc-editor.org/info/rfc3022</a>&gt;.

   [<a id="ref-RFC4272">RFC4272</a>]  Murphy, S., &quot;BGP Security Vulnerabilities Analysis&quot;,
              <a href="/doc/html/rfc4272">RFC 4272</a>, DOI 10.17487/RFC4272, January 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4272">https://www.rfc-editor.org/info/rfc4272</a>&gt;.

   [<a id="ref-RFC5925">RFC5925</a>]  Touch, J., Mankin, A., and R. Bonica, &quot;The TCP
              Authentication Option&quot;, <a href="/doc/html/rfc5925">RFC 5925</a>, DOI 10.17487/RFC5925,
              June 2010, &lt;<a href="https://www.rfc-editor.org/info/rfc5925">https://www.rfc-editor.org/info/rfc5925</a>&gt;.

   [<a id="ref-RFC6146">RFC6146</a>]  Bagnulo, M., Matthews, P., and I. van Beijnum, &quot;Stateful
              NAT64: Network Address and Protocol Translation from IPv6
              Clients to IPv4 Servers&quot;, <a href="/doc/html/rfc6146">RFC 6146</a>, DOI 10.17487/RFC6146,
              April 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6146">https://www.rfc-editor.org/info/rfc6146</a>&gt;.

   [<a id="ref-RFC6296">RFC6296</a>]  Wasserman, M. and F. Baker, &quot;IPv6-to-IPv6 Network Prefix
              Translation&quot;, <a href="/doc/html/rfc6296">RFC 6296</a>, DOI 10.17487/RFC6296, June 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6296">https://www.rfc-editor.org/info/rfc6296</a>&gt;.

   [<a id="ref-RFC6952">RFC6952</a>]  Jethanandani, M., Patel, K., and L. Zheng, &quot;Analysis of
              BGP, LDP, PCEP, and MSDP Issues According to the Keying
              and Authentication for Routing Protocols (KARP) Design
              Guide&quot;, <a href="/doc/html/rfc6952">RFC 6952</a>, DOI 10.17487/RFC6952, May 2013,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6952">https://www.rfc-editor.org/info/rfc6952</a>&gt;.

   [<a id="ref-RFC7498">RFC7498</a>]  Quinn, P., Ed. and T. Nadeau, Ed., &quot;Problem Statement for
              Service Function Chaining&quot;, <a href="/doc/html/rfc7498">RFC 7498</a>,
              DOI 10.17487/RFC7498, April 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7498">https://www.rfc-editor.org/info/rfc7498</a>&gt;.

Acknowledgements

   Thanks to Tony Przygienda, Jeff Haas, and Andy Malis for helpful
   comments, and to Joel Halpern for discussions that improved this
   document.  Yuanlong Jiang provided a useful review and caught some
   important issues.  Stephane Litkowski did an exceptionally good and
   detailed Document Shepherd review.

   Andy Malis contributed text that formed the basis of <a href="#section-7.7">Section 7.7</a>.

   Brian Carpenter and Martin Vigoureux provided useful reviews during
   IETF Last Call.  Thanks also to Sheng Jiang, Med Boucadair, Ravi
   Singh, Benjamin Kaduk, Roman Danyliw, Adam Roach, Alvaro Retana,
   Barry Leiba, and Murray Kucherawy for review comments.  Ketan
   Talaulikar provided helpful discussion of the SFT codepoint registry.
   Ron Bonica kept us honest on the difference between an RD and an RT;
   Benjamin Kaduk kept us on message about the difference between an RD
   and an Extended Community.

Contributors

   Stuart Mackie
   Juniper Networks

   Email: wsmackie@juinper.net


   Keyur Patel
   Arrcus, Inc.

   Email: keyur@arrcus.com


   Avinash Lingala
   AT&amp;T

   Email: ar977m@att.com


Authors&#x27; Addresses

   Adrian Farrel
   Old Dog Consulting

   Email: adrian@olddog.co.uk


   John Drake
   Juniper Networks

   Email: jdrake@juniper.net


   Eric Rosen
   Juniper Networks

   Email: erosen52@gmail.com


   Jim Uttaro
   AT&amp;T

   Email: ju1738@att.com


   Luay Jalil
   Verizon

   Email: luay.jalil@verizon.com
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

