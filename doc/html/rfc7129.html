<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc7129
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-gieben-auth-denial-of-existence-dns/">
  <meta name="description" content="Authenticated Denial of Existence in the DNS (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgorange"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc7129.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc7129.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7129.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc7129/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc7129/" title="Datatracker information for this document">Tracker</a>] [<a href="mailto:draft-gieben-auth-denial-of-existence-dns@ietf.org?subject=draft-gieben-auth-denial-of-existence-dns" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-gieben-auth-denial-of-existence-dns-06.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-gieben-auth-denial-of-existence-dns-06.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-gieben-auth-denial-of-existence-dns-06.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-gieben-auth-denial-of-existence-dns-06">draft-gieben-auth-denial-of-existence-dns-06</a>         Informational</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Independent Submission                                         R. Gieben
Request for Comments: 7129                                        Google
Category: Informational                                       W. Mekking
ISSN: 2070-1721                                               NLnet Labs
                                                           February 2014


              <span class="h1">Authenticated Denial of Existence in the DNS</span>

Abstract

   Authenticated denial of existence allows a resolver to validate that
   a certain domain name does not exist.  It is also used to signal that
   a domain name exists but does not have the specific resource record
   (RR) type you were asking for.  When returning a negative DNS
   Security Extensions (DNSSEC) response, a name server usually includes
   up to two NSEC records.  With NSEC version 3 (NSEC3), this amount is
   three.

   This document provides additional background commentary and some
   context for the NSEC and NSEC3 mechanisms used by DNSSEC to provide
   authenticated denial-of-existence responses.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This is a contribution to the RFC Series, independently of any other
   RFC stream.  The RFC Editor has chosen to publish this document at
   its discretion and makes no statement about its value for
   implementation or deployment.  Documents approved for publication by
   the RFC Editor are not a candidate for any level of Internet
   Standard; see <a href="/doc/html/rfc5741#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7129">http://www.rfc-editor.org/info/rfc7129</a>.













<span class="grey">Gieben &amp; Mekking              Informational                     [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="/doc/html/bcp78">BCP 78</a> and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Denial of Existence .............................................<a href="#page-4">4</a>
      <a href="#section-2.1">2.1</a>. NXDOMAIN Responses .........................................<a href="#page-4">4</a>
      <a href="#section-2.2">2.2</a>. NODATA Responses ...........................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Secure Denial of Existence ......................................<a href="#page-6">6</a>
      <a href="#section-3.1">3.1</a>. NXT ........................................................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. NSEC .......................................................<a href="#page-7">7</a>
      <a href="#section-3.3">3.3</a>. NODATA Responses ...........................................<a href="#page-9">9</a>
      <a href="#section-3.4">3.4</a>. Drawbacks of NSEC .........................................<a href="#page-10">10</a>
   <a href="#section-4">4</a>. Experimental and Deprecated Mechanisms: NO, NSEC2, and DNSNR ...<a href="#page-11">11</a>
   <a href="#section-5">5</a>. NSEC3 ..........................................................<a href="#page-12">12</a>
      <a href="#section-5.1">5.1</a>. Opt-Out ...................................................<a href="#page-14">14</a>
      <a href="#section-5.2">5.2</a>. Loading an NSEC3 Zone .....................................<a href="#page-15">15</a>
      <a href="#section-5.3">5.3</a>. Wildcards in the DNS ......................................<a href="#page-15">15</a>
      <a href="#section-5.4">5.4</a>. CNAME Records .............................................<a href="#page-18">18</a>
      <a href="#section-5.5">5.5</a>. The Closest Encloser NSEC3 Record .........................<a href="#page-19">19</a>
      <a href="#section-5.6">5.6</a>. Three to Tango ............................................<a href="#page-24">24</a>
   <a href="#section-6">6</a>. Security Considerations ........................................<a href="#page-25">25</a>
   <a href="#section-7">7</a>. Acknowledgments ................................................<a href="#page-25">25</a>
   <a href="#section-8">8</a>. References .....................................................<a href="#page-26">26</a>
      <a href="#section-8.1">8.1</a>. Normative References ......................................<a href="#page-26">26</a>
      <a href="#section-8.2">8.2</a>. Informative References ....................................<a href="#page-26">26</a>
   <a href="#appendix-A">Appendix A</a>. Online Signing: Minimally Covering NSEC Records .......<a href="#page-28">28</a>
   <a href="#appendix-B">Appendix B</a>. Online Signing: NSEC3 White Lies ......................<a href="#page-29">29</a>
   <a href="#appendix-C">Appendix C</a>. List of Hashed Owner Names ............................<a href="#page-29">29</a>












<span class="grey">Gieben &amp; Mekking              Informational                     [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.  Introduction</span>

   DNSSEC can be somewhat of a complicated matter, and there are certain
   areas of the specification that are more difficult to comprehend than
   others.  One such area is &quot;authenticated denial of existence&quot;.

   Denial of existence is a mechanism that informs a resolver that a
   certain domain name does not exist.  It is also used to signal that a
   domain name exists but does not have the specific RR type you were
   asking for.

   The first is referred to as a nonexistent domain (NXDOMAIN)
   (<a href="/doc/html/rfc2308#section-2.1">[RFC2308], Section&nbsp;2.1</a>) and the latter as a NODATA (<a href="/doc/html/rfc2308#section-2.2">[RFC2308],
   Section&nbsp;2.2</a>) response.  Both are also known as negative responses.

   Authenticated denial of existence uses cryptography to sign the
   negative response.  However, if there is no answer, what is it that
   needs to be signed?  To further complicate this matter, there is the
   desire to pre-generate negative responses that are applicable for all
   queries for nonexistent names in the signed zone.  See <a href="#section-3">Section 3</a> for
   the details.

   In this document, we will explain how authenticated denial of
   existence works.  We begin by explaining the current technique in the
   DNS and work our way up to DNSSEC.  We explain the first steps taken
   in DNSSEC and describe how NSEC and NSEC3 work.  The NXT, NO, NSEC2,
   and DNSNR records also briefly make their appearance, as they have
   paved the way for NSEC and NSEC3.

   To complete the picture, we also need to explain DNS wildcards as
   these complicate matters, especially when combined with CNAME
   records.

   Note: In this document, domain names in zone file examples will have
   a trailing dot, but in the running text they will not.  This text is
   written for people who have a fair understanding of DNSSEC.  The
   following RFCs are not required reading, but they help in
   understanding the problem space.
   o  [<a href="/doc/html/rfc5155" title="&quot;DNS Security (DNSSEC) Hashed Authenticated Denial of Existence&quot;">RFC5155</a>] -- DNS Security (DNSSEC) Hashed Authenticated Denial of
      Existence;

   o  [<a href="/doc/html/rfc4592" title="&quot;The Role of Wildcards in the Domain Name System&quot;">RFC4592</a>] -- The Role of Wildcards in the Domain Name System.

   And, these provide some general DNSSEC information.

   o  [<a href="/doc/html/rfc4033" title="&quot;DNS Security Introduction and Requirements&quot;">RFC4033</a>], [<a href="/doc/html/rfc4034" title="&quot;Resource Records for the DNS Security Extensions&quot;">RFC4034</a>], and [<a href="/doc/html/rfc4035" title="&quot;Protocol Modifications for the DNS Security Extensions&quot;">RFC4035</a>] -- DNSSEC specifications;





<span class="grey">Gieben &amp; Mekking              Informational                     [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   o  [<a href="/doc/html/rfc4956" title="&quot;DNS Security (DNSSEC) Opt-In&quot;">RFC4956</a>] -- DNS Security (DNSSEC) Opt-In.  This RFC has an
      Experimental status but is a good read.

   These three documents give some background information on the NSEC3
   development.

   o  The NO record [<a href="#ref-DNSEXT" title="&quot;Authenticating denial of existence in DNS with minimum disclosure&quot;">DNSEXT</a>];

   o  The NSEC2 record [<a href="#ref-DNSEXT-NSEC2">DNSEXT-NSEC2</a>];

   o  The DNSNR record [<a href="#ref-DNSNR-RR" title="&quot;DNSSEC Non-Repudiation Resource Record&quot;">DNSNR-RR</a>].

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.  Denial of Existence</span>

   We start with the basics and take a look at NXDOMAIN handling in the
   DNS.  To make it more visible, we are going to use a small DNS zone
   with three names (&quot;example.org&quot;, &quot;a.example.org&quot;, and
   &quot;d.example.org&quot;) and four types (SOA, NS, A, and TXT).  For brevity,
   the class is not shown (defaults to IN) and the SOA record is
   shortened, resulting in the following zone file:

   example.org.        SOA ( ... )
   example.org.        NS  a.example.org.
   a.example.org.      A 192.0.2.1
                       TXT &quot;a record&quot;
   d.example.org.      A 192.0.2.1
                       TXT &quot;d record&quot;

   Figure 1: The Unsigned &quot;example.org&quot; Zone

<span class="h3"><a class="selflink" id="section-2.1" href="#section-2.1">2.1</a>.  NXDOMAIN Responses</span>

   If a resolver asks the name server serving this zone for the TXT type
   belonging to &quot;a.example.org&quot;, it sends the following question:
   &quot;a.example.org TXT&quot;.

   The name server looks in its zone data and generates an answer.  In
   this case, a positive one: &quot;Yes, it exists and this is the data&quot;,
   resulting in this reply:

   ;; status: NOERROR, id: 28203

   ;; ANSWER SECTION:
   a.example.org.      TXT &quot;a record&quot;

   ;; AUTHORITY SECTION:
   example.org.        NS a.example.org.




<span class="grey">Gieben &amp; Mekking              Informational                     [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   The &quot;status: NOERROR&quot; signals that everything is OK, and the &quot;id&quot; is
   an integer used to match questions and answers.  In the ANSWER
   section, we find our answer.  The AUTHORITY section holds the names
   of the name servers that have information concerning the
   &quot;example.org&quot; zone.  Note that including this information is
   optional.

   If a resolver asks for &quot;b.example.org TXT&quot;, it gets an answer that
   this name does not exist:

   ;; status: NXDOMAIN, id: 7042

   ;; AUTHORITY SECTION:
   example.org.        SOA ( ... )

   In this case, we do not get an ANSWER section, and the status is set
   to NXDOMAIN.  From this, the resolver concludes that &quot;b.example.org&quot;
   does not exist.  The AUTHORITY section holds the SOA record of
   &quot;example.org&quot; that the resolver can use to cache the negative
   response.

<span class="h3"><a class="selflink" id="section-2.2" href="#section-2.2">2.2</a>.  NODATA Responses</span>

   It is important to realize that NXDOMAIN is not the only type of
   does-not-exist response.  A name may exist, but the type you are
   asking for may not.  This occurrence of nonexistence is called a
   NODATA response.  Let us ask our name server for &quot;a.example.org AAAA&quot;
   and look at the answer:

   ;; status: NOERROR, id: 7944

   ;; AUTHORITY SECTION:
   example.org.        SOA ( ... )

   The status NOERROR shows that the &quot;a.example.org&quot; name exists, but
   the reply does not contain an ANSWER section.  This differentiates a
   NODATA response from an NXDOMAIN response; the rest of the packet is
   very similar.  The resolver has to put these pieces of information
   together and conclude that &quot;a.example.org&quot; exists, but it does not
   have a &quot;AAAA&quot; record.











<span class="grey">Gieben &amp; Mekking              Informational                     [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.  Secure Denial of Existence</span>

   The above has to be translated to the security-aware world of DNSSEC.
   But, there are a few principles DNSSEC brings to the table:

   1.  A name server is free to compute the answer and signature(s) on
       the fly, but the protocol is written with a &quot;first sign, then
       load&quot; attitude in mind.  It is rather asymmetrical, but a lot of
       the design in DNSSEC stems from fact that you need to accommodate
       authenticated denial of existence.  If the DNS did not have
       NXDOMAIN, DNSSEC would be a lot simpler, but a lot less useful!

   2.  The DNS packet header is not signed.  This means that a &quot;status:
       NXDOMAIN&quot; cannot be trusted.  In fact, the entire header may be
       forged, including the AD bit (AD stands for Authentic Data; see
       [<a href="/doc/html/rfc3655" title="&quot;Redefinition of DNS Authenticated Data (AD) bit&quot;">RFC3655</a>]), which may give some food for thought;

   3.  DNS wildcards and CNAME records complicate matters significantly.
       See more about this later in Sections <a href="#section-5.3">5.3</a> and <a href="#section-5.4">5.4</a>.

   The first principle implies that all denial-of-existence answers need
   to be precomputed, but it is impossible to precompute (all
   conceivable) nonexistence answers.

   A generic denial record that can be used in all denial-of-existence
   proofs is not an option: such a record is susceptible to replay
   attacks.  When you are querying a name server for any record that
   actually exists, a man in the middle could replay that generic denial
   record that is unlimited in its scope, and it would be impossible to
   tell whether the response was genuine or spoofed.  In other words,
   the generic record can be replayed to falsely deny _all_ possible
   responses.

   We could also use the QNAME in the answer and sign that, essentially
   signing an NXDOMAIN response.  While this approach could have worked
   technically, it is incompatible with offline signing.

   The way this has been solved is by introducing a record that defines
   an interval between two existing names.  Or, to put it another way,
   it defines the holes (nonexisting names) in the zone.  This record
   can be signed beforehand and given to the resolver.  Appendices A and
   B describe online signing techniques that are compatible with this
   scheme.

      Given all these troubles, why didn&#x27;t the designers of DNSSEC go
      for the easy route and allow for online signing?  Well, at that
      time (pre 2000), online signing was not feasible with the then-
      current hardware.  Keep in mind that the larger servers get



<span class="grey">Gieben &amp; Mekking              Informational                     [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


      between 2000 and 6000 queries per second (qps), with peaks up to
      20,000 qps or more.  Scaling signature generation to these kind of
      levels is always a challenge.  Another issue was (and is) key
      management.  For online signing to work, _each_ authoritative name
      server needs access to the private key(s).  This is considered a
      security risk.  Hence, the protocol is required not to rely on
      on-line signing.

   The road to the current solution (NSEC/NSEC3) was long.  It started
   with the NXT (next) record.  The NO (not existing) record was
   introduced, but it never made it into an RFC.  Later on, NXT was
   superseded by the NSEC (next secure) record.  From there, it went
   through NSEC2/DNSNR to finally reach NSEC3 (Next SECure version 3) in
   <a href="/doc/html/rfc5155">RFC 5155</a>.

<span class="h3"><a class="selflink" id="section-3.1" href="#section-3.1">3.1</a>.  NXT</span>

   The first attempt to specify authenticated denial of existence was
   NXT ([<a href="/doc/html/rfc2535" title="&quot;Domain Name System Security Extensions&quot;">RFC2535</a>]).  <a href="/doc/html/rfc2535#section-5.1">Section&nbsp;5.1 of RFC 2535</a> introduces the record:

      The NXT resource record is used to securely indicate that RRs with
      an owner name in a certain name interval do not exist in a zone
      and to indicate what RR types are present for an existing name.

   By specifying what you do have, you implicitly tell what you don&#x27;t
   have.  NXT is superseded by NSEC.  In the next section, we explain
   how NSEC (and thus NXT) works.

<span class="h3"><a class="selflink" id="section-3.2" href="#section-3.2">3.2</a>.  NSEC</span>

   In [<a href="/doc/html/rfc3755" title="&quot;Legacy Resolver Compatibility for Delegation Signer (DS)&quot;">RFC3755</a>], all the DNSSEC types were given new names: SIG was
   renamed RRSIG, KEY became DNSKEY, and NXT was renamed NSEC, and a
   minor issue was fixed in the process, namely the type bitmap was
   redefined to allow more than 127 types to be listed (<a href="/doc/html/rfc2535#section-5.2">[RFC2535],
   Section&nbsp;5.2</a>).

   Just as NXT, NSEC is used to describe an interval between names: it
   indirectly tells a resolver which names do not exist in a zone.

   For this to work, we need our &quot;example.org&quot; zone to be sorted in
   canonical order (<a href="/doc/html/rfc4034#section-6.1">[RFC4034], Section&nbsp;6.1</a>), and then create the NSECs.
   We add three NSEC records, one for each name, and each one covers a
   certain interval.  The last NSEC record points back to the first as
   required by <a href="/doc/html/rfc4034">RFC 4034</a> and depicted in Figure 2.

   1.  The first NSEC covers the interval between &quot;example.org&quot; and
       &quot;a.example.org&quot;;




<span class="grey">Gieben &amp; Mekking              Informational                     [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   2.  The second NSEC covers &quot;a.example.org&quot; to &quot;d.example.org&quot;;

   3.  The third NSEC points back to &quot;example.org&quot; and covers
       &quot;d.example.org&quot; to &quot;example.org&quot; (i.e., the end of the zone).

   As we have defined the intervals and put those in resource records,
   we now have something that can be signed.

                       example.org
                          **
                      +-- ** &lt;--+
                 (1) /  .    .   \ (3)
                    /  .      .   \
                   |  .        .  |
                   v .          . |
                   **    (2)     **
     a.example.org ** ---------&gt; ** d.example.org

   Figure 2: The NSEC records of &quot;example.org&quot;.  The arrows represent
             NSEC records, starting from the apex.

   This signed zone is loaded into the name server.  It looks like this:

   example.org.        SOA ( ... )
                       DNSKEY ( ... )
                       NS  a.example.org.
                       NSEC a.example.org. NS SOA RRSIG NSEC DNSKEY
                       RRSIG(NS) ( ... )
                       RRSIG(SOA) ( ... )
                       RRSIG(NSEC) ( ... )
                       RRSIG(DNSKEY) ( ... )
   a.example.org.      A 192.0.2.1
                       TXT &quot;a record&quot;
                       NSEC d.example.org. A TXT RRSIG NSEC
                       RRSIG(A) ( ... )
                       RRSIG(TXT) ( ... )
                       RRSIG(NSEC) ( ... )
   d.example.org.      A 192.0.2.1
                       TXT &quot;d record&quot;
                       NSEC example.org. A TXT RRSIG NSEC
                       RRSIG(A) ( ... )
                       RRSIG(TXT) ( ... )
                       RRSIG(NSEC) ( ... )

   Figure 3: The signed and sorted &quot;example.org&quot; zone with the added
             NSEC records (and signatures).  For brevity, the class is
             not shown (defaults to IN) and the SOA, DNSKEY, and RRSIG
             records are shortened.



<span class="grey">Gieben &amp; Mekking              Informational                     [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   If a DNSSEC-aware resolver asks for &quot;b.example.org&quot;, it gets back a
   &quot;status: NXDOMAIN&quot; packet, which by itself is meaningless (remember
   that the DNS packet header is not signed and thus can be forged).  To
   be able to securely detect that &quot;b&quot; does not exist, there must also
   be a signed NSEC record that covers the name space where &quot;b&quot; lives.

   The record:

   a.example.org.      NSEC d.example.org. A TXT RRSIG NSEC

   does precisely that: &quot;b&quot; should come after &quot;a&quot;, but the next owner
   name is &quot;d.example.org&quot;, so &quot;b&quot; does not exist.

   Only by making that calculation is a resolver able to conclude that
   the name &quot;b&quot; does not exist.  If the signature of the NSEC record is
   valid, &quot;b&quot; is proven not to exist.  We have authenticated denial of
   existence.  A similar NSEC record needs to be included to deny
   wildcard expansion, see <a href="#section-5.3">Section 5.3</a>.

   Note that a man in the middle may still replay this NXDOMAIN response
   when you&#x27;re querying for, say, &quot;c.example.org&quot;.  But, it would not do
   any harm since it is provable that this is the proper response to the
   query.

<span class="h3"><a class="selflink" id="section-3.3" href="#section-3.3">3.3</a>.  NODATA Responses</span>

   NSEC records are also used in NODATA responses.  In that case, we
   need to look more closely at the type bitmap.  The type bitmap in an
   NSEC record tells which types are defined for a name.  If we look at
   the NSEC record of &quot;a.example.org&quot;, we see the following types in the
   bitmap: A, TXT, NSEC, and RRSIG.  So, for the name &quot;a&quot;, this
   indicates we must have an A, TXT, NSEC, and RRSIG record in the zone.

   With the type bitmap of the NSEC record, a resolver can establish
   that a name is there, but the type is not.  For example, if a
   resolver asks for &quot;a.example.org AAAA&quot;, the reply that comes back is:

   ;; status: NOERROR, id: 44638

   ;; AUTHORITY SECTION:
   example.org.        SOA ( ... )
   example.org.        RRSIG(SOA) ( ... )
   a.example.org.      NSEC d.example.org. A TXT RRSIG NSEC
   a.example.org.      RRSIG(NSEC) ( ... )







<span class="grey">Gieben &amp; Mekking              Informational                     [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   The resolver should check the AUTHORITY section and conclude that:

   (1)  &quot;a.example.org&quot; exists (because of the NSEC with that owner
        name); and

   (2)  the type (AAAA) does not exist as it is not listed in the type
        bitmap.

   The techniques used by NSEC form the basics of authenticated denial
   of existence in DNSSEC.

<span class="h3"><a class="selflink" id="section-3.4" href="#section-3.4">3.4</a>.  Drawbacks of NSEC</span>

   There were two issues with NSEC (and NXT).  The first is that it
   allows for zone walking.  NSEC records point from one name to
   another; in our example: &quot;example.org&quot; points to &quot;a.example.org&quot;,
   which points to &quot;d.example.org&quot;, which points back to &quot;example.org&quot;.
   So, we can reconstruct the entire &quot;example.org&quot; zone, thus defeating
   attempts to administratively block zone transfers (<a href="/doc/html/rfc2065#section-5.5">[RFC2065],
   Section&nbsp;5.5</a>).

   The second issue is that when a large, delegation-centric (<a href="/doc/html/rfc5155#section-1.1">[RFC5155],
   Section&nbsp;1.1</a>) zone deploys DNSSEC, every name in the zone gets an NSEC
   plus RRSIG.  So, this leads to a huge increase in the zone size (when
   signed).  This would in turn mean that operators of such zones who
   are deploying DNSSEC face up-front costs.  This could hinder DNSSEC
   adoption.

   These two issues eventually lead to NSEC3, which:

   o  Adds a way to garble the owner names thus thwarting zone walking;

   o  Makes it possible to skip names for the next owner name.  This
      feature is called Opt-Out (see <a href="#section-5.1">Section 5.1</a>).  It means not all
      names in your zone get an NSEC3 plus ditto signature, making it
      possible to &quot;grow into&quot; your DNSSEC deployment.

   Note that there are other ways to mitigate zone walking.  <a href="/doc/html/rfc4470">RFC 4470</a>
   [<a href="/doc/html/rfc4470" title="&quot;Minimally Covering NSEC Records and DNSSEC On-line Signing&quot;">RFC4470</a>] prevents zone walking by introducing minimally covering
   NSEC records.  This technique is described in <a href="#appendix-A">Appendix A</a>.

   Before we delve into NSEC3, let us first take a look at its
   predecessors: NO, NSEC2, and DNSNR.








<span class="grey">Gieben &amp; Mekking              Informational                    [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.  Experimental and Deprecated Mechanisms: NO, NSEC2, and DNSNR</span>

   Long before NSEC was defined, the NO record was introduced.  It was
   the first record to use the idea of hashed owner names to fix the
   issue of zone walking that was present with the NXT record.  It also
   fixed the type bitmap issue of the NXT record, but not in a space-
   efficient way.  At that time (around 2000), zone walking was not
   considered important enough to warrant the new record.  People were
   also worried that DNSSEC deployment would be hindered by developing
   an alternate means of denial of existence.  Thus, the effort was
   shelved and NXT remained.

   When the new DNSSEC specification [<a href="/doc/html/rfc4034" title="&quot;Resource Records for the DNS Security Extensions&quot;">RFC4034</a>] was written, people were
   still not convinced that zone walking was a problem that should be
   solved.  So, NSEC saw the light and inherited the two issues from
   NXT.

   Several years after, NSEC2 was introduced as a way to solve the two
   issues of NSEC.  The NSEC2 document [<a href="#ref-DNSEXT-NSEC2">DNSEXT-NSEC2</a>] contains the
   following paragraph:

      This document proposes an alternate scheme which hides owner names
      while permitting authenticated denial of existence of non-existent
      names.  The scheme uses two new RR types: NSEC2 and EXIST.

   When an authenticated denial-of-existence scheme starts to talk about
   EXIST records, it is worth paying extra attention.  The EXIST record
   was defined as a record without RDATA that would be used to signal
   the presence of a domain name.  From [<a href="#ref-DNSEXT-NSEC2">DNSEXT-NSEC2</a>]:

      In order to prove the nonexistence of a record that might be
      covered by a wildcard, it is necessary to prove the existence of
      its closest encloser.  This record does that.  Its owner is the
      closest encloser.  It has no RDATA.  If there is another RR that
      proves the existence of the closest encloser, this SHOULD be used
      instead of an EXIST record.

   The introduction of this record led to questions about what wildcards
   actually mean (especially in the context of DNSSEC).  It is probably
   not a coincidence that &quot;The Role of Wildcards in the Domain Name
   System&quot; [<a href="/doc/html/rfc4592" title="&quot;The Role of Wildcards in the Domain Name System&quot;">RFC4592</a>] was standardized before NSEC3 was.

   NSEC2 solved the zone-walking issue by hashing (with SHA1 and a salt)
   the &quot;next owner name&quot; in the record, thereby making it useless for
   zone walking.  But, it did not have Opt-Out.

   The DNSNR record was another attempt that used hashed names to foil
   zone walking, and it also introduced the concept of opting out



<span class="grey">Gieben &amp; Mekking              Informational                    [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   (called &quot;Authoritative Only Flag&quot;), which limited the use of DNSNR in
   delegation-centric zones.

   All of these proposals didn&#x27;t make it, but they did provide valuable
   insights.  To summarize:

   o  The NO record introduced hashing, but this idea lingered in the
      background for a long time;

   o  The NSEC2 record made it clear that wildcards were not completely
      understood;

   o  The DNSNR record used a new flag field in the RDATA to signal Opt-
      Out.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.  NSEC3</span>

   From the experience gained with NSEC2 and DNSNR, NSEC3 was forged.
   It incorporates both Opt-Out and the hashing of names.  NSEC3 solves
   any issues people might have with NSEC, but it introduces some
   additional complexity.

   NSEC3 did not supersede NSEC; they are both defined for DNSSEC.  So,
   DNSSEC is blessed with two different means to perform authenticated
   denial of existence: NSEC and NSEC3.  In NSEC3, every name is hashed,
   including the owner name.  This means that the NSEC3 chain is sorted
   in hash order, instead of canonical order.  Because the owner names
   are hashed, the next owner name for &quot;example.org&quot; is unlikely to be
   &quot;a.example.org&quot;.  Because the next owner name is hashed, zone walking
   becomes more difficult.

   To make it even more difficult to retrieve the original names, the
   hashing can be repeated several times, each time taking the previous
   hash as input.  To prevent the reuse of pre-generated hash values
   between zones, a (per-zone) salt can also be added.  In the NSEC3 for
   &quot;example.org&quot;, we have hashed the names thrice (<a href="/doc/html/rfc5155#section-5">[RFC5155], Section&nbsp;5</a>)
   and used the salt &quot;DEAD&quot;.  Let&#x27;s look at a typical NSEC3 record:

   15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
      NSEC3 1 0 2 DEAD A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84
           NS SOA RRSIG DNSKEY NSEC3PARAM )

   On the first line, we see the hashed owner name:
   &quot;15bg9l6359f5ch23e34ddua6n1rihl9h.example.org&quot;; this is the hashed
   name of the fully qualified domain name (FQDN) &quot;example.org&quot; encoded
   as Base32 [<a href="/doc/html/rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>].  Note that even though we hashed &quot;example.org&quot;,
   the zone&#x27;s name is added to make it look like a domain name again.
   In our zone, the basic format is &quot;Base32(SHA1(FQDN)).example.org&quot;.



<span class="grey">Gieben &amp; Mekking              Informational                    [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   The next hashed owner name &quot;A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84&quot; (line
   2) is the hashed version of &quot;d.example.org&quot;, represented as Base32.
   Note that &quot;d.example.org&quot; is used as the next owner name because in
   the hash ordering, its hash comes after the hash of the zone&#x27;s apex.
   Also, note that &quot;.example.org&quot; is not added to the next hashed owner
   name, as this name always falls in the current zone.

   The &quot;1 0 2 DEAD&quot; segment of the NSEC3 states:

   o  Hash Algorithm = 1 (SHA1 is the default; no other hash algorithms
      are currently defined for use in NSEC3; see <a href="/doc/html/rfc5155#section-3.1.1">Section&nbsp;3.1.1 of
      [RFC5155]</a>);

   o  Opt-Out = 0 (disabled; see <a href="/doc/html/rfc5155#section-6">Section&nbsp;6 of [RFC5155]</a>);

   o  Hash Iterations = 2 (this yields three iterations, as a zero value
      is already one iteration; see <a href="/doc/html/rfc5155#section-3.1.3">Section&nbsp;3.1.3 of [RFC5155]</a>);

   o  Salt = &quot;DEAD&quot; (see <a href="/doc/html/rfc5155#section-3.1.5">Section&nbsp;3.1.5 of [RFC5155]</a>.

   At the end, we see the type bitmap, which is identical to NSEC&#x27;s
   bitmap, that lists the types present at the original owner name.
   Note that the type NSEC3 is absent from the list in the example
   above.  This is due to the fact that the original owner name
   (&quot;example.org&quot;) does not have the NSEC3 type.  It only exists for the
   hashed name.

   Names like &quot;1.h.example.org&quot; hash to one label in NSEC3 and
   &quot;1.h.example.org&quot; becomes:
   &quot;117gercprcjgg8j04ev1ndrk8d1jt14k.example.org&quot; when used as an owner
   name.  This is an important observation.  By hashing the names, you
   lose the depth of a zone -- hashing introduces a flat space of names,
   as opposed to NSEC.

   The name used above (&quot;1.h.example.org&quot;) creates an empty non-
   terminal.  Empty non-terminals are domain names that have no RRs
   associated with them and exist only because they have one or more
   subdomains that do (<a href="/doc/html/rfc5155#section-1.3">[RFC5155], Section&nbsp;1.3</a>).  The record:

       1.h.example.org.    TXT &quot;1.h record&quot;

   creates two names:

   1.  &quot;1.h.example.org&quot; that has the type: TXT;

   2.  &quot;h.example.org&quot;, which has no types.  This is the empty non-
       terminal.




<span class="grey">Gieben &amp; Mekking              Informational                    [Page 13]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-14" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   An empty non-terminal will get an NSEC3 record but not an NSEC
   record.  In <a href="#section-5.5">Section 5.5</a>, how the resolver uses these NSEC3 records to
   validate the denial-of-existence proofs is shown.

   Note that NSEC3 might not always be useful.  For example, highly
   structured zones, like the reverse zones ip6.arpa and in-addr.arpa,
   can be walked even with NSEC3 due to their structure.  Also, the
   names in small, trivial zones can be easily guessed.  In these cases,
   it does not help to defend against zone walking, but it does add the
   computational load on authoritative servers and validators.

<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a>.  Opt-Out</span>

   Hashing mitigates the zone-walking issue of NSEC.  The other issue,
   the high costs of securing a delegation to an insecure zone, is
   tackled with Opt-Out.  When using Opt-Out, names that are an insecure
   delegation (and empty non-terminals that are only derived from
   insecure delegations) don&#x27;t require an NSEC3 record.  For each
   insecure delegation, the zone size can be decreased (compared with a
   fully signed zone without using Opt-Out) with at least two records:
   one NSEC3 record and one corresponding RRSIG record.  If the insecure
   delegation would introduce empty non-terminals, even more records can
   be omitted from the zone.

   Opt-Out NSEC3 records are not able to prove or deny the existence of
   the insecure delegations.  In other words, those delegations do not
   benefit from the cryptographic security that DNSSEC provides.

   A recently discovered corner case (see RFC Errata ID 3441 [<a href="#ref-Err3441" title="RFC 5155">Err3441</a>])
   shows that not only those delegations remain insecure but also the
   empty non-terminal space that is derived from those delegations.

   Because the names in this empty non-terminal space do exist according
   to the definition in [<a href="/doc/html/rfc4592" title="&quot;The Role of Wildcards in the Domain Name System&quot;">RFC4592</a>], the server should respond to queries
   for these names with a NODATA response.  However, the validator
   requires an NSEC3 record proving the NODATA response (<a href="/doc/html/rfc5155#section-8.5">[RFC5155],
   Section&nbsp;8.5</a>):

      The validator MUST verify that an NSEC3 RR that matches QNAME is
      present and that both the QTYPE and the CNAME type are not set in
      its Type Bit Maps field.

   A way to resolve this contradiction in the specification is to always
   provide empty non-terminals with an NSEC3 record, even if it is only
   derived from an insecure delegation.






<span class="grey">Gieben &amp; Mekking              Informational                    [Page 14]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-15" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


<span class="h3"><a class="selflink" id="section-5.2" href="#section-5.2">5.2</a>.  Loading an NSEC3 Zone</span>

   Whenever an authoritative server receives a query for a non-existing
   record, it has to hash the incoming query name to determine into
   which interval between two existing hashes it falls.  To do that, it
   needs to know the zone&#x27;s specific NSEC3 parameters (hash iterations
   and salt).

   One way to learn them is to scan the zone during loading for NSEC3
   records and glean the NSEC3 parameters from them.  However, it would
   need to make sure that there is at least one complete set of NSEC3
   records for the zone using the same parameters.  Therefore, it would
   need to inspect all NSEC3 records.

   A more graceful solution was designed.  The solution was to create a
   new record, NSEC3PARAM, which must be placed at the apex of the zone.
   Its role is to provide a fixed place where an authoritative name
   server can directly see the NSEC3 parameters used, and by putting it
   in the zone, it allows for easy transfer to the secondaries.

<span class="h3"><a class="selflink" id="section-5.3" href="#section-5.3">5.3</a>.  Wildcards in the DNS</span>

   So far, we have only talked about denial of existence in negative
   responses.  However, denial of existence may also occur in positive
   responses, i.e., where the ANSWER section of the response is not
   empty.  This can happen because of wildcards.

   Wildcards have been part of the DNS since the first DNS RFCs.  They
   allow to define all names for a certain type in one go.  In our
   &quot;example.org&quot; zone, we could, for instance, add a wildcard record:

   *.example.org.      TXT &quot;wildcard record&quot;

   For completeness, our (unsigned) zone now looks like this:

   example.org.        SOA ( ... )
   example.org.        NS  a.example.org.
   *.example.org.      TXT &quot;wildcard record&quot;
   a.example.org.      A 192.0.2.1
                       TXT &quot;a record&quot;
   d.example.org.      A 192.0.2.1
                       TXT &quot;d record&quot;

   Figure 4: The example.org Zone with a Wildcard Record







<span class="grey">Gieben &amp; Mekking              Informational                    [Page 15]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-16" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   If a resolver asks for &quot;z.example.org TXT&quot;, the name server will
   respond with an expanded wildcard instead of an NXDOMAIN:

   ;; status: NOERROR, id: 13658

   ;; ANSWER SECTION:
   z.example.org.      TXT &quot;wildcard record&quot;

   Note, however, that the resolver cannot detect that this answer came
   from a wildcard.  It just sees the answer as is.  How will this
   answer look with DNSSEC?

   ;; status: NOERROR, id: 51790

   ;; ANSWER SECTION:
   z.example.org.      TXT &quot;wildcard record&quot;
   z.example.org.      RRSIG(TXT) ( ... )

   ;; AUTHORITY SECTION:
   d.example.org.      NSEC example.org. A TXT RRSIG NSEC
   d.example.org.      RRSIG(NSEC) ( ... )

   Figure 5: A Response with an Expanded Wildcard and DNSSEC

   The RRSIG of the &quot;z.example.org&quot; TXT record indicates there is a
   wildcard configured.  The RDATA of the signature lists a label count,
   <a href="/doc/html/rfc4034#section-3.1.3">[RFC4034], Section&nbsp;3.1.3</a>., of two (not visible in the figure above),
   but the owner name of the signature has three labels.  This mismatch
   indicates there is a wildcard &quot;*.example.org&quot; configured.

      An astute reader may notice that it appears as if a
      &quot;z.example.org&quot; RRSIG(TXT) is created out of thin air.  This is
      not the case.  The signature for &quot;z.example.org&quot; does not exist.
      The signature you are seeing is the one for &quot;*.example.org&quot;, which
      does exist; only the owner name is switched to &quot;z.example.org&quot;.
      So, even with wildcards, no signatures have to be created on the
      fly.

   The DNSSEC standard mandates that an NSEC (or NSEC3) is included in
   such responses.  If it wasn&#x27;t, an attacker could mount a replay
   attack and poison the cache with false data.  Suppose that the
   resolver has asked for &quot;a.example.org TXT&quot;.  An attacker could modify
   the packet in such way that it looks like the response was generated
   through wildcard expansion, even though a record exists for
   &quot;a.example.org TXT&quot;.






<span class="grey">Gieben &amp; Mekking              Informational                    [Page 16]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-17" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   The tweaking simply consists of adjusting the ANSWER section to:

   ;; status: NOERROR, id: 31827

   ;; ANSWER SECTION:
   a.example.org.      TXT &quot;wildcard record&quot;
   a.example.org.      RRSIG(TXT) ( ... )

   Figure 6: A Forged Response without the Expanded Wildcard

   Note the subtle difference from Figure 5 in the owner name.  In this
   response, we see a &quot;a.example.org TXT&quot; record for which a record with
   different RDATA (see Figure 4) exists in the zone.

   That would be a perfectly valid answer if we would not require the
   inclusion of an NSEC or NSEC3 record in the wildcard answer response.
   The resolver believes that &quot;a.example.org TXT&quot; is a wildcard record,
   and the real record is obscured.  This is bad and defeats all the
   security DNSSEC can deliver.  Because of this, the NSEC or NSEC3 must
   be present.

   Another way of putting this is that DNSSEC is there to ensure the
   name server has followed the steps as outlined in <a href="/doc/html/rfc1034#section-4.3.2">[RFC1034],
   Section&nbsp;4.3.2</a> for looking up names in the zone.  It explicitly lists
   wildcard lookup as one of these steps (3c), so with DNSSEC this must
   be communicated to the resolver: hence, the NSEC or NSEC3 record.

























<span class="grey">Gieben &amp; Mekking              Informational                    [Page 17]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-18" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


<span class="h3"><a class="selflink" id="section-5.4" href="#section-5.4">5.4</a>.  CNAME Records</span>

   So far, the maximum number of NSEC records a response will have is
   two: one for the denial of existence and another for the wildcard.
   We say maximum because sometimes a single NSEC can prove both.  With
   NSEC3, this is three (as to why, we will explain in the next
   section).

   When we take CNAME wildcard records into account, we can have more
   NSEC or NSEC3 records.  For every wildcard expansion, we need to
   prove that the expansion was allowed.  Let&#x27;s add some CNAME wildcard
   records to our zone:

   example.org.        SOA ( ... )
   example.org.        NS  a.example.org.
   *.example.org.      TXT &quot;wildcard record&quot;
   a.example.org.      A 192.0.2.1
                       TXT &quot;a record&quot;
   *.a.example.org.    CNAME w.b
   *.b.example.org.    CNAME w.c
   *.c.example.org.    A 192.0.2.1
   d.example.org.      A 192.0.2.1
                       TXT &quot;d record&quot;
   w.example.org.      CNAME w.a

   Figure 7: A Wildcard CNAME Chain Added to the &quot;example.org&quot; Zone

























<span class="grey">Gieben &amp; Mekking              Informational                    [Page 18]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-19" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   A query for &quot;w.example.org A&quot; will result in the following response:

   ;; status: NOERROR, id: 4307

   ;; ANSWER SECTION:
   w.example.org.      CNAME w.a.example.org.
   w.example.org.      RRSIG(CNAME) ( ... )
   w.a.example.org.    CNAME w.b.example.org.
   w.a.example.org.    RRSIG(CNAME) ( ... )
   w.b.example.org.    CNAME w.c.example.org.
   w.b.example.org.    RRSIG(CNAME) ( ... )
   w.c.example.org.    A 192.0.2.1
   w.c.example.org.    RRSIG(A) ( ... )

   ;; AUTHORITY SECTION:
   *.a.example.org.    NSEC *.b.example.org. CNAME RRSIG NSEC
   *.a.example.org.    RRSIG(NSEC) ( ... )
   *.b.example.org.    NSEC *.c.example.org. CNAME RRSIG NSEC
   *.b.example.org.    RRSIG(NSEC) ( ... )
   *.c.example.org.    NSEC d.example.org. A RRSIG NSEC
   *.c.example.org.    RRSIG(NSEC) ( ... )

   The NSEC record &quot;*.a.example.org&quot; proves that wildcard expansion to
   &quot;w.a.example.org&quot; was appropriate: &quot;w.a.&quot; falls in the gap &quot;*.a&quot; to
   &quot;*.b&quot;.  Similarly, the NSEC record &quot;*.b.example.org&quot; proves that
   there was no direct match for &quot;w.b.example.org&quot; and &quot;*.c.example.org&quot;
   denies the direct match for &quot;w.c.example.org&quot;.

   DNAME records and wildcard names should not be used as reiterated in
   <a href="/doc/html/rfc6672#section-3.3">[RFC6672], Section&nbsp;3.3</a>.

<span class="h3"><a class="selflink" id="section-5.5" href="#section-5.5">5.5</a>.  The Closest Encloser NSEC3 Record</span>

   We can have one or more NSEC3 records that deny the existence of the
   requested name and one NSEC3 record that denies wildcard synthesis.
   What do we miss?

   The short answer is that due to the hashing in NSEC3, you lose the
   depth of your zone and everything is hashed into a flat plane.  To
   make up for this loss of information, you need an extra record.











<span class="grey">Gieben &amp; Mekking              Informational                    [Page 19]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-20" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   To understand NSEC3, we will need two definitions:

   Closest encloser:  Introduced in [<a href="/doc/html/rfc4592" title="&quot;The Role of Wildcards in the Domain Name System&quot;">RFC4592</a>] as:

      The closest encloser is the node in the zone&#x27;s tree of existing
      domain names that has the most labels matching the query name
      (consecutively, counting from the root label downward).

      In our example, if the query name is &quot;x.2.example.org&quot;, then
      &quot;example.org&quot; is the &quot;closest encloser&quot;;

   Next closer name:  Introduced in [<a href="/doc/html/rfc5155" title="&quot;DNS Security (DNSSEC) Hashed Authenticated Denial of Existence&quot;">RFC5155</a>], this is the closest
      encloser with one more label added to the left.  So, if
      &quot;example.org&quot; is the closest encloser for the query name
      &quot;x.2.example.org&quot;, &quot;2.example.org&quot; is the &quot;next closer name&quot;.

   An NSEC3 &quot;closest encloser proof&quot; consists of:

   1.  An NSEC3 record that *matches* the &quot;closest encloser&quot;.  This
       means the unhashed owner name of the record is the closest
       encloser.  This bit of information tells a resolver: &quot;The name
       you are asking for does not exist; the closest I have is this&quot;.

   2.  An NSEC3 record that *covers* the &quot;next closer name&quot;.  This means
       it defines an interval in which the &quot;next closer name&quot; falls.
       This tells the resolver: &quot;The next closer name falls in this
       interval, and therefore the name in your question does not exist.
       In fact, the closest encloser is indeed the closest I have&quot;.

   These two records already deny the existence of the requested name,
   so we do not need an NSEC3 record that covers the actual queried
   name.  By denying the existence of the next closer name, you also
   deny the existence of the queried name.

   Note that with NSEC, the existence of all empty non-terminals between
   the two names are denied, hence it implicitly contains the closest
   encloser.

   For a given query name, there is one (and only one) place where
   wildcard expansion is possible.  This is the &quot;source of synthesis&quot;
   and is defined ([<a href="/doc/html/rfc4592" title="&quot;The Role of Wildcards in the Domain Name System&quot;">RFC4592</a>], Sections <a href="#section-2.1.1">2.1.1</a> and <a href="#section-3.3.1">3.3.1</a>) as:

   &lt;asterisk label&gt;.&lt;closest encloser&gt;

   In other words, to deny wildcard synthesis, the resolver needs to
   know the hash of the source of synthesis.  Since it does not know
   beforehand what the closest encloser of the query name is, it must be
   provided in the answer.



<span class="grey">Gieben &amp; Mekking              Informational                    [Page 20]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-21" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   Take the following example.  We have a zone with two TXT records to
   it.  The records added are &quot;1.h.example.org&quot; and &quot;3.3.example.org&quot;.
   It is signed with NSEC3, resulting in the following unsigned zone:

    example.org.        SOA ( ... )
    example.org.        NS  a.example.org.
    1.h.example.org.    TXT &quot;1.h record&quot;
    3.3.example.org.    TXT &quot;3.3 record&quot;

   Figure 8: The TXT records in example.org.  These records create two
   empty non-terminals: h.example.org and 3.example.org.

   The resolver asks the following: &quot;x.2.example.org TXT&quot;.  This leads
   to an NXDOMAIN response from the server, which contains three NSEC3
   records.  A list of hashed owner names can be found in <a href="#appendix-C">Appendix C</a>.
   Also, see Figure 9; the numbers in that figure correspond with the
   following NSEC3 records:

   15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
    NSEC3 1 0 2 DEAD 1AVVQN74SG75UKFVF25DGCETHGQ638EK NS SOA RRSIG
           DNSKEY NSEC3PARAM )

   1avvqn74sg75ukfvf25dgcethgq638ek.example.org. (
       NSEC3 1 0 2 DEAD 75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ )

   75b9id679qqov6ldfhd8ocshsssb6jvq.example.org. (
    NSEC3 1 0 2 DEAD 8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ TXT RRSIG )

   If we would follow the NSEC approach, the resolver is only interested
   in one thing.  Does the hash of &quot;x.2.example.org&quot; fall in any of the
   intervals of the NSEC3 records it got?




















<span class="grey">Gieben &amp; Mekking              Informational                    [Page 21]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-22" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


                       example.org
                          **
                      +-- ** . . . . . . . . . . .
                 (1) /  . ^ .                     .
                    /  .  |   .                    .
                   |  .   |    .                    .
                   v .    |     .                    .
                   **     | (2)  **                  ++
     h.example.org ** ----+----&gt; ** 3.example.org    ++ 2.example.org
                   .     /        . |                .
                   .    / (5)     . | (3)            .
                   .   /          . |                .
                   .  /           . v                .
   1.h.example.org **            **                  ++
                   ** &lt;--------- ** 3.3.example.org  ++ x.2.example.org
                            (4)

   Figure 9: &quot;x.2.example.org&quot; does not exist.  The five arrows
             represent the NSEC3 records; the ones numbered (1), (2),
             and (3) are the NSEC3s returned in our answer.
             &quot;2.example.org&quot; is covered by (3) and &quot;x.2.example.org&quot; is
             covered by (4).

   The hash of &quot;x.2.example.org&quot; is &quot;ndtu6dste50pr4a1f2qvr1v31g00i2i1&quot;.
   Checking this hash on the first NSEC3 yields that it does not fall in
   between the interval: &quot;15bg9l6359f5ch23e34ddua6n1rihl9h&quot; to
   &quot;1avvqn74sg75ukfvf25dgcethgq638ek&quot;.  For the second NSEC3, the answer
   is also negative: the hash sorts outside the interval described by
   &quot;1avvqn74sg75ukfvf25dgcethgq638ek&quot; and
   &quot;75b9id679qqov6ldfhd8ocshsssb6jvq&quot;.  And, the third NSEC3, with
   interval &quot;75b9id679qqov6ldfhd8ocshsssb6jvq&quot; to
   &quot;8555t7qegau7pjtksnbchg4td2m0jnpj&quot; also isn&#x27;t of any help.

   What is a resolver to do?  It has been given the maximum amount of
   NSEC3s and they all seem useless.

   So, this is where the closest encloser proof comes into play.  And,
   for the proof to work, the resolver needs to know what the closest
   encloser is.  There must be an existing ancestor in the zone: a name
   must exist that is shorter than the query name.  The resolver keeps
   hashing increasingly shorter names from the query name until an owner
   name of an NSEC3 matches.  This owner name is the closest encloser.

   When the resolver has found the closest encloser, the next step is to
   construct the next closer name.  This is the closest encloser with
   the last chopped label from the query name prepended to it: &quot;&lt;last
   chopped label&gt;.&lt;closest encloser&gt;&quot;.  The hash of this name should be
   covered by the interval set in any of the NSEC3 records.



<span class="grey">Gieben &amp; Mekking              Informational                    [Page 22]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-23" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   Then, the resolver needs to check the presence of a wildcard.  It
   creates the wildcard name by prepending the asterisk label to the
   closest encloser, &quot;*.&lt;closest encloser&gt;&quot;, and uses the hash of that.

   Going back to our example, the resolver must first detect the NSEC3
   that matches the closest encloser.  It does this by chopping up the
   query name, hashing each instance (with the same number of iterations
   and hash as the zone it is querying), and comparing that to the
   answers given.  So, it has the following hashes to work with:

   x.2.example.org:  &quot;ndtu6dste50pr4a1f2qvr1v31g00i2i1&quot;, last chopped
      label: &quot;&lt;empty&gt;&quot;;

   2.example.org:  &quot;7t70drg4ekc28v93q7gnbleopa7vlp6q&quot;, last chopped
      label: &quot;x&quot;;

   example.org:  &quot;15bg9l6359f5ch23e34ddua6n1rihl9h&quot;, last chopped label:
      &quot;2&quot;.

   Of these hashes, only one matches the owner name of one of the NSEC3
   records: &quot;15bg9l6359f5ch23e34ddua6n1rihl9h&quot;.  This must be the
   closest encloser (unhashed: &quot;example.org&quot;).  That&#x27;s the main purpose
   of that NSEC3 record: tell the resolver what the closest encloser is.

   When using Opt-Out, it is possible that the actual closest encloser
   to the QNAME does not have an NSEC3 record.  If so, we will have to
   do with the closest provable encloser, which is the closest enclosing
   authoritative name that does have an NSEC3 record.  In the worst
   case, this is the NSEC3 record corresponding to the apex; this name
   must always have an NSEC3 record.

   With the closest (provable) encloser, the resolver constructs the
   next closer, which in this case is: &quot;2.example.org&quot;; &quot;2&quot; is the last
   label chopped when &quot;example.org&quot; is the closest encloser.  The hash
   of this name should be covered in any of the other NSEC3s.  And, it
   is -- &quot;7t70drg4ekc28v93q7gnbleopa7vlp6q&quot; falls in the interval set by
   &quot;75b9id679qqov6ldfhd8ocshsssb6jvq&quot; and
   &quot;8555t7qegau7pjtksnbchg4td2m0jnpj&quot; (this is our second NSEC3).

   So, what does the resolver learn from this?

   o  &quot;example.org&quot; exists;

   o  &quot;2.example.org&quot; does not exist.

   And, if &quot;2.example.org&quot; does not exist, there is also no direct match
   for &quot;x.2.example.org&quot;.  The last step is to deny the existence of the
   source of synthesis to prove that no wildcard expansion was possible.



<span class="grey">Gieben &amp; Mekking              Informational                    [Page 23]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-24" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   The resolver hashes &quot;*.example.org&quot; to
   &quot;22670trplhsr72pqqmedltg1kdqeolb7&quot; and checks that it is covered.  In
   this case, by the last NSEC3 (see Figure 9), the hash falls in the
   interval set by &quot;1avvqn74sg75ukfvf25dgcethgq638ek&quot; and
   &quot;75b9id679qqov6ldfhd8ocshsssb6jvq&quot;.  This means there is no wildcard
   record directly below the closest encloser, and &quot;x.2.example.org&quot;
   definitely does not exist.

   When we have validated the signatures, we have reached our goal:
   authenticated denial of existence.

<span class="h3"><a class="selflink" id="section-5.6" href="#section-5.6">5.6</a>.  Three to Tango</span>

   One extra NSEC3 record plus an additional signature may seem like a
   lot just to deny the existence of the wildcard record, but we cannot
   leave it out.  If the standard would not mandate the closest encloser
   NSEC3 record but instead required two NSEC3 records -- one to deny
   the query name and one to deny the wildcard record -- an attacker
   could fool the resolver that the source of synthesis does not exist,
   while it in fact does.

   Suppose the wildcard record does exist, so our unsigned zone looks
   like this:

   example.org.        SOA ( ... )
   example.org.        NS  a.example.org.
   *.example.org.      TXT &quot;wildcard record&quot;
   1.h.example.org.    TXT &quot;1.h record&quot;
   3.3.example.org.    TXT &quot;3.3 record&quot;

   The query &quot;x.2.example.org TXT&quot; should now be answered with:

   x.2.example.org.    TXT &quot;wildcard record&quot;

   An attacker can deny this wildcard expansion by calculating the hash
   for the wildcard name &quot;*.2.example.org&quot; and searching for an NSEC3
   record that covers that hash.  The hash of &quot;*.2.example.org&quot; is
   &quot;fbq73bfkjlrkdoqs27k5qf81aqqd7hho&quot;.  Looking through the NSEC3
   records in our zone, we see that the NSEC3 record of &quot;3.3&quot; covers
   this hash:

   8555t7qegau7pjtksnbchg4td2m0jnpj.example.org. (
       NSEC3 1 0 2 DEAD 15BG9L6359F5CH23E34DDUA6N1RIHL9H TXT RRSIG )

   This record also covers the query name &quot;x.2.example.org&quot;
   (&quot;ndtu6dste50pr4a1f2qvr1v31g00i2i1&quot;).





<span class="grey">Gieben &amp; Mekking              Informational                    [Page 24]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-25" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   Now an attacker adds this NSEC3 record to the AUTHORITY section of
   the reply to deny both &quot;x.2.example.org&quot; and any wildcard expansion.
   The net result is that the resolver determines that &quot;x.2.example.org&quot;
   does not exist, while in fact it should have been synthesized via
   wildcard expansion.  With the NSEC3 matching the closest encloser
   &quot;example.org&quot;, the resolver can be sure that the wildcard expansion
   should occur at &quot;*.example.org&quot; and nowhere else.

   Coming back to the original question: Why do we need up to three
   NSEC3 records to deny a requested name?  The resolver needs to be
   explicitly told what the &quot;closest encloser&quot; is, and this takes up a
   full NSEC3 record.  Then, the next closer name needs to be covered in
   an NSEC3 record.  Finally, an NSEC3 must say something about whether
   wildcard expansion was possible.  That makes three to tango.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.  Security Considerations</span>

   DNSSEC does not protect against denial-of-service attacks, nor does
   it provide confidentiality.  For more general security considerations
   related to DNSSEC, please see [<a href="/doc/html/rfc4033" title="&quot;DNS Security Introduction and Requirements&quot;">RFC4033</a>], [<a href="/doc/html/rfc4034" title="&quot;Resource Records for the DNS Security Extensions&quot;">RFC4034</a>], [<a href="/doc/html/rfc4035" title="&quot;Protocol Modifications for the DNS Security Extensions&quot;">RFC4035</a>], and
   [<a href="/doc/html/rfc5155" title="&quot;DNS Security (DNSSEC) Hashed Authenticated Denial of Existence&quot;">RFC5155</a>].

   These RFCs are concise about why certain design choices have been
   made in the area of authenticated denial of existence.
   Implementations that do not correctly handle this aspect of DNSSEC
   create a severe hole in the security DNSSEC adds.  This is
   specifically troublesome for secure delegations.  If an attacker is
   able to deny the existence of a Delegation Signer (DS) record, the
   resolver cannot establish a chain of trust, and the resolver has to
   fall back to insecure DNS for the remainder of the query resolution.

   This document aims to fill this &quot;documentation gap&quot; and provide
   would-be implementors and other interested parties with enough
   background knowledge to better understand authenticated denial of
   existence.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.  Acknowledgments</span>

   This document would not be possible without the help of Ed Lewis, Roy
   Arends, Wouter Wijngaards, Olaf Kolkman, Carsten Strotmann, Jan-Piet
   Mens, Peter van Dijk, Marco Davids, Esther Makaay, Antoin Verschuren,
   Lukas Wunner, Joe Abley, Ralf Weber, Geoff Huston, Dave Lawrence,
   Tony Finch, and Mark Andrews.  Also valuable was the source code of
   Unbound (&quot;validator/val_nsec3.c&quot;) [<a href="#ref-Unbound" title="&quot;Unbound: a validating, recursive, and caching DNS resolver&quot;">Unbound</a>].

   Extensive feedback for early versions of this document was received
   from Karst Koymans.




<span class="grey">Gieben &amp; Mekking              Informational                    [Page 25]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-26" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.  References</span>

<span class="h3"><a class="selflink" id="section-8.1" href="#section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC1034">RFC1034</a>]  Mockapetris, P., &quot;Domain names - concepts and facilities&quot;,
              STD 13, <a href="/doc/html/rfc1034">RFC 1034</a>, November 1987.

   [<a id="ref-RFC2065">RFC2065</a>]  Eastlake, D. and C. Kaufman, &quot;Domain Name System Security
              Extensions&quot;, <a href="/doc/html/rfc2065">RFC 2065</a>, January 1997.

   [<a id="ref-RFC2308">RFC2308</a>]  Andrews, M., &quot;Negative Caching of DNS Queries (DNS
              NCACHE)&quot;, <a href="/doc/html/rfc2308">RFC 2308</a>, March 1998.

   [<a id="ref-RFC4033">RFC4033</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, &quot;DNS Security Introduction and Requirements&quot;, <a href="/doc/html/rfc4033">RFC</a>
              <a href="/doc/html/rfc4033">4033</a>, March 2005.

   [<a id="ref-RFC4034">RFC4034</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, &quot;Resource Records for the DNS Security Extensions&quot;,
              <a href="/doc/html/rfc4034">RFC 4034</a>, March 2005.

   [<a id="ref-RFC4035">RFC4035</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, &quot;Protocol Modifications for the DNS Security
              Extensions&quot;, <a href="/doc/html/rfc4035">RFC 4035</a>, March 2005.

   [<a id="ref-RFC4592">RFC4592</a>]  Lewis, E., &quot;The Role of Wildcards in the Domain Name
              System&quot;, <a href="/doc/html/rfc4592">RFC 4592</a>, July 2006.

   [<a id="ref-RFC4648">RFC4648</a>]  Josefsson, S., &quot;The Base16, Base32, and Base64 Data
              Encodings&quot;, <a href="/doc/html/rfc4648">RFC 4648</a>, October 2006.

   [<a id="ref-RFC5155">RFC5155</a>]  Laurie, B., Sisson, G., Arends, R., and D. Blacka, &quot;DNS
              Security (DNSSEC) Hashed Authenticated Denial of
              Existence&quot;, <a href="/doc/html/rfc5155">RFC 5155</a>, March 2008.

   [<a id="ref-RFC6672">RFC6672</a>]  Rose, S. and W. Wijngaards, &quot;DNAME Redirection in the
              DNS&quot;, <a href="/doc/html/rfc6672">RFC 6672</a>, June 2012.

<span class="h3"><a class="selflink" id="section-8.2" href="#section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-DNSEXT-NSEC2">DNSEXT-NSEC2</a>]
              Laurie, B., &quot;DNSSEC NSEC2 Owner and RDATA Format&quot;, Work in
              Progress, October 2004.

   [<a id="ref-DNSEXT">DNSEXT</a>]   Josefsson, S., &quot;Authenticating denial of existence in DNS
              with minimum disclosure&quot;, Work in Progress, November 2000.





<span class="grey">Gieben &amp; Mekking              Informational                    [Page 26]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-27" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   [<a id="ref-DNSNR-RR">DNSNR-RR</a>] Arends, R., &quot;DNSSEC Non-Repudiation Resource Record&quot;, Work
   in Progress, June 2004.

   [<a id="ref-Err3441">Err3441</a>]  RFC Errata, Errata ID 3441, <a href="/doc/html/rfc5155">RFC 5155</a>,
   &lt;<a href="http://www.rfc-editor.org">http://www.rfc-editor.org</a>&gt;.

   [<a id="ref-RFC2535">RFC2535</a>]  Eastlake, D., &quot;Domain Name System Security Extensions&quot;,
   <a href="/doc/html/rfc2535">RFC 2535</a>, March 1999.

   [<a id="ref-RFC3655">RFC3655</a>]  Wellington, B. and O. Gudmundsson, &quot;Redefinition of DNS
   Authenticated Data (AD) bit&quot;, <a href="/doc/html/rfc3655">RFC 3655</a>, November 2003.

   [<a id="ref-RFC3755">RFC3755</a>]  Weiler, S., &quot;Legacy Resolver Compatibility for Delegation
   Signer (DS)&quot;, <a href="/doc/html/rfc3755">RFC 3755</a>, May 2004.

   [<a id="ref-RFC4470">RFC4470</a>]  Weiler, S. and J. Ihren, &quot;Minimally Covering NSEC Records
   and DNSSEC On-line Signing&quot;, <a href="/doc/html/rfc4470">RFC 4470</a>, April 2006.

   [<a id="ref-RFC4956">RFC4956</a>]  Arends, R., Kosters, M., and D. Blacka, &quot;DNS Security
   (DNSSEC) Opt-In&quot;, <a href="/doc/html/rfc4956">RFC 4956</a>, July 2007.

   [<a id="ref-Unbound">Unbound</a>]  NLnet Labs, &quot;Unbound: a validating, recursive, and caching
   DNS resolver&quot;, 2006, &lt;<a href="http://unbound.net">http://unbound.net</a>&gt;.

   [<a id="ref-phreebird">phreebird</a>]
              Kaminsky, D., &quot;Phreebird: a DNSSEC proxy&quot;, January 2011,
              &lt;<a href="http://dankaminsky.com/phreebird/">http://dankaminsky.com/phreebird/</a>&gt;.
























<span class="grey">Gieben &amp; Mekking              Informational                    [Page 27]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-28" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


<span class="h2"><a class="selflink" id="appendix-A" href="#appendix-A">Appendix A</a>.  Online Signing: Minimally Covering NSEC Records</span>

   An NSEC record lists the next existing name in a zone and thus makes
   it trivial to retrieve all the names from the zone.  This can also be
   done with NSEC3, but an adversary will then retrieve all the hashed
   names.  With DNSSEC online signing, zone walking can be prevented by
   faking the next owner name.

   To prevent retrieval of the next owner name with NSEC, a different,
   non-existing (according to the existence rules in <a href="/doc/html/rfc4592#section-2.2">[RFC4592],
   Section&nbsp;2.2</a>) name is used.  However, not just any name can be used
   because a validator may make assumptions about the size of the span
   the NSEC record covers.  The span must be large enough to cover the
   QNAME but not too large that it covers existing names.

   [<a id="ref-RFC4470">RFC4470</a>] introduces a scheme for generating minimally covering NSEC
   records.  These records use a next owner name that is lexically
   closer to the NSEC owner name than the actual next owner name,
   ensuring that no existing names are covered.  The next owner name can
   be derived from the QNAME with the use of so-called epsilon
   functions.

   For example, to deny the existence of &quot;b.example.org&quot; in the zone
   from <a href="#section-3.2">Section 3.2</a>, the following NSEC record could have been
   generated:

   a.example.org.      NSEC c.example.org. RRSIG NSEC

   This record also proves that &quot;b.example.org&quot; also does not exist, but
   an adversary _cannot_ use the next owner name in a zone-walking
   attack.  Note the type bitmap only has the RRSIG and NSEC set because
   [<a href="/doc/html/rfc4470" title="&quot;Minimally Covering NSEC Records and DNSSEC On-line Signing&quot;">RFC4470</a>] states:

      The generated NSEC record&#x27;s type bitmap MUST have the RRSIG and
      NSEC bits set and SHOULD NOT have any other bits set.

   This is because the NSEC records may appear at names that did not
   exist before the zone was signed.  In this case, however,
   &quot;a.example.org&quot; exists with other RR types, and we could have also
   set the A and TXT types in the bitmap.

   Because DNS ordering is very strict, the span should be shortened to
   a minimum.  In order to do so, the last character in the leftmost
   label of the NSEC owner name needs to be decremented, and the label
   must be filled with octets of value 255 until the label length
   reaches the maximum of 63 octets.  The next owner name is the QNAME
   with a leading label with a single null octet added.  This gives the
   following minimally covering record for &quot;b.example.org&quot;:



<span class="grey">Gieben &amp; Mekking              Informational                    [Page 28]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-29" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


   a\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255
    \255\255\255\255\255\255\255\255\255\255\255.example.org. (
      NSEC \000.b.example.org. RRSIG NSEC )

<span class="h2"><a class="selflink" id="appendix-B" href="#appendix-B">Appendix B</a>.  Online Signing: NSEC3 White Lies</span>

   The same principle of minimally covering spans can be applied to
   NSEC3 records.  This mechanism has been dubbed &quot;NSEC3 White Lies&quot;
   when it was implemented in Phreebird [<a href="#ref-phreebird">phreebird</a>].  Here, the NSEC3
   owner name is the hash of the QNAME minus one, and the next owner
   name is the hash of the QNAME plus one.

   The following NSEC3 white lie denies &quot;b.example.org&quot; (recall that
   this hashes to &quot;iuu8l5lmt76jeltp0bir3tmg4u3uu8e7&quot;):

   iuu8l5lmt76jeltp0bir3tmg4u3uu8e6.example.org. (
      NSEC3 1 0 2 DEAD IUU815LMT76JELTP0BIR3TMG4U3UU8E8 )

   The type bitmap is empty in this case.  If the hash of
   &quot;b.example.org&quot; - 1 is a collision with an existing name, the bitmap
   should have been filled with the RR types that exist at that name.
   This record actually denies the existence of the next closer name
   (which is conveniently &quot;b.example.org&quot;).  Of course, the NSEC3
   records to match the closest encloser and the one to deny the
   wildcard are still required.  These can be generated too:

   # Matching `example.org`: `15bg9l6359f5ch23e34ddua6n1rihl9h`
   15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
      NSEC3 1 0 2 DEAD 15BG9L6359F5CH23E34DDUA6N1RIHL9I NS SOA RRSIG
           DNSKEY NSEC3PARAM )

   # Covering `*.example.org`: `22670trplhsr72pqqmedltg1kdqeolb7`
   22670trplhsr72pqqmedltg1kdqeolb6.example.org.(
      NSEC3 1 0 2 DEAD 22670TRPLHSR72PQQMEDLTG1KDQEOLB8 )

<span class="h2"><a class="selflink" id="appendix-C" href="#appendix-C">Appendix C</a>.  List of Hashed Owner Names</span>

   The following owner names are used in this document.  The origin for
   these names is &quot;example.org&quot;.










<span class="grey">Gieben &amp; Mekking              Informational                    [Page 29]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-30" ></span>
<span class="grey"><a href="/doc/html/rfc7129">RFC 7129</a>               Authenticated Denial in DNS         February 2014</span>


         +----------------+-------------------------------------+
         | Original Name  | Hashed Name                         |
         +----------------+-------------------------------------+
         | &quot;a&quot;            | &quot;04sknapca5al7qos3km2l9tl3p5okq4c&quot;  |
         | &quot;1.h&quot;          | &quot;117gercprcjgg8j04ev1ndrk8d1jt14k&quot;  |
         | &quot;@&quot;            | &quot;15bg9l6359f5ch23e34ddua6n1rihl9h&quot;  |
         | &quot;h&quot;            | &quot;1avvqn74sg75ukfvf25dgcethgq638ek&quot;  |
         | &quot;*&quot;            | &quot;22670trplhsr72pqqmedltg1kdqeolb7&quot;  |
         | &quot;3&quot;            | &quot;75b9id679qqov6ldfhd8ocshsssb6jvq&quot;  |
         | &quot;2&quot;            | &quot;7t70drg4ekc28v93q7gnbleopa7vlp6q&quot;  |
         | &quot;3.3&quot;          | &quot;8555t7qegau7pjtksnbchg4td2m0jnpj&quot;  |
         | &quot;d&quot;            | &quot;a6edkb6v8vl5ol8jnqqlt74qmj7heb84&quot;  |
         | &quot;*.2&quot;          | &quot;fbq73bfkjlrkdoqs27k5qf81aqqd7hho&quot;  |
         | &quot;b&quot;            | &quot;iuu8l5lmt76jeltp0bir3tmg4u3uu8e7&quot;  |
         | &quot;x.2&quot;          | &quot;ndtu6dste50pr4a1f2qvr1v31g00i2i1&quot;  |
         +----------------+-------------------------------------+

        Table 1: Hashed Owner Names for &quot;example.org&quot; in Hash Order

Authors&#x27; Addresses

   R. (Miek) Gieben
   Google

   EMail: miek@google.com


   W. (Matthijs) Mekking
   NLnet Labs
   Science Park 400
   Amsterdam  1098 XH
   NL

   EMail: matthijs@nlnetlabs.nl
   URI:   <a href="http://www.nlnetlabs.nl/">http://www.nlnetlabs.nl/</a>
















Gieben &amp; Mekking              Informational                    [Page 30]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

