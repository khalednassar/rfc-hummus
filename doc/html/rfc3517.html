<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc3517
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.34.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.34.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-allman-tcp-sack/">
  <meta name="description" content="A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.34.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.34.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.34.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgbrown"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc3517.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc3517.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc3517.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc3517/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc3517/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/tsvwg/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-allman-tcp-sack@ietf.org?subject=draft-allman-tcp-sack" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-allman-tcp-sack-13.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-allman-tcp-sack-13.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-allman-tcp-sack-13.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-allman-tcp-sack-13">draft-allman-tcp-sack-13</a>                         Proposed Standard
Obsoleted by: <a href="/doc/html/rfc6675">6675</a>                                                      </pre>
      </div>
    

    <div class="draftcontent">
    <pre>Network Working Group                                         E. Blanton
Request for Comments: 3517                             Purdue University
Category: Standards Track                                      M. Allman
                                                            BBN/NASA GRC
                                                                 K. Fall
                                                          Intel Research
                                                                 L. Wang
                                                  University of Kentucky
                                                              April 2003


         <span class="h1">A Conservative Selective Acknowledgment (SACK)-based</span>
                    <span class="h1">Loss Recovery Algorithm for TCP</span>

Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   This document presents a conservative loss recovery algorithm for TCP
   that is based on the use of the selective acknowledgment (SACK) TCP
   option.  The algorithm presented in this document conforms to the
   spirit of the current congestion control specification (<a href="/doc/html/rfc2581">RFC 2581</a>),
   but allows TCP senders to recover more effectively when multiple
   segments are lost from a single flight of data.

Terminology

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>
   [<a href="/doc/html/rfc2119">RFC2119</a>].










<span class="grey">Blanton, et al.             Standards Track                     [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>   Introduction</span>

   This document presents a conservative loss recovery algorithm for TCP
   that is based on the use of the selective acknowledgment (SACK) TCP
   option.  While the TCP SACK [<a href="/doc/html/rfc2018">RFC2018</a>] is being steadily deployed in
   the Internet [<a href="#ref-All00">All00</a>], there is evidence that hosts are not using the
   SACK information when making retransmission and congestion control
   decisions [<a href="#ref-PF01">PF01</a>].  The goal of this document is to outline one
   straightforward method for TCP implementations to use SACK
   information to increase performance.

   [<a id="ref-RFC2581">RFC2581</a>] allows advanced loss recovery algorithms to be used by TCP
   [<a href="/doc/html/rfc793">RFC793</a>] provided that they follow the spirit of TCP&#x27;s congestion
   control algorithms [RFC2581, <a href="/doc/html/rfc2914">RFC2914</a>].  [<a href="/doc/html/rfc2582">RFC2582</a>] outlines one such
   advanced recovery algorithm called NewReno.  This document outlines a
   loss recovery algorithm that uses the SACK [<a href="/doc/html/rfc2018">RFC2018</a>] TCP option to
   enhance TCP&#x27;s loss recovery.  The algorithm outlined in this
   document, heavily based on the algorithm detailed in [<a href="#ref-FF96">FF96</a>], is a
   conservative replacement of the fast recovery algorithm [Jac90,
   <a href="/doc/html/rfc2581">RFC2581</a>].  The algorithm specified in this document is a
   straightforward SACK-based loss recovery strategy that follows the
   guidelines set in [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>] and can safely be used in TCP
   implementations.  Alternate SACK-based loss recovery methods can be
   used in TCP as implementers see fit (as long as the alternate
   algorithms follow the guidelines provided in [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>]).  Please
   note, however, that the SACK-based decisions in this document (such
   as what segments are to be sent at what time) are largely decoupled
   from the congestion control algorithms, and as such can be treated as
   separate issues if so desired.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>   Definitions</span>

   The reader is expected to be familiar with the definitions given in
   [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>].

   The reader is assumed to be familiar with selective acknowledgments
   as specified in [<a href="/doc/html/rfc2018">RFC2018</a>].

   For the purposes of explaining the SACK-based loss recovery algorithm
   we define four variables that a TCP sender stores:

      &quot;HighACK&quot; is the sequence number of the highest byte of data that
      has been cumulatively ACKed at a given point.

      &quot;HighData&quot; is the highest sequence number transmitted at a given
      point.





<span class="grey">Blanton, et al.             Standards Track                     [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


      &quot;HighRxt&quot; is the highest sequence number which has been
      retransmitted during the current loss recovery phase.

      &quot;Pipe&quot; is a sender&#x27;s estimate of the number of bytes outstanding
      in the network.  This is used during recovery for limiting the
      sender&#x27;s sending rate.  The pipe variable allows TCP to use a
      fundamentally different congestion control than specified in
      [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>].  The algorithm is often referred to as the &quot;pipe
      algorithm&quot;.

   For the purposes of this specification we define a &quot;duplicate
   acknowledgment&quot; as a segment that arrives with no data and an
   acknowledgment (ACK) number that is equal to the current value of
   HighACK, as described in [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>].

   We define a variable &quot;DupThresh&quot; that holds the number of duplicate
   acknowledgments required to trigger a retransmission.  Per [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>]
   this threshold is defined to be 3 duplicate acknowledgments.
   However, implementers should consult any updates to [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>] to
   determine the current value for DupThresh (or method for determining
   its value).

   Finally, a range of sequence numbers [A,B] is said to &quot;cover&quot;
   sequence number S if A &lt;= S &lt;= B.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>   Keeping Track of SACK Information</span>

   For a TCP sender to implement the algorithm defined in the next
   section it must keep a data structure to store incoming selective
   acknowledgment information on a per connection basis.  Such a data
   structure is commonly called the &quot;scoreboard&quot;.  The specifics of the
   scoreboard data structure are out of scope for this document (as long
   as the implementation can perform all functions required by this
   specification).

   Note that this document refers to keeping account of (marking)
   individual octets of data transferred across a TCP connection.  A
   real-world implementation of the scoreboard would likely prefer to
   manage this data as sequence number ranges.  The algorithms presented
   here allow this, but require arbitrary sequence number ranges to be
   marked as having been selectively acknowledged.










<span class="grey">Blanton, et al.             Standards Track                     [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>   Processing and Acting Upon SACK Information</span>

   For the purposes of the algorithm defined in this document the
   scoreboard SHOULD implement the following functions:

   Update ():

      Given the information provided in an ACK, each octet that is
      cumulatively ACKed or SACKed should be marked accordingly in the
      scoreboard data structure, and the total number of octets SACKed
      should be recorded.

      Note: SACK information is advisory and therefore SACKed data MUST
      NOT be removed from TCP&#x27;s retransmission buffer until the data is
      cumulatively acknowledged [<a href="/doc/html/rfc2018">RFC2018</a>].

   IsLost (SeqNum):

      This routine returns whether the given sequence number is
      considered to be lost.  The routine returns true when either
      DupThresh discontiguous SACKed sequences have arrived above
      &#x27;SeqNum&#x27; or (DupThresh * SMSS) bytes with sequence numbers greater
      than &#x27;SeqNum&#x27; have been SACKed.  Otherwise, the routine returns
      false.

   SetPipe ():

      This routine traverses the sequence space from HighACK to HighData
      and MUST set the &quot;pipe&quot; variable to an estimate of the number of
      octets that are currently in transit between the TCP sender and
      the TCP receiver.  After initializing pipe to zero the following
      steps are taken for each octet &#x27;S1&#x27; in the sequence space between
      HighACK and HighData that has not been SACKed:

      (a) If IsLost (S1) returns false:

         Pipe is incremented by 1 octet.

         The effect of this condition is that pipe is incremented for
         packets that have not been SACKed and have not been determined
         to have been lost (i.e., those segments that are still assumed
         to be in the network).

      (b) If S1 &lt;= HighRxt:

         Pipe is incremented by 1 octet.





<span class="grey">Blanton, et al.             Standards Track                     [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


         The effect of this condition is that pipe is incremented for
         the retransmission of the octet.

      Note that octets retransmitted without being considered lost are
      counted twice by the above mechanism.

   NextSeg ():

      This routine uses the scoreboard data structure maintained by the
      Update() function to determine what to transmit based on the SACK
      information that has arrived from the data receiver (and hence
      been marked in the scoreboard).  NextSeg () MUST return the
      sequence number range of the next segment that is to be
      transmitted, per the following rules:

      (1) If there exists a smallest unSACKed sequence number &#x27;S2&#x27; that
          meets the following three criteria for determining loss, the
          sequence range of one segment of up to SMSS octets starting
          with S2 MUST be returned.

          (1.a) S2 is greater than HighRxt.

          (1.b) S2 is less than the highest octet covered by any
                received SACK.

          (1.c) IsLost (S2) returns true.

      (2) If no sequence number &#x27;S2&#x27; per rule (1) exists but there
          exists available unsent data and the receiver&#x27;s advertised
          window allows, the sequence range of one segment of up to SMSS
          octets of previously unsent data starting with sequence number
          HighData+1 MUST be returned.

      (3) If the conditions for rules (1) and (2) fail, but there exists
          an unSACKed sequence number &#x27;S3&#x27; that meets the criteria for
          detecting loss given in steps (1.a) and (1.b) above
          (specifically excluding step (1.c)) then one segment of up to
          SMSS octets starting with S3 MAY be returned.

          Note that rule (3) is a sort of retransmission &quot;last resort&quot;.
          It allows for retransmission of sequence numbers even when the
          sender has less certainty a segment has been lost than as with
          rule (1).  Retransmitting segments via rule (3) will help
          sustain TCP&#x27;s ACK clock and therefore can potentially help
          avoid retransmission timeouts.  However, in sending these
          segments the sender has two copies of the same data considered
          to be in the network (and also in the Pipe estimate).  When an
          ACK or SACK arrives covering this retransmitted segment, the



<span class="grey">Blanton, et al.             Standards Track                     [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


          sender cannot be sure exactly how much data left the network
          (one of the two transmissions of the packet or both
          transmissions of the packet).  Therefore the sender may
          underestimate Pipe by considering both segments to have left
          the network when it is possible that only one of the two has.

          We believe that the triggering of rule (3) will be rare and
          that the implications are likely limited to corner cases
          relative to the entire recovery algorithm.  Therefore we leave
          the decision of whether or not to use rule (3) to
          implementors.

      (4) If the conditions for each of (1), (2), and (3) are not met,
          then NextSeg () MUST indicate failure, and no segment is
          returned.

   Note: The SACK-based loss recovery algorithm outlined in this
   document requires more computational resources than previous TCP loss
   recovery strategies.  However, we believe the scoreboard data
   structure can be implemented in a reasonably efficient manner (both
   in terms of computation complexity and memory usage) in most TCP
   implementations.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>   Algorithm Details</span>

   Upon the receipt of any ACK containing SACK information, the
   scoreboard MUST be updated via the Update () routine.

   Upon the receipt of the first (DupThresh - 1) duplicate ACKs, the
   scoreboard is to be updated as normal.  Note: The first and second
   duplicate ACKs can also be used to trigger the transmission of
   previously unsent segments using the Limited Transmit algorithm
   [<a href="/doc/html/rfc3042">RFC3042</a>].

   When a TCP sender receives the duplicate ACK corresponding to
   DupThresh ACKs, the scoreboard MUST be updated with the new SACK
   information (via Update ()).  If no previous loss event has occurred
   on the connection or the cumulative acknowledgment point is beyond
   the last value of RecoveryPoint, a loss recovery phase SHOULD be
   initiated, per the fast retransmit algorithm outlined in [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>].
   The following steps MUST be taken:

   (1) RecoveryPoint = HighData

       When the TCP sender receives a cumulative ACK for this data octet
       the loss recovery phase is terminated.





<span class="grey">Blanton, et al.             Standards Track                     [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


   (2) ssthresh = cwnd = (FlightSize / 2)

       The congestion window (cwnd) and slow start threshold (ssthresh)
       are reduced to half of FlightSize per [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>].

   (3) Retransmit the first data segment presumed dropped -- the segment
       starting with sequence number HighACK + 1.  To prevent repeated
       retransmission of the same data, set HighRxt to the highest
       sequence number in the retransmitted segment.

   (4) Run SetPipe ()

       Set a &quot;pipe&quot; variable  to the number of outstanding octets
       currently &quot;in the pipe&quot;; this is the data which has been sent by
       the TCP sender but for which no cumulative or selective
       acknowledgment has been received and the data has not been
       determined to have been dropped in the network.  It is assumed
       that the data is still traversing the network path.

   (5) In order to take advantage of potential additional available
       cwnd, proceed to step (C) below.

   Once a TCP is in the loss recovery phase the following procedure MUST
   be used for each arriving ACK:

   (A) An incoming cumulative ACK for a sequence number greater than
       RecoveryPoint signals the end of loss recovery and the loss
       recovery phase MUST be terminated.  Any information contained in
       the scoreboard for sequence numbers greater than the new value of
       HighACK SHOULD NOT be cleared when leaving the loss recovery
       phase.

   (B) Upon receipt of an ACK that does not cover RecoveryPoint the
       following actions MUST be taken:

       (B.1) Use Update () to record the new SACK information conveyed
       by the incoming ACK.

       (B.2) Use SetPipe () to re-calculate the number of octets still
       in the network.

   (C) If cwnd - pipe &gt;= 1 SMSS the sender SHOULD transmit one or more
       segments as follows:

       (C.1) The scoreboard MUST be queried via NextSeg () for the
       sequence number range of the next segment to transmit (if any),





<span class="grey">Blanton, et al.             Standards Track                     [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


       and the given segment sent.  If NextSeg () returns failure (no
       data to send) return without sending anything (i.e., terminate
       steps C.1 -- C.5).

       (C.2) If any of the data octets sent in (C.1) are below HighData,
       HighRxt MUST be set to the highest sequence number of the
       retransmitted segment.

       (C.3) If any of the data octets sent in (C.1) are above HighData,
       HighData must be updated to reflect the transmission of
       previously unsent data.

       (C.4) The estimate of the amount of data outstanding in the
       network must be updated by incrementing pipe by the number of
       octets transmitted in (C.1).

       (C.5) If cwnd - pipe &gt;= 1 SMSS, return to (C.1)

<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a> Retransmission Timeouts</span>

   In order to avoid memory deadlocks, the TCP receiver is allowed to
   discard data that has already been selectively acknowledged.  As a
   result, [<a href="/doc/html/rfc2018">RFC2018</a>] suggests that a TCP sender SHOULD expunge the SACK
   information gathered from a receiver upon a retransmission timeout
   &quot;since the timeout might indicate that the data receiver has
   reneged.&quot;  Additionally, a TCP sender MUST &quot;ignore prior SACK
   information in determining which data to retransmit.&quot;  However, a
   SACK TCP sender SHOULD still use all SACK information made available
   during the slow start phase of loss recovery following an RTO.

   If an RTO occurs during loss recovery as specified in this document,
   RecoveryPoint MUST be set to HighData.  Further, the new value of
   RecoveryPoint MUST be preserved and the loss recovery algorithm
   outlined in this document MUST be terminated.  In addition, a new
   recovery phase (as described in <a href="#section-5">section 5</a>) MUST NOT be initiated
   until HighACK is greater than or equal to the new value of
   RecoveryPoint.

   As described in Sections <a href="#section-4">4</a> and <a href="#section-5">5</a>, Update () SHOULD continue to be
   used appropriately upon receipt of ACKs.  This will allow the slow
   start recovery period to benefit from all available information
   provided by the receiver, despite the fact that SACK information was
   expunged due to the RTO.

   If there are segments missing from the receiver&#x27;s buffer following
   processing of the retransmitted segment, the corresponding ACK will
   contain SACK information.  In this case, a TCP sender SHOULD use this
   SACK information when determining what data should be sent in each



<span class="grey">Blanton, et al.             Standards Track                     [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


   segment of the slow start.  The exact algorithm for this selection is
   not specified in this document (specifically NextSeg () is
   inappropriate during slow start after an RTO).  A relatively
   straightforward approach to &quot;filling in&quot; the sequence space reported
   as missing should be a reasonable approach.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>   Managing the RTO Timer</span>

   The standard TCP RTO estimator is defined in [<a href="/doc/html/rfc2988">RFC2988</a>].  Due to the
   fact that the SACK algorithm in this document can have an impact on
   the behavior of the estimator, implementers may wish to consider how
   the timer is managed.  [<a href="/doc/html/rfc2988">RFC2988</a>] calls for the RTO timer to be
   re-armed each time an ACK arrives that advances the cumulative ACK
   point.  Because the algorithm presented in this document can keep the
   ACK clock going through a fairly significant loss event,
   (comparatively longer than the algorithm described in [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>]), on
   some networks the loss event could last longer than the RTO.  In this
   case the RTO timer would expire prematurely and a segment that need
   not be retransmitted would be resent.

   Therefore we give implementers the latitude to use the standard
   [<a href="/doc/html/rfc2988">RFC2988</a>] style RTO management or, optionally, a more careful variant
   that re-arms the RTO timer on each retransmission that is sent during
   recovery MAY be used.  This provides a more conservative timer than
   specified in [<a href="/doc/html/rfc2988">RFC2988</a>], and so may not always be an attractive
   alternative.  However, in some cases it may prevent needless
   retransmissions, go-back-N transmission and further reduction of the
   congestion window.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>   Research</span>

   The algorithm specified in this document is analyzed in [<a href="#ref-FF96">FF96</a>], which
   shows that the above algorithm is effective in reducing transfer time
   over standard TCP Reno [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>] when multiple segments are dropped
   from a window of data (especially as the number of drops increases).
   [<a href="#ref-AHKO97">AHKO97</a>] shows that the algorithm defined in this document can
   greatly improve throughput in connections traversing satellite
   channels.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>   Security Considerations</span>

   The algorithm presented in this paper shares security considerations
   with [<a href="/doc/html/rfc2581" title="heavily based on the algorithm detailed in [FF96">RFC2581</a>].  A key difference is that an algorithm based on SACKs
   is more robust against attackers forging duplicate ACKs to force the
   TCP sender to reduce cwnd.  With SACKs, TCP senders have an
   additional check on whether or not a particular ACK is legitimate.
   While not fool-proof, SACK does provide some amount of protection in
   this area.



<span class="grey">Blanton, et al.             Standards Track                     [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


Acknowledgments

   The authors wish to thank Sally Floyd for encouraging this document
   and commenting on early drafts.  The algorithm described in this
   document is loosely based on an algorithm outlined by Kevin Fall and
   Sally Floyd in [<a href="#ref-FF96">FF96</a>], although the authors of this document assume
   responsibility for any mistakes in the above text.  Murali Bashyam,
   Ken Calvert, Tom Henderson, Reiner Ludwig, Jamshid Mahdavi, Matt
   Mathis, Shawn Ostermann, Vern Paxson and Venkat Venkatsubra provided
   valuable feedback on earlier versions of this document.  We thank
   Matt Mathis and Jamshid Mahdavi for implementing the scoreboard in ns
   and hence guiding our thinking in keeping track of SACK state.

   The first author would like to thank Ohio University and the Ohio
   University Internetworking Research Group for supporting the bulk of
   his work on this project.

Normative References

   [<a id="ref-RFC793">RFC793</a>]  Postel, J., &quot;Transmission Control Protocol&quot;, STD 7, <a href="/doc/html/rfc793">RFC</a>
             <a href="/doc/html/rfc793">793</a>, September 1981.

   [<a id="ref-RFC2018">RFC2018</a>] Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, &quot;TCP
             Selective Acknowledgment Options&quot;, <a href="/doc/html/rfc2018">RFC 2018</a>, October 1996.

   [<a id="ref-RFC2026">RFC2026</a>] Bradner, S., &quot;The Internet Standards Process -- Revision
             3&quot;, <a href="/doc/html/bcp9">BCP 9</a>, <a href="/doc/html/rfc2026">RFC 2026</a>, October 1996.

   [<a id="ref-RFC2119">RFC2119</a>] Bradner, S., &quot;Key words for use in RFCs to Indicate
             Requirement Levels&quot;, <a href="/doc/html/bcp14">BCP 14</a>, <a href="/doc/html/rfc2119">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2581">RFC2581</a>] Allman, M., Paxson, V. and R. Stevens, &quot;TCP Congestion
             Control&quot;, <a href="/doc/html/rfc2581">RFC 2581</a>, April 1999.

Informative References

   [<a id="ref-AHKO97">AHKO97</a>]  Mark Allman, Chris Hayes, Hans Kruse, Shawn Ostermann.  TCP
             Performance Over Satellite Links.  Proceedings of the Fifth
             International Conference on Telecommunications Systems,
             Nashville, TN, March, 1997.

   [<a id="ref-All00">All00</a>]   Mark Allman.  A Web Server&#x27;s View of the Transport Layer.
             ACM Computer Communication Review, 30(5), October 2000.

   [<a id="ref-FF96">FF96</a>]    Kevin Fall and Sally Floyd.  Simulation-based Comparisons
             of Tahoe, Reno and SACK TCP.  Computer Communication
             Review, July 1996.




<span class="grey">Blanton, et al.             Standards Track                    [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


   [<a id="ref-Jac90">Jac90</a>]   Van Jacobson.  Modified TCP Congestion Avoidance Algorithm.
             Technical Report, LBL, April 1990.

   [<a id="ref-PF01">PF01</a>]    Jitendra Padhye, Sally Floyd.  Identifying the TCP Behavior
             of Web Servers, ACM SIGCOMM, August 2001.

   [<a id="ref-RFC2582">RFC2582</a>] Floyd, S. and T. Henderson, &quot;The NewReno Modification to
             TCP&#x27;s Fast Recovery Algorithm&quot;, <a href="/doc/html/rfc2582">RFC 2582</a>, April 1999.

   [<a id="ref-RFC2914">RFC2914</a>] Floyd, S., &quot;Congestion Control Principles&quot;, <a href="/doc/html/bcp41">BCP 41</a>, <a href="/doc/html/rfc2914">RFC</a>
             <a href="/doc/html/rfc2914">2914</a>, September 2000.

   [<a id="ref-RFC2988">RFC2988</a>] Paxson, V. and M. Allman, &quot;Computing TCP&#x27;s Retransmission
             Timer&quot;, <a href="/doc/html/rfc2988">RFC 2988</a>, November 2000.

   [<a id="ref-RFC3042">RFC3042</a>] Allman, M., Balakrishnan, H, and S. Floyd, &quot;Enhancing TCP&#x27;s
             Loss Recovery Using Limited Transmit&quot;, <a href="/doc/html/rfc3042">RFC 3042</a>, January
             2001.

Intellectual Property Rights Notice

   The IETF takes no position regarding the validity or scope of any
   intellectual property or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; neither does it represent that it
   has made any effort to identify any such rights.  Information on the
   IETF&#x27;s procedures with respect to rights in standards-track and
   standards-related documentation can be found in <a href="/doc/html/bcp11">BCP-11</a>.  Copies of
   claims of rights made available for publication and any assurances of
   licenses to be made available, or the result of an attempt made to
   obtain a general license or permission for the use of such
   proprietary rights by implementors or users of this specification can
   be obtained from the IETF Secretariat.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights which may cover technology that may be required to practice
   this standard.  Please address the information to the IETF Executive
   Director.











<span class="grey">Blanton, et al.             Standards Track                    [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


Authors&#x27; Addresses

   Ethan Blanton
   Purdue University Computer Sciences
   1398 Computer Science Building
   West Lafayette, IN  47907

   EMail: eblanton@cs.purdue.edu


   Mark Allman
   BBN Technologies/NASA Glenn Research Center
   Lewis Field
   21000 Brookpark Rd.  MS 54-5
   Cleveland, OH  44135

   Phone: 216-433-6586
   Fax: 216-433-8705
   EMail: mallman@bbn.com
   <a href="http://roland.grc.nasa.gov/~mallman">http://roland.grc.nasa.gov/~mallman</a>


   Kevin Fall
   Intel Research
   2150 Shattuck Ave., PH Suite
   Berkeley, CA 94704

   EMail: kfall@intel-research.net


   Lili Wang
   Laboratory for Advanced Networking
   210 Hardymon Building
   University of Kentucky
   Lexington, KY 40506-0495

   EMail: lwang0@uky.edu














<span class="grey">Blanton, et al.             Standards Track                    [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey"><a href="/doc/html/rfc3517">RFC 3517</a>            SACK-based Loss Recovery for TCP          April 2003</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   &quot;AS IS&quot; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Blanton, et al.             Standards Track                    [Page 13]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

