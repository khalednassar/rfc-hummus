<!DOCTYPE html> 

<!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/htmlized_base.html -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>
  
    rfc2588
  
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

  @media only screen 
    and (min-width: 992px)
    and (max-width: 1199px) {
      body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 768px)
    and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-width: 480px)
    and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
  @media only screen 
    and (min-device-width : 375px) 
    and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
  @media only screen 
    and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
      font-weight: bold;
            /* line-height: 0pt; */
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
      font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
  .pre {
      white-space: pre;
      font-family: monospace;
  }
  .header{
      font-weight: bold;
  }
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        @media print {
            body {
                margin-top: 5em;
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
  @media screen {
      .grey, .grey a:link, .grey a:visited {
    color: #777;
      }
            .meta-info {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .pad {
                padding-top: 7px;
                line-height: 24px;
                padding-bottom: 4px;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
  }
    
     

.bgwhite  { background-color: white; }
.bgred    { background-color: #F44; }
.bggrey   { background-color: #666; }
.bgbrown  { background-color: #840; }            
.bgorange { background-color: #FA0; }
.bgyellow { background-color: #EE0; }
.bgmagenta{ background-color: #F4F; }
.bgblue   { background-color: #66F; }
.bgcyan   { background-color: #4DD; }
.bggreen  { background-color: #4F4; }

.draftcontent { margin-top:0px !important;}


    </style>

    <!--[if lt IE 9]>
        <script src="https://www.ietf.org/lib/dt/7.33.0/html5shiv/html5shiv.min.js"></script>
        <script src="https://www.ietf.org/lib/dt/7.33.0/respond/dest/respond.min.js"></script>
    <![endif]-->
    
  <link rel="alternate" type="application/atom+xml" title="Document changes" href="/feed/document-changes/draft-ietf-mboned-mcast-firewall/">
  <meta name="description" content="IP Multicast and Firewalls (RFC )">
  <script src="https://www.ietf.org/lib/dt/7.33.0/d3/d3.min.js"></script>
  <script src="https://www.ietf.org/lib/dt/7.33.0/jquery/jquery.min.js"></script>


    
    <link rel="shortcut icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/ietf-icon-blue3.png">
    
    <link rel="apple-touch-icon" href="https://www.ietf.org/lib/dt/7.33.0/ietf/images/apple-touch-icon.png">
  </head>

  <body style="padding-top: 0;">

	  <div class="content" id="content">
        
  <!-- template: /a/www/ietf-datatracker/web/ietf/templates/doc/document_html.html -->
 
  <div class="rfcmarkup">
    <div class="noprint" style="height: 6px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showLegend();"
         onmouseout="hideLegend()"
         style="height: 6px; min-height: 6px; width: 96ex; position: absolute; margin-top:0; "
         class="meta-info bgorange"
         title="Click for colour legend." >&nbsp;</div>
      <div id="legend"
           class="meta-info noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showLegend();"
           onmouseout="hideLegend();">
      </div>
    </div>

    
      <div class="noprint">
	 <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.rfc-editor.org/rfc/rfc2588.txt" title="Plaintext version of this document">txt</a>|<a href="https://www.rfc-editor.org/rfc/rfc2588.html" title="HTML version of this document, from XML2RFC">html</a>|<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc2588.txt.pdf" title="PDF version of this document">pdf</a>|<a href="/doc/rfc2588/bibtex" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/rfc2588/" title="Datatracker information for this document">Tracker</a>] [<a href="/group/mboned/" title="The working group handling this document">WG</a>] [<a href="mailto:draft-ietf-mboned-mcast-firewall@ietf.org?subject=draft-ietf-mboned-mcast-firewall" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-mboned-mcast-firewall-02.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-ietf-mboned-mcast-firewall-02.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-ietf-mboned-mcast-firewall-02.txt" title="Run an idnits check of this document">Nits</a>]

From: <a href="/doc/html/draft-ietf-mboned-mcast-firewall-02">draft-ietf-mboned-mcast-firewall-02</a>                  Informational</pre>
      </div>
    

    <div class="draftcontent">
    <pre>Network Working Group                                      R. Finlayson
Request for Comments: 2588                                     LIVE.COM
Category: Informational                                        May 1999


                       <span class="h1">IP Multicast and Firewalls</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>. Abstract</span>

   Many organizations use a firewall computer that acts as a security
   gateway between the public Internet and their private, internal
   &#x27;intranet&#x27;.  In this document, we discuss the issues surrounding the
   traversal of IP multicast traffic across a firewall, and describe
   possible ways in which a firewall can implement and control this
   traversal.  We also explain why some firewall mechanisms - such as
   SOCKS - that were designed specifically for unicast traffic, are less
   appropriate for multicast.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>. Introduction</span>

   A firewall is a security gateway that controls access between a
   private adminstrative domain (an &#x27;intranet&#x27;) and the public Internet.
   This document discusses how a firewall handles IP multicast [<a href="#ref-1" title="&quot;Host Extensions for IP Multicasting&quot;">1</a>]
   traffic.

   We assume that the external side of the firewall (on the Internet)
   has access to IP multicast - i.e., is on the public &quot;Multicast
   Internet&quot; (aka. &quot;MBone&quot;), or perhaps some other multicast network.

   We also assume that the *internal* network (i.e., intranet) supports
   IP multicast routing.  This is practical, because intranets tend to
   be centrally administered.  (Also, many corporate intranets already
   use multicast internally - for training, meetings, or corporate
   announcements.)  In contrast, some previously proposed firewall
   mechanisms for multicast (e.g., [<a href="#ref-2" title="&quot;An MBone Proxy for an Application Gateway Firewall&quot;">2</a>]) have worked by sending *unicast*
   packets within the intranet.  Such mechanisms are usually
   inappropriate, because they scale poorly and can cause excessive
   network traffic within the intranet.  Instead, it is better to rely



<span class="grey">Finlayson                    Informational                      [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


   upon the existing IP multicast routing/delivery mechanism, rather
   than trying to replace it with unicast.

   This document addresses scenarios where a multicast session is
   carried - via multicast - on both sides of the firewall.  For
   instance, (i) a particular public MBone session may be relayed onto
   the intranet (e.g., for the benefit of employees), or (ii) a special
   internal communication (e.g., announcing a new product) may be
   relayed onto the public MBone.  In contrast, we do not address the
   case of a roaming user - outside the firewall - who wishes to access
   a private internal multicast session, using a virtual private
   network.  (Such &quot;road warrior&quot; scenarios are outside the scope of
   this document.)

   As noted by Freed and Carosso [<a href="#ref-3" title="&quot;An Internet Firewall Transparency Requirement&quot;">3</a>], a firewall can act in two
   different ways:

      1/ As a &quot;protocol end point&quot;.  In this case, no internal node
         (other than the firewall) is directly accessible from the
         external Internet, and no external node (other than the
         firewall) is directly accessible from within the intranet.
         Such firewalls are also known as &quot;application-level gateways&quot;.
      2/ As a &quot;packet filter&quot;.  In this case, internal and external
         nodes are visible to each other at the IP level, but the
         firewall filters out (i.e., blocks passage of) certain packets,
         based on their header or contents.

   In the remainder of this document, we assume the first type of
   firewall, as it is the most restrictive, and generally provides the
   most security.  For multicast, this means that:

      (i)  A multicast packet that&#x27;s sent over the Internet will never
           be seen on the intranet (and vice versa), unless such packets
           are explicitly relayed by the firewall, and
      (ii) The IP source address of a relayed multicast packet will be
           that of the firewall, not that of the packet&#x27;s original
           sender.  To work correctly, the applications and protocols
           being used must take this into account.  (Fortunately, most
           modern multicast-based protocols - for instance, RTP [<a href="#ref-4" title="&quot;RTP: A Transport Protocol for Real-Time Applications&quot;">4</a>] -
           are designed with such relaying in mind.)

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>. Why Multicast is Different</span>

   When considering the security implications of IP multicast, it is
   important to note the fundamental way in which multicast
   communication differs from unicast.





<span class="grey">Finlayson                    Informational                      [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


   Unicast communication consists of a &#x27;conversation&#x27; between an
   explicit pair of participants.  It therefore makes sense for the
   security of unicast communication to be based upon these participants
   (e.g., by authenticating each participant).  Furthermore, &#x27;trust&#x27;
   within unicast communication can be based upon trust in each
   participant, as well as upon trust in the data.

   Multicast communication, on the other hand, involves a arbitrary
   sized, potentially varying set of participants, whose membership
   might never be fully known.  (This is a feature, not a bug!)  Because
   of this, the security of multicast communication is based not upon
   its participants, but instead, upon its *data*.  In particular,
   multicast communication is authenticated by authenticating packet
   data - e.g., using digital signatures - and privacy is obtained by
   encrypting this data.  And &#x27;trust&#x27; within multicast communication is
   based solely upon trust in the data.

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>. Multicast-Related Threats and Countermeasures</span>

   The primary threat arising from relaying multicast across a firewall
   is therefore &quot;bad data&quot; - in particular:

      (i)  damaging data flowing from the Internet onto the intranet, or
      (ii) sensitive data inadvertently flowing from the intranet onto
           the external Internet.

   To avert this threat, the intranet&#x27;s security administrator must
   establish, in advance, a security policy that decides:

      (i)  Which multicast groups (and corresponding UDP ports) contain
           data that can safely be relayed from the Internet onto the
           intranet.  For example, the security administrator might
           choose to permit the relaying of an MBone lecture, knowing
           that the data consists only of audio/video (&amp; to safe ports).
      (ii) Which multicast groups (and corresponding UDP ports) will not
           contain sensitive internal information (that should therefore
           not be relayed from the intranet onto the Internet).  This,
           of course, requires placing trust in the applications that
           internal users will use to participate in these groups.  For
           example, if users use an audio/video &#x27;viewer&#x27; program to
           participate in an MBone session, then this program must be
           trusted not to be a &quot;Trojan Horse&quot;.  (This requirement for
           &quot;trusted applications&quot; is by no means specific to multicast,
           of course.)

   Once such a security policy has been established, it is then the job
   of the firewall to implement this policy.




<span class="grey">Finlayson                    Informational                      [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>. What Firewalls Need to Do</span>

   In short, a firewall must do three things in order to handle
   multicast:

      1/ Support the chosen multicast security policy (which establishes
         particular multicast groups as being candidates to be relayed),
      2/ Determine (dynamically) when each candidate group should be
         relayed, and
      3/ Relay each candidate group&#x27;s data across the firewall (and then
         re-multicast it at the far end).

   These three tasks are described in more detail in the next three
   sections.

   Note that because a firewall is often a convenient place to
   centralize the administration of the intranet, some firewalls might
   also perform additional administrative functions - for example,
   auditing, accounting, and resource monitoring.  These additional
   functions, however, are outside the scope of this document, because
   they are not specifically *firewall*-related.  They are equally
   applicable to an administrative domain that is not firewalled.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>. Supporting a Multicast Security Policy</span>

   As noted above, a multicast security policy consists of specifying
   the set of allowed multicast groups (&amp; corresponding UDP ports) that
   are candidates to be relayed across the firewall.  There are three
   basic ways in which a firewall can support such a policy:

      1/ Static configuration.  The firewall could be configured, in
         advance, with the set of candidate groups/ports - for example,
         in a configuration file.
      2/ Explicit dynamic configuration.  The set of candidate
         groups/ports could be set (and updated) dynamically, based upon
         an explicit request from one or more trusted clients
         (presumably internal).  For example, the firewall could contain
         a &#x27;remote control&#x27; mechanism that allows these trusted clients
         - upon authentication - to update the set of candidate
         groups/ports.
      3/ Implicit dynamic configuration.  The set of candidate
         groups/ports could be determined implicitly, based upon the
         contents of some pre-authorized multicast group/port, such as a
         &quot;session directory&quot;.  Suppose, for example, that the security
         policy decides that the default MBone SAP/SDP session directory
         [<a href="#ref-5" title="&quot;SDP: Session Description Protocol&quot;">5</a>] may be relayed, as well as any sessions that are announced
         in this directory.  A &#x27;watcher&#x27; process, associated with the
         firewall, would watch this directory, and use its contents to



<span class="grey">Finlayson                    Informational                      [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


         dynamically update the set of candidates.

   Notes:

      (i)   Certain ranges of multicast addresses are defined to be
            &quot;administratively scoped&quot; [<a href="#ref-6" title="&quot;Administratively Scoped IP Multicast&quot;">6</a>].  Even though the firewall
            does not act as a true multicast router, the multicast
            security policy should set up and respect administrative
            scope boundaries.
      (ii)  As noted in [<a href="#ref-2" title="&quot;An MBone Proxy for an Application Gateway Firewall&quot;">2</a>], certain privileged UDP ports may be
            considered dangerous, even with multicast.  The multicast
            security policy should check that such ports do not become
            candidates for relaying.
      (iii) Even if sessions announced in a session directory are
            considered automatic candidates for relaying (i.e., case 3/
            above), the firewall&#x27;s &#x27;watcher&#x27; process should still
            perform some checks on incoming announcements.  In
            particular, it should ensure that each session&#x27;s &#x27;group&#x27;
            address really is a multicast address, and (as noted above)
            it should also check that the port number is within a safe
            range.  Depending on the security policy, it may also wish
            to prevent any *locally* created session announcements from
            becoming candidates (or being relayed).

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>. Determining When to Relay Candidate Groups</span>

   If a multicast group becomes a candidate to be relayed across the
   firewall, the actual relaying should *not* be done continually, but
   instead should be done only when there is actual interest in having
   this group relayed.  The reason for this is two-fold.  First,
   relaying a multicast group requires that one or both sides of the
   firewall join the group; this establishes multicast routing state
   within the network.  This is inefficient if there is no current
   interest in having the group relayed (especially for
   Internet-&gt;intranet relaying).  Second, the act of relaying an
   unwanted multicast group consumes unnecessary resources in the
   firewall itself.

   The best way for the firewall to determine when a candidate group
   should be relayed is for it to use actual multicast routing
   information, thereby acting much as if it were a real &#x27;inter-domain&#x27;
   multicast router.  If the intranet consists of a single subnet only,
   then the firewall could listen to IGMP requests to learn when a
   candidate group has been joined by a node on this subnet.  If,
   however, the intranet consists of more than one subnet, then the
   firewall can learn about candidate group memberships by listening to
   &quot;Domain Wide Multicast Group Membership Reports&quot; [<a href="#ref-7" title="&quot;Domain Wide Multicast Group Membership Reports&quot;">7</a>].  Unfortunately,
   this mechanism has only recently been defined, and is not yet used by



<span class="grey">Finlayson                    Informational                      [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


   most routers.

   Another, albeit less desirable, way for the firewall to learn when
   candidate multicast groups have been joined is for the firewall to
   periodically &#x27;probe&#x27; each of these groups.  Such a probe can be
   performed by sending an ICMP ECHO request packet to the group, and
   listening for a response (with some timeout interval).  This probing
   scheme is practical provided that the set of candidate groups is
   reasonably small, but it should be used only on the intranet, not on
   the external Internet.  One significant drawback of this approach is
   that some operating systems - most notably Windows 95 - do not
   respond to multicast ICMP ECHOs.  However, this approach has been
   shown to work on a large, all-Unix network.

   Another possibility - less desirable still - is for each node to
   explicitly notify the firewall whenever it joins, or leaves, a
   multicast group.  This requires changes to the node&#x27;s operating
   system or libraries, or cooperation from the application.  Therefore
   this technique, like the previous one, is applicable only within the
   intranet, not the external Internet.  Note that if multicast
   applications are always launched from a special &quot;session directory&quot;
   or &quot;channel guide&quot; application, then this application may be the only
   one that need be aware of having to contact the firewall.

   What makes the latter two approaches (&quot;probing&quot; and &quot;explicit
   notification&quot;) undesirable is that they duplicate some of the
   existing functionality of multicast routing, and in a way that scales
   poorly for large networks.  Therefore, if possible, firewalls should
   attempt to make use of existing multicast routing information: either
   IGMP (for a single-subnet intranet), or &quot;Domain Wide Multicast Group
   Membership Reports&quot;.

   In some circumstances, however, the client cannot avoid contacting
   the firewall prior to joining a multicast session.  In this case, it
   may make sense for this contact to also act as a &#x27;notification&#x27;
   operation.  Consider, for example, an RTSP [<a href="#ref-8" title="&quot;Real Time Streaming Protocol (RTSP)&quot;">8</a>] proxy associated with
   the firewall.  When the proxy receives a request - from an internal
   user - to open a remote RTSP session, the proxy might examine the
   response from the remote site, to check whether a multicast session
   is being launched, and if so, check whether the multicast group(s)
   are candidates to be relayed.










<span class="grey">Finlayson                    Informational                      [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>. Relaying Candidate Groups</span>

   The actual mechanism that&#x27;s used to relay multicast packets will
   depend upon the nature of the firewall.  One common firewall
   configuration is to use two nodes: one part of the intranet; the
   other part of the external Internet.  In this case, multicast packets
   would be relayed between these two nodes (and then re-multicast on
   the other side) using a tunneling protocol.

   A tunneling protocol for multicast should *not* run on top of TCP,
   because the reliability and ordering guarantees that TCP provides are
   unnecessary for multicast communication (where any reliability is
   provided at a higher level), yet would add latency.  Instead, a UDP-
   based tunneling protocol is a better fit for relaying multicast
   packets.  (If congestion avoidance is a concern, then the tunnel
   traffic could be rate-limited, perhaps on a per-group basis.)

   One possible tunneling protocol is the &quot;UDP Multicast Tunneling
   Protocol&quot; (UMTP) [<a href="#ref-9" title="&quot;The UDP Multicast Tunneling Protocol&quot;">9</a>].  Although this protocol was originally designed
   as a mechanism for connecting individual client machines to the
   MBone, it is also a natural fit for for use across firewalls.  UMTP
   uses only a single UDP port, in each direction, for its tunneleling,
   so an existing firewall can easily be configured to support multicast
   relaying, by adding a UMTP implementation at each end, and enabling
   the UDP port for tunneling.

   Notes:

      (i)  When multicast packets are relayed from the intranet onto the
           external Internet, they should be given the same TTL that
           they had when they arrived on the firewall&#x27;s internal
           interface (except decremented by 1).  Therefore, the internal
           end of the multicast relay mechanism needs to be able to read
           the TTL of incoming packets.  (This may require special
           privileges.)  In contrast, the TTL of packets being relayed
           in the other direction - from the external Internet onto the
           intranet - is usually less important; some default value
           (sufficient to reach the whole intranet) will usually
           suffice.  Thus, the Internet end of the multicast relay
           mechanism - which might be less trusted than the intranet end
           - need not run with special privileges.
      (ii) One end of the multicast tunnel - usually the intranet end -
           will typically act as the controller (i.e., &quot;master&quot;) of the
           tunnel, with the other end - usually the Internet end -
           acting as a &quot;slave&quot;.  For security, the &quot;master&quot; end of the
           tunnel should be configured not to accept any commands from
           the &quot;slave&quot; (which will often be less trusted).




<span class="grey">Finlayson                    Informational                      [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>. Networks With More Than One Firewall</span>

   So far we have assumed that there is only one firewall between the
   intranet and the external Internet.  If, however, the intranet has
   more than one firewall, then it&#x27;s important that no single multicast
   group be relayed by more than one firewall.  Otherwise (because
   firewalls are assumed to be application-level gateways - not proper
   multicast routers), packets sent to any such group would become
   replicated on the other side of the firewalls.  The set of candidate
   groups must therefore be partitioned among the firewalls (so that
   exactly one firewall has responsibility for relaying each candidate
   group).  Clearly, this will require coordination between the
   administrators of the respective firewalls.

   As a general rule, candidate groups should be assigned - if possible
   - to the firewall that is topologically closest to most of the group
   members (on both the intranet and the external Internet).  For
   example, if a company&#x27;s intranet spans the Atlantic, with firewalls
   in New York and London, then groups with mostly North American
   members should be assigned to the New York firewall, and groups with
   mostly European members should be assigned to the London firewall.
   (Unfortunately, even if a group has many internal and external
   members on both sides of the Atlantic, only one firewall will be
   allowed to relay it.  Some inefficiencies in the data delivery tree
   are unavoidable in this case.)

<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>. Why SOCKS is Less Appropriate for Multicast</span>

   SOCKS [<a href="#ref-10" title="Koblas">10</a>] is a mechanism for transparently performing unicast
   communication across a firewall.  A special client library -
   simulating the regular &#x27;sockets&#x27; library - sits between applications
   and the transport level.  A conversation between a pair of nodes is
   implemented (transparently) as a pair of conversations: one between
   the first node and a firewall; the other between the firewall and the
   second node.

   In contrast, because multicast communication does not involve a
   conversation between a pair of nodes, the SOCKS model is less
   appropriate.  Although multicast communication across a firewall is
   implemented as two separate multicast communications (one inside the
   firewall; the other outside), the *same* multicast address(es) and
   port(s) are used on both sides of the firewall.  Thus, multicast
   applications running inside the firewall see the same environment as
   those running outside, so there is no need for them to use a special
   library.






<span class="grey">Finlayson                    Informational                      [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


   Nonetheless, there has been a proposal [<a href="#ref-11" title="&quot;SOCKS V5 UDP and Multicast Extensions&quot;">11</a>] to extend SOCKS V5 to
   support multicast.  This proposal includes two possible modes of
   communication:

      (i)  &quot;MU-mode&quot;, uses only *unicast* communication within the
           intranet (between the firewall and each internal group
           member), and
      (ii) &quot;MM-mode&quot;, which uses unicast for client-to-firewall relay
           control, but uses *multicast* for other communication within
           the intranet.

   As noted in <a href="#section-2">section 2</a> above, &quot;MU-mode&quot; would be a poor choice
   (unless, for some reason, the intranet does not support multicast
   routing at all).  If multicast routing is available, there should
   rarely be a compelling reason to replace multicast with &#x27;multiple-
   unicast&#x27;.  Not only does this scale badly, but it also requires
   (otherwise unnecessary) changes to each application node, because the
   multicast service model is different from that of unicast.

   On the other hand, &quot;MM-mode&quot; (or some variant thereof) *might* be
   useful in environments where a firewall can learn about group
   membership only via &quot;explicit notification&quot;.  In this case each node
   might use SOCKS to notify the firewall whenever it joins and leaves a
   group.  However, as we explained above, this should only be
   considered as a last resort - a far better solution is to leverage
   off the existing multicast routing mechanism.

   It has been suggested [<a href="#ref-11" title="&quot;SOCKS V5 UDP and Multicast Extensions&quot;">11</a>] that a benefit of using multicast SOCKS
   (or an &quot;explicit notification&quot; scheme in general) is that it allows
   the firewall to authenticate a client&#x27;s multicast &quot;join&quot; and &quot;leave&quot;
   operations.  This, however, does not provide any security, because it
   does not prevent other clients within the intranet from joining the
   multicast session (and receiving packets), nor from sending packets
   to the multicast session.  As we noted in <a href="#section-3">section 3</a> above,
   authentication and privacy in multicast sessions is usually obtained
   by signing and encrypting the multicast data, not by attempting to
   impose low-level restrictions on group membership.  We note also that
   even if group membership inside the intranet could be restricted, it
   would not be possible, in general, to impose any such membership
   restrictions on the external Internet.

<span class="h2"><a class="selflink" id="section-11" href="#section-11">11</a>. Security Considerations</span>

   Once a security policy has been established, the techniques described
   in this document can be used to implement this policy.  No security
   mechanism, however, can overcome a badly designed security policy.
   Specifically, network administrators must be confident that the
   multicast groups/ports that they designate as being &#x27;safe&#x27; really are



<span class="grey">Finlayson                    Informational                      [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


   free from harmful data.  In particular, administrators must be
   familiar with the applications that will receive and process
   multicast data, and (as with unicast applications) be confident that
   they cannot cause harm (e.g., by executing unsafe code received over
   the network).

   Because it is possible for an adversary to initiate a &quot;denial of
   service&quot; attack by flooding an otherwise-legitimate multicast group
   with garbage, administrators may also wish to guard against this by
   placing bandwidth limits on cross-firewall relaying.

<span class="h2"><a class="selflink" id="section-12" href="#section-12">12</a>. Summary</span>

   Bringing IP multicast across a firewall requires that the intranet
   first establish a multicast security policy that defines which
   multicast groups (&amp; corresponding UDP ports) are candidates to be
   relayed across the firewall.  The firewall implements this policy by
   dynamically determining when each candidate group/port needs to be
   relayed, and then by doing the actual relaying.  This document has
   outlined how a firewall can perform these tasks.

<span class="h2"><a class="selflink" id="section-13" href="#section-13">13</a>. References</span>

   [<a id="ref-1">1</a>] Deering, S., &quot;Host Extensions for IP Multicasting&quot;, STD 5, <a href="/doc/html/rfc1112">RFC</a>
       <a href="/doc/html/rfc1112">1112</a>, August 1989.

   [<a id="ref-2">2</a>] Djahandari, K., Sterne, D. F., &quot;An MBone Proxy for an Application
       Gateway Firewall&quot; IEEE Symposium on Security and Privacy, 1997.

   [<a id="ref-3">3</a>] Freed, N. and K. Carosso, &quot;An Internet Firewall Transparency
       Requirement&quot;, Work in Progress.

   [<a id="ref-4">4</a>] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, &quot;RTP:
       A Transport Protocol for Real-Time Applications&quot;, <a href="/doc/html/rfc1889">RFC 1889</a>,
       January 1996.

   [<a id="ref-5">5</a>] Handley, M. and V. Jacobson, &quot;SDP: Session Description Protocol&quot;,
       <a href="/doc/html/rfc2327">RFC 2327</a>, April 1998.

   [<a id="ref-6">6</a>] Meyer, D., &quot;Administratively Scoped IP Multicast&quot;, <a href="/doc/html/bcp23">BCP 23</a>, <a href="/doc/html/rfc2365">RFC</a>
       <a href="/doc/html/rfc2365">2365</a> July 1998.

   [<a id="ref-7">7</a>] Fenner, B., &quot;Domain Wide Multicast Group Membership Reports&quot;,
       Work in Progress.

   [<a id="ref-8">8</a>] Schulzrinne, H., Rao, A. and R. Lanphier, &quot;Real Time Streaming
       Protocol (RTSP)&quot;, <a href="/doc/html/rfc2326">RFC 2326</a>, April 1998.




<span class="grey">Finlayson                    Informational                     [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


   [<a id="ref-9">9</a>] Finlayson, R., &quot;The UDP Multicast Tunneling Protocol&quot;, Work in
       Progress.

   [<a id="ref-10">10</a>] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D. and L.
        Joned, SOCKS Protocol Version 5&quot;, <a href="/doc/html/rfc1928">RFC 1928</a>, April 1996.

   [<a id="ref-11">11</a>] Chouinard, D., &quot;SOCKS V5 UDP and Multicast Extensions&quot;, Work in
        Progress.

<span class="h2"><a class="selflink" id="section-14" href="#section-14">14</a>. Author&#x27;s Address</span>

   Ross Finlayson,
   Live Networks, Inc. (LIVE.COM)

   EMail: finlayson@live.com
   WWW: <a href="http://www.live.com/">http://www.live.com/</a>



































<span class="grey">Finlayson                    Informational                     [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey"><a href="/doc/html/rfc2588">RFC 2588</a>               IP Multicast and Firewalls               May 1999</span>


<span class="h2"><a class="selflink" id="section-15" href="#section-15">15</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   &quot;AS IS&quot; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Finlayson                    Informational                     [Page 12]
</pre>
    </div>

  </div>


        
	  </div>

	

	

    </div>

      
      <script>$(".visible-nojs").removeClass("visible-nojs");</script>
      <script>$(".hidden-nojs").removeClass("hidden-nojs");</script>
      
    <script type="text/javascript"><!--
    var legend_html = "Colour legend:<br /> \
     <table> \
        <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
    </table>";
    function showLegend() {
        var elem = document.getElementById('legend');
        elem.innerHTML = legend_html
        elem.style.visibility='visible';
    }
    function hideLegend() {
        var elem = document.getElementById('legend');
        elem.style.visibility='hidden';
        elem.innerHTML = "";
    }
    // -->
    </script>

  </body>
</html>

